# Chapter 12

## 1. 웹사이트와 성능

웹사이트의 성능은 다음과 같은 요소에 영항을 미침

* 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트 보다 전자상거래 전환율이 2.5배 높음
* 0\~5 초의 범위에서, 1초 로딩이 늦어질 수록 전환율은 4.42%씩 떨어짐. ⇒ 5초 이상 느려지면 전환율은 20% 가까이 떨어짐.
* 페이지 로드 시간이 0\~2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있음

그리고 사용자 또한 이러한 성능에 매우 민감함

* 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는데 영향을 미친다고 밝혔으며
* 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요없다고 밝힘

구글에서도 비슷하게 웹사이트에 관한 통계를 내놓음

* 전체 웹페이지를 표시하는데 필요한 최적의 평균 리소스 요청 수는 50회 미만.
* 평균적으로 웹 페이지 전체를 요청하는데 15.3초가 걸림
* 인간의 뇌와 신경계를 분석한 결과, 페이지 로드 시간이 1초에서 10초로 늘어날 수록 모바일 사이트를 이탈할 확률이 123% 증가

과거 웹 사이트의 성능은 단순히 웹사이트의 로딩속도, 방문이나 결제 같은 실제 목표로 이뤄지는 전환율 등으로만 지엽적으로 판단했으나 구글은 핵심 웹 지표라고 하는 몇가지 핵심적인 요소를 꼽고 이에대한 지표를 제시하고 있음.

## 2. 핵심 웹 지표란?

구글에서 만든 지표. 웹사이트에서 뛰어난 사용자 경험을 제공하는데 필수적인 지표를 일컫는 용어임.

* 최대 콘텐츠풀 페인트(LCP: Lagest Contentful Paint)
* 최초 입력 지연(FID: First Input Delay)
* 누적 레이아웃 이동(CLS: Cumulative Layout Shift)

그리고 다음 두 지표는 핵심은 아니지만 특정 문제를 진단하는데 사용할 수 있음

* 최초 바이트까지의 시간(TTFB: Time To First Byte)
* 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

## 3. 최대 콘텐츠풀 페인트(LCP)

### 1. 정의

페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는데 걸리는 시간을 말함.

* 뷰포트: 사용자에게 현재 노출되는 화면을 의미한다. 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다름.
* 뷰포트 내에서의 큰 이미지와 텍스트
  *
  * 내부의
  * poster 속성을 사용하는&#x20;
  * url()을 통해 불러온 배경 이미지가 있는 요소
  * 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
    *   이 블록 레벨 요소에는

        ,

        등이 포함

### 2. 의미

무엇으로 기준을 측정하면 될지 첫번째로 떠오르는 건 DOMContetLoaded 이벤트가 호출되는 시간.

DOMContentLoaded: HTMl 문서를 완전히 불러오고 파싱했을 떄 발생하는 이벤트로, 페이지의 document를 대상으로 일어나며 단 한번만 호출됨.

그러나 이 이벤트가 발생했다고 해서 사용자 또한 페이지가 로딩됐다고 인식할 것이라 기대하기에는 무리가 있음. 왜냐하면 이 이벤트는 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다는 제한이 있기 때문

그렇다면 사용자가 페이지가 어느정도 로딩됐다고 인식하는 시점은 언제일까?

⇒ 사용자가 페이지 로딩을 체감하기 위해 꼭 페이지가 완전히 로딩될 필요는 없음. 일단 사용자에게 노출되는 부분만 로딩되어 있다면 사용자는 페이지 로딩이 완료됐다고 느낄것.

단순히 사용자에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 할것이므로 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면 사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을것.

사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것이 최대 콘텐츠풀 페인트

### 4. 기준 점수

* 직접 자바스크립트 API를 호출하는 방법
* 다른 도구를 활용하는 방법 ⇒ 손쉬운 측정을 위해 많이들 택함

좋은 점수 ⇒ 해당 지표가 2.5초 내로 응답이 오는것. 보통은 4초 이내. 그 이상은 나쁨

### 5. 개선 방안

#### 텍스트는 언제나 옳다

좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대영역, 즉 최대 콘텐츠풀페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것. 아무리 이미지를 최적화 하더라도 추가적인 리소스 다운로드가 필요한 이미지보다 텍스트 노출이 훨씬 더 빠름.

#### 이미지를 어떻게 불러올 것인가?

```jsx
<!-- 1)  img -->
<img src="lcp.jpg" />

<!-- 2) svg == >
<svg xmlns="http://www.w3.org/1000/svg">
	<image href="lcp.jpg" />
</svg>
<!-- 3) (비디오의 경우) video.poster -->
<vidow poster="lcp.jpg"></video>
<!-- 4) background-image: url() -->
<div style="background-image: url(lcp.jpg)")>...</div>
```

* 내부의  : 가 미처 로딩되는 시점. 만 로딩된 시점에 이미 최대 콘텐츠풀 페인트가 완료된 것으로 간주 이는 크롬 102 버전 이하의 버그로, 이후 버전에서는 수정됨. 수정된 버전에서는 내부의 가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않음. 또 모든 리소스를 다 불러온 이후에 이미지를 불러온다는 것.⇒ 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않음. 이는 결국 최대 콘텐츠풀 페인트 점수에도 악영향을 미치므로 이러한 방식은 삼가는 것이 좋음
* 의 poster: poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소. 이 역시 마찬가지로 프리로드 스캐너에 의해 조기에 발견되어 와 같은 성능을 나타냄. 향후에 poster가 없는 video의 경우 video를 실제로 로딩해 첫번쨰 프레임을 해당 poster 리소스로 대채헬 예정.
* background-image: url() : background-image를 비롯해서 CSS에 있는 리소스는 항상 느림. 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될때까지 리소스 요청을 뒤로 미루기 때문이다. 이것은 최대 콘텐츠풀 페인트에도 좋은 영향을 미치지 않음.

#### 그 밖에 조심해야 할 사항

* 이미지 무손실 압축 : 웹으로 서비스할 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋음
* loading=lazy 주의: 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로 , 등에 적용할 수 있지만 문제는 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안됨. 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않음.
* fadein과 같은 각종 애니메이션: 그냥 이미지가 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어짐
* 클라이언트에서 빌드하지 말것
* 최대 콘텐츠풀 리소스는 직접 호스팅 : 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋음. 일반적인 경우 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고, 포맷도 변환하고, 압축해 이미지를 관리하지만 다른 출처에서 이렇게 정제한 이미지를 가져오는 것ㅇ느 최적화에 별로 좋은 영향을 미치지 않음. 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문

## 4. 최초 입력 지연(FID)

### 1. 정의

사용자가 페이지와 처음 상호작용할때부터 해당 상호 작요에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정

### 2. 의미

이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있음,.

구글은 사용자 경험을 크게 4가지로 분류해 정의하는데, 이를 RAIL이라고 함

* Response: 사용자의 입력에 대한 반응속도. 50ms 미만으로 이벤트를 처리할 것
* Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
* Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할것
* Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

### 4. 기준 점수

* 좋은 점수 : 100ms 이내로 응답이 와야함
* 보통 점수 : 300ms 이내
* 나쁨 : 그 이후의 경우

### 5. 개선방안

#### 실행에 오래 걸리는 긴 작업을 분리

* 꼭 웹페이지에서 해야하는 작업인가
* 긴 작업을 여러개로 분리하기

#### 자바스크립트 코드 최소화

번들러가 코드를 만들어주는 과정에서 어느정도 필요없는 코드를 제거해 준다고 하지만 여전히 경우에 따라 웹페이지를 불러오는 데 사용되지 않는 필요없는 코드가 존재할 수 있음. 이러한 코드를 크롬 개발자 도구를 통해 확인할 수 있음.

폴리필: 브라우저에서 지우너하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드를 의미. 풀리필의 크기는 제법 크기 때문에 집어넣기 전에 두가지를 확인해야 함

1. 풀리필이 필요한 환경인지
2. 꼭 필요한 풀리필인지

#### 타사 자바스크립트 코드 실행의 지연

타사 스크립트 는 대부분 웹페이지 로드에 중요한 자원이 아니므로의 async와 defer를 이용하여 지연 불러오기를 하는게 좋음

* defer: 먼저 해당 스크립트를 다른 리소스와 함꼐 병렬로 다운로드 이 스크립트의 실행은 페이지가 완전히 로딩된 이후 맨 마지막에 실행
* async: script에 async 속성이 있다면 마찬가지로 해당 스크립트를 다른 리소스와 함꼐 병렬로 다운로드. 다운로드가 완료되면 다른 리소스의 다운로드를 기다리지 않고 바로 실행.
* 둘다 없는 경우 : script를 만나는 순간 다운로드가 우선되며 다운로드가 완료되면 코드 실행이 우선됨. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄짐.

타사 스크립트는 가능하다면 async, 더 가능하다면 defer로 지연하는 것이 좋음.

## 5. 누적 레이아웃 이동(CLS)

### 1. 정의

페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것. 다른 지표와 마찬가지로 이 지표가 낮을 수록 더 좋은 웹사이트

### 2. 의미

과거의 웹사이트는 제한적인 트래픽과 리소스로 인해 제공하는 정보가 굉장히 한정적이었음. 현재의 웹사이트는 클라이언트에서 처리하는 작업이 많음.

누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정하며, 뷰포트 밖의 요소에 대해서는 측정하지 않음. 최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생한다면 누적 레이아웃 이동 점수로 기록. 요소가 추가되어도 다른 요소의 시작위치에 영향을 미치지 않았다면 레이아웃 이동으로 간주되지 않음.

* 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미
* 거리분율 : 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미

### 4. 기준 점수

* 좋음 : 0.1 이하
* 보통 : 0.25 이하
* 나쁨 : 그 외

### 5. 개선 방안

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

스켈레톤 UI의 사례 처럼 미리 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이며 가장 좋은 방법은 서버 사이드 렌더링

무엇보다 뷰포트 영역은 사용자에게 첫번째로 이 웹페이지에 대한 인상을 주는 가장 중요한 영역이므로 동적인 콘텐츠를 제공할 지를 신중하게 고민해야 함.

#### 폰트 로딩 최적화

폰트 또한 레이아웃 이동을 일으키는 원인 중 하나. 폰트로 발생할 수 있는 문제는 크게 두가지

* FOUT(flash of unstyled text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
* FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

폰트는 각각 고유의 높이와 너비를 가지고 있음. 즉 미처 지정한 폰트가 다운로드되기 전에 텍스트를 노출하려고 한다면 높이와 크기가 다른 기본 폰트를 기반으로 한 텍스트를 노출해서, 혹은 미처 ㅌ텍스트를 노출하지 못해 누적 레이아웃 이동이 발생할 수 있음.

* 의 preload 사용: 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능
* font-family: optional: 폰트를 불어올 수 있는 방법은 크게 다섯가지로 나눔
  * auto(기본값): 브라우저가 폰트를 불러오는 방법
  * block: 폰트가 로딩되기 전까지 렌더링을 중단. 완료되면 적용
  * swap: 앞서 언급한 FOUT 방식. 우선 폴백 폰트로 렌더링 후 로딩이 완료되면 웹 폰트를 적용
  * fallback: 이 옵션을 사용하면 100ms간 텍스트가 보이지 않고 그 이후 폴백 폰트로 렌러딩. 그리고 3초 이내로 폰트가 로딩되면 해당 웹 폰트로 전환하고 그렇지 않다면 폴백 폰트를 계속 사용
  * optional: fallback과 매우 유사. 100ms 간 텍스트가 보이지 않고 폴백 폰트로 렌더링 하는 것은 동일함. 그러나 0.1초 이내로 폰트가 다운로드 돼있거나, 캐시되어있지 않다면 폴백 폰트를 사용. 또 브라우저가 네트워크 상태를 파악해 일정 기간 폰트를 다운로드 하지 못하면 연결을 취소.

#### 적절한 이미지 크기 설정

* width, height 지정
* 만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하고 반응형 이미지를 사용하고 싶다면 srcset 속성을 사용하는 것이 좋음. 비율이 같고 크기가 다른 여러개의 이미지를 미리 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 됨

### 6. 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표

#### 최초 바이트까지의 시간(Time to First Byte, TTFB)

#### 최초 콘텐츠풀 페인트(First Contentful Panit, FCP)
