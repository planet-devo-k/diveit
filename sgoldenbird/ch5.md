# Takeaways

## 상태 관리는 왜 필요한가?

### 상태

* 어떠한 의미를 지난 값. 애플리케이션 시나리오에 따라 지속적으로 변경될 수 있는 값
* 상호작용이 가능한 모든 요소의 현재 값

### 웹 애플리 케이션에서 상태로 분류될 수 있는 것들 예

* UI
* URL: 브라우저에서 관리되고 있는 상태값. 사용자의 라우팅에 따라 변경된다. (동적으로 변경되는 params 같은것)
* form: loading, submit, disabled, validation 등
* 요청: 서버로 요청해 가져온 값 (API 요청 등)

### Flux 패턴의 등장

* MVC 패턴에서 데이터가 양방향으로 흘러 상태를 추적하고 이해하는 것이 매우 어려운 상황 → 페이스북은 문제의 원인을 양방향 데이터 바인딩으로 봤다.
  * 뷰(HTML)와 모델(자바스크립트)이 서로를 변경할 수 있다보니 코드를 작성할때는 간단해도 관리하기에는 어려움. → 단방향으로 데이터 흐름 변경
  * 항상 Action → Dispatcher → Store → View라는 일정한 방향으로만 데이터가 흐르도록 설계된 것이 특징입니다.
* 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트 해야하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 개발자가 수고스러워지기는 함
* 그러나 데이터 흐름을 추적하기 쉽고 코드 이해가 수월.

![Flux](../.gitbook/assets/Flux.png)

* action: 무엇을 할지 정의하는 객체
  * 어떤 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
* dispatcher: 들어온 Action을 받아서 모든 Store로 전달하는 허브.
  * 콜백함수 형태로 앞서 액션이 정의한 타입과 데이터를 스토어에 보내는 역할
* store: 애플리케이션의 상태(데이터)와 로직을 저장. 상태가 변경되면 View에 알림
  * 실제 상태에 따른 값과 상태를 변경할 수 잇는 메서드. 액션 타입에 따라 어떻게 변경할지가 정의되어 있다.
* view: 화면을 렌더링하고, 사용자 입력이 있으면 다시 Action을 발생시킴
  * 리액트 컴포넌트에 해당하는 부분. 스토어에서 만들어진 데이터를 가져와 화면을 렌더링.
  * 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 때 액션을 호출.

### 리덕스의 등장

* Flux구조 + Elm 아키텍처
  * Elm: 웹페이지를 선언적으로 작성하기 위한 언어. Flux와 마찬가지로 데이터 흐름을 단방향으로 강제하고 세가지로 분류.
    * Model: 애플리케이션의 상태
    * View: 모델을 표현하는 HTML
    * Update: 모델을 수정하는 방식
* 리덕스는 하나의 글로벌 상태 객체를 스토어에 저장해두고 이 객체를 업데이트하는 작업을 디스패치해 업데이트 수행
  * props drilling 문제 해결
  * 컴포넌트에서 connect로 스토어에 바로 접근
* 단점
  * 단순히 하나의 상태를 바꾸고 싶어도 할일이 너무 많다. 하고자하는 일에 비해 보일러 플레이트가 너무 많다.
    * 어떤 액션인지 타입 선언, 이 액션을 수행할 creator 함수 생성
    * dispatcher, selector도 필요하고,
    * 새로운 상태가 기존의 reducer 내부에서 어떤 식으로 변경돼야할지, 혹은 새로 만들어야 할지 정의 필요
  * 지금은 많이 간소화되긴 했다.

### ContextAPI와 useContext

* ContextAPI는 상태 관리가 아니라 전역 상태 주입을 도와주는 역할
* 원하는 곳에서 Context Provider가 주입하는 상태 사용 가능

### 훅의 탄생, 그리고 React Query와 SWR(Stale-While-Revalidate)

* HTTP요청에 특화된, API 호출에 대한 상태 관리 라이브러리
* SWR
  * 첫번째 인수: 조회할 API 주소(키로 사용)
  * 두번째 인수: 조회에 사용하는 fetch

### Recoil, Zustand, Jotai, Valtio

* 기존의 리덕스 같은 라이브러리와 달리 훅을 활용해 작은 크기의 상태를 효율적으로 관리
* 기존 상태 관리 라이브러리의 아쉬운 점으로 지적받던 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었다.

## 리액트 훅으로 시작하는 상태 관리

### 가장 기본적인 방법: useState, useReducer

* 두 훅 모두 지역상태 관리를 위해 만들어졌다.
* useState의 등장으로 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리
* useState는 useReducer로 구현됐다.
* 한계
  * 훅을 사용할 때 마다 컴포넌트 별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다. 컴포넌트별로 상태의 파편화를 만들어 버린다.
  * 이렇게 기본적인 useState를 기반으로 한 상태를 지역상태라고 하며 이 지역 상태는 해당 컴포넌트 내에서만 유효하다.
  * useState는 리액트가 만든 클로저 내부에서 관리되어 지역상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있는 것.

### 지역 상태의 한계를 벗아나 useState의 상태를 바깥으로 분리하기

함수 외부에서 상태를 참조하고, 이를 통해 렌더링까지 자연스럽게 일어나려면 아래 조건들을 만족시켜야 한다. (리렌더링이 되야 업데이트된 상태를 컴포넌트에 반영시킬 수 있다.)

1. 꼭 window, global에 있을 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 이 외부 상태를 사용하는 컴포넌트들은 상태 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야한다.
3. 상태가 원시값이 아닌 객체라면 그 객체에 내가 감지하지 않는 값이 변했을때는 리렌더링이 발생해서는 안된다.

* 위 조건을 만족하는 상태는 객체일수도 원시값일수도 있으므로 범용적인 이름인 store로 정의
* store 값이 변경될 때마다 알리는 callback함수 실행, 이 콜백을 등록할 수 있는 subscribe함수 필요.
  * store의 변경을 감지하고 싶은 컴포넌트들이 자신의 callback함수를 subscribe에 등록
  * subscribe에 컴포넌트 자기 자신을 렌더링하는 코드를 추가해 리렌더링 실행
* store는 값이 변경될 때마다 자신에게 등록된 모든 callback을 실행하게 한다.
* → useSubscription을 사용하면 외부 데이터를 가져와서 사용하고 리렌더링까지 수행
* → 리액트 18로 넘어오면서 기존의 useSubscription이나 수동으로 useEffect를 써서 외부 상태를 구독하던 방식들이 useSyncExternalStore 훅으로 통합
  * 리액트 18에는 화면을 렌더링하는 도중 더 급한 작업이 들어오면 렌더링을 잠시 멈추는 동시성(Concurrency) 기능이 들어갔습니다. 이때 외부 저장소(Redux, Zustand, 브라우저 API 등)의 데이터가 렌더링 중간에 바뀌어버리면, 화면의 윗부분과 아랫부분이 서로 다른 데이터를 보여주는 테어링 현상이 발생할 수 있습니다.
  * useSyncExternalStore는 이 문제를 해결하기 위해 "외부 상태 업데이트를 리액트 렌더링과 동기화"해주는 전용 훅으로 설계되었습니다.

### useState와 Context를 동시에 사용해보기

* 훅은 스토어에 의존적인 1:1 관계를 맺고 있으므로 스토어를 만들 때마다 해당 스토어에 의존적인 useStore 같은 훅을 동일한 개수로 생성해야 한다.
  * 이 훅이 어느 스토어에서 사용 가능한지 가늠하려면 오직 훅의 이름이나 스토어의 이름에 의지
* → Context를 활용해 해당 스토어를 하위 컴포넌트에 주입하면 컴포넌트에서는 자신이 주입된 스토어에 대해서만 접근.

### 상태 관리 라이브러리 작동 방식 정리

* useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다.
  * 이는 컴포넌트 최상단 내지는 상태가 필요한 부모가 될수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가 일수도 있다.
* 이 외부 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.
* 리액트에서 리렌더링을 일으키기 위한 방식은 제한적이기 때문에 어떠한 방식으로 상태를 관리하든 리렌더링을 만드는 방법은 모두 거의 동일
* npm에서 제공하는 모든 라이브러리와 마찬가지로 메인테이너가 많고 다운로드가 활발하며 이슈 관리가 잘 되고 있는 라이브러리를 선택 → 장기적인 유지보수 및 개선

### 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

* Recoil, Jotai
  * Context와 훅을 기반으로 작은상태를 효율적으로 관리하는데 초점
* Zustand
  * 리덕스 비슷하게 하나의 큰 스토어를 기반으로 상태 관리
  * Recoil, Jotai와는 다르게 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성
  * 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식

#### facebook이 만든 상태 관리 라이브러리 Recoil

* Recoil 핵심 API
  * RecoilRoot
    * 애플리케이션 최상단에 선언
    * Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장
    * 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경
    * 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.
  * atom
    * 상태를 나타내는 리코일의 최소 상태 단위
    * key값 필수. 이 키는 다른 atom과 구별하는 식별자. 애플리케이션 내부에서 유일한 값이어야 한다.
  * atom의 값을 컴포넌트에서 읽어오고 값의 변화에 따라 컴포넌트를 리렌더링하는 훅 2개
    * useRecoilValue: atom 값을 읽어오는 훅
    * useRecoilState: 값을 가져오고 변경할수도 있는 훅
* 기타 API
  * selector
    * 한개 이상의 atom값을 바탕으로 새로운 값을 조립할 수 있는 API
  * atom에 비동기 작업 추가 API
    * useRecoilStateLoadable, waitForAll, waitForAny, waitForAllSettled
* 요약
  * 먼저 애플리케이션 최상단에 `<RecoilRoot/>`를 선언해 하나의 스토어를 만들고,
  * atom이라는 상태 단위를 그 스토어에 등록
  * 컴포넌트는 리코일에서 제공하는 훅을 통해 atom의 상태 변화를 구독하고 값이 변경되면 forceUpdate같은 기법을 통해 리렌더링을 실행해 최신 atom값을 가져온다.
* 특징
  * 리덕스와 달리 redux-saga, redux-thunk 등 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다.
* 리코일은 메인테인이 중단된 상태.

#### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai

* Jotai는 상향식(bottom-up) 접근법을 취하고 있다. 이는 리덕스처럼 하나의 큰 상태르 애플리케이션에 내려주는 방식이 아니라 작은 단위의 상태를 위초 전파하는 구조.
* 리액트 Context의 문제점인 불필요한 리렌더링을 해결하고자 설계돼 있다.
* 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계
* atom
  * 최소 단위의 상태
  * 리코일과는 다르게 atom하나만으로도 상태를 만들수도 있고 또 이에 파생된 상태를 만들 수도 있다.
  * Jotai는 각 atom을 생성할 때마다 고유한 key를 필요로 했던 recoil과는 달리 atom을 생성할 때 별도의 key를 넘겨주지 않아도 된다.
    * atom내부에는 key라는 변수가 존재하긴 하지만 외부에서 받는 값은 아니며 단순히 toString을 위한 용도로 한정돼 있다.
  * config라는 객체를 반환하는데 이 config에는 초깃값을 의미하는 init, 값을 가져오는 read, 값을 설정하는 write만 존재한다. 즉, Jotai에서 atom에 따로 상태를 저장하고 있지 않다.
* useAtomValue
  * useReducer에서 반환하는 상태값 3가지 \[version, valueFromReducer, atomFromReducer]
    * store의 버전
    * atom에서 get을 수행했을 때 반환되는 값
    * atom 그 자체
  * 리코일과 달리 컴포넌트 루트 레벨에서 context가 존재하지 않아도 된다. Context가 없다면 기본 스토어를 루트에 생성하고 이를 활용해 값을 저장하기 때문
  * atom값은 store에 존재한다. store에 atom객체 그 자체를 키로 활용해 값을 저장한다. 이런 방식을 위해 WeakMap이라고 하는 자바스크립트에서 객체만을 키로 가질수 있는 독특한 방식의 Map을 활용해 recoil과는 다르게 별도의 key를 받지 않아도 스토어에 값을 저장할 수 있다.
  * rerenderIfChanged를 통해 넘겨받은 atom이 스토어에 있는 atom과 다르거나 subscribe를 수행하고 있다가 어디선가 이 값이 달라진 경우, 즉 atom값이 어디서 변경되더라도 useAtomValue로 값을 사용하는 쪽에선느 언제든 최신 값의 atom을 사용해 렌더링 할 수 있다.
* useAtom
  * useState와 동일한 형태의 배열 반환. 첫번째로는 atom의 현재 값을 나타내는 useAtomValue훅의 결과 반환, 두번째로는 useSetAtom 훅 반환(atom 수정 기능)
  * 스토어 내부에서 해당 atom을 찾아 직접 값을 업데이트.
  * 스토어에서 새로운 값을 작성한 후에는 해당 값의 변화에 대해 알고 있어야하는 listener함수를 실행해 값의 변화가 있음을 전파하고 사용하는 쪽에서 리렌더링이 수행되게 한다.
* Jotai에서 상태를 선언하기 위해서는 atom이라는 API를 사용한다. 이 API는 리액트의 useState와는 다르게 컴포넌트 외부에서도 선언할 수 있다.
* atom은 값뿐만 아니라 함수를 인수로 받을수 있는데 이런 특징을 활용해 다른 atom의 값으로부터 파생된 atom을 만들수도 있다.
* atom은 컴포넌트 내부에서 useAtom을 활용해 useState비슷하게 사용하거나 useAtomValue를 통해 getter만 가져올 수 있다.
* 기본적인 API외에도 localStorage와연동해 영구적으로 데이터를 저장하거나 Next.js리액트 네이티브와 연동하는 등 지원
* 특징
  * 리코일의 atom개념을 도입하면서도 API가 간결하다.
  * 리코일의 atom에서는 상태값이 모두 별도의 키를 필요로 하기 때문에 이 키를 별도로 관리해야했는데 Jotai는 이런 부분을 추상화해 사용자가 키를 관리할 필요가 없다. Jotai가 별도의 문자열 키가 없어도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 값을 관리하기 때문이다. 객체의 참조를 WeakMap에 보관해 해당 객체 자체가 변경되지 않는 한 별도의 키가 없이도 객체의 참조를 통해 값을 관리할 수 있다.
  * 리코일에서는 atom에서 파생된 값을 만들기 위해 selector가 필요했지만 Jotai에서는 selector없이도 atom만으로 atom값에서 또 다른 파생된 상태를 만들 수 있다.
  * Jotai 자체도 여타 다른 라이브러리와 마찬가지로 타입스크립트로 작성돼 있어 타입을 잘 지원하고 있다. (이는 Flow로 작성되어 별도로 d.ts를 제공하는 리코일 대비 장점)

#### 작고 빠르며 확장에도 유연한 Zustand

* 리덕스에 영감을 받아 만들어짐
* 하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리
* store는 리액트를 비롯한 그 어떤 프레임워크와는 별개로 완전히 독립적으로 구성. 바닐라 자바스크립트 환경에서도 사용 가능
* state값을 useState외부에서 관리. state라고 하는 변수가 바로 스토어의 상태값을 담아두는 곳.
* partial은 state의 일부분만 변경, replace는 state를 완전히 새로운 값으로 변경. → state값이 객체일 때 필요에 따라 나눠서 사용
* getState는 클로저의 최신 값을 가져오는 함수
* subscribe는 listener를 등록. 상태값이 변경될 때 리렌더링이 필요한 컴포넌트에 전파. subscribe를 통해 스토어의 값이 변경될 때마다 특정 함수를 실행할 수도 있다. subscribe는 현재 값과 이전 값 둘 다 확인할 수 있으므로 특정 값이 변경될 때만 실행되게 최적화할 수도 있다.
* destroy는 listeners를 초기화.
* createStore는 이렇게 만들어진 getState, setState, subscribe, destroy를 반환
* zustand를 리액트에서 사용하려면 어디선가 store를 읽고 리렌더링을 해야한다.
  * useStore
    * useSyncExternalStoreWithSelector
      * useSyncExternalStore와 동일하지만 원하는 값을 가져올 수 있는 selector와 동등 비교를 할 수 있는 equalityFn 함수를 받는다.
      * useSyncExternalStore는 리액트 외부에서 관리되는 상태값을 리액트에서 사용할 수 있도록 돕는다.
  * create
    * 리액트에서 사용할 수 있는 스토어를 만들어주는 변수
    * create을 사용해 스토어를 만들면 useStore를 굳이 사용하지 않더라도 스토어를 리액트에서 바로 사용할 수 있다.
* zustand의 create을 사용해 스토어를 만들고 반환값으로 이 스토어를 컴포넌트 내부에서 사용할 수 있는 훅을 받는다. 이 훅을 사용하면 스토어 내부에 있는 getter와 setter모두에 접근해 사용할 수 있게 된다.
* 리액트 컴포넌트 외부에 store를 만드는 것도 가능하다. createStore를 사용하면 리액트와 상관없는 바닐라 스토어를 만들수 있다. 이 바닐라 스토어는 useStore 훅을 통해 접근해 리액트 컴포넌트 내부에서 사용할 수 있게 된다.
* 특징
  * Zustand는 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다는 장점이 있다. 간단하고 빠르게 상태를 정의할 수 있어 상태를 관리하는 입장에서 한결 가볍고 편리하다. (리덕스 대비 장점)
  * zustand 자체의 라이브러리 크기도 다른 라이브러리에 비해 굉장히 가볍다. API가 복잡하지 ㅇ낳고 사용이 간단해 쉽게 접근할 수 있다.
  * 마찬가지로 타입스크립트 기반으로 작성돼 있어서 별도로 @types를 설치하거나 임의로 작성된 d.ts에 대한 우려 없이 타입스크립트를 자연스럽게 쓸 수 있다.
  * 리덕스와 마찬가지로 미들웨어를 지원. create의 두번 째 인수로 원하는 미들웨어를 추가하면 된다.
    * 스토어 데이터를 영구히 보존할 수 있는 persist
    * 본잡한 객체를 관리하기 쉽게 도와주는 immer
    * 리덕스와 함께 사용할수 있는 리억스 미들웨어 등

## 기타

* tearing: 하나의 상태에 따라 서로 다른 결과물을 사용자에게 보여주는 현상. 일종의 레이스 컨디션(Race Condition, 경쟁 상태) 때문에 발생하는 현상
* MVC 패던: 소프트웨어를 만들 때 그 역할을 Model(모델), View(뷰), Controller(컨트롤러) 세 가지로 나누어 설계
  * Model: 데이터와 비즈니스 로직
    * 앱이 무엇을 할지, 어떤 데이터를 가질지 정의합니다.
    * DB와 연동하여 데이터를 저장, 수정, 불러오는 일을 하며, 화면(UI)이 어떻게 생겼는지는 전혀 신경 쓰지 않습니다.
  * View: 화면 UI
    * 사용자가 실제로 보는 화면(텍스트 박스, 버튼 등)입니다.
    * 모델이 가진 데이터를 받아서 시각적으로 보여주기만 합니다. 데이터를 직접 수정하지 않고 "보여주는 역할"에 충실합니다.
  * Controller: 중재자
    * 사용자의 입력(클릭, 타이핑 등)을 받아 모델과 뷰를 연결합니다.
    * 사용자가 버튼을 누르면 "모델아, 데이터 좀 수정해줘"라고 시키고, 수정된 데이터를 다시 "뷰야, 이 내용으로 화면 바꿔줘"라고 전달합니다.
* 타입스크립트에서 오버로딩(Overloading): 이름은 같지만 매개변수의 타입이나 개수가 다른 함수를 여러 개 정의하는 것

```ts
function add(a: string, b: string): string;
function add(a: number, b: number): number;
```

* 메인테이너(Maintainer): 픈소스 소프트웨어 프로젝트를 책임지고 관리하는 사람(또는 그룹)
