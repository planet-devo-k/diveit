# Takeaways

## 리액트 17, 18, 19 변경 사항

### 리액트 17

- 리액트 16과 비교해 새롭게 추가된 기능이 엇으며 호환성이 깨지는 병경 사항(기존 코드의 수정을 필요로 하는 변경 사항) 최소화 → 16에서 17로의 업그레이드는 별 문제 없이 순조롭게 가능

#### 리액트의 점진적인 업그레이드

- 점진적인 버전 업 가능
  - 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택
  - 버전이 서로 다른 리액트가 두 개 존재하므로 관리 지점이 많이지므로 버전을 올리기에 너무 부담되는 큰 애플리케이션의 경우 고려. 즉, 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로 고려.
  - 리액트 17 애플리케이션 내부에서 리액트 16을 lazy 불러오기
    - 리액트 16을 위한 별도 루트 요소 만들고, 여기에 불러온 리액트16 모듈을 렌더링
    - 이렇게 하면 렌더링하는 과정에서 버전 불일치 에러 발생하지 않음
  - 과거) 새로운 주 버전이 릴리스되면 이전 버전에서의 API제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구

#### 이벤트 위임 방식의 변경

- 이벤트 추가하는 방법

  - 직접 DOM을 참조해서 가져온 다음, DOM의 onclick에 직접 함수를 추가

    - 해당 버튼의 이벤트 리스너에 해당 이벤트 핸들러 추가

    ```html
    <button id="submitBtn">Submit</button>

    <script>
      const button = document.getElementById("submitBtn");

      button.onclick = function () {
        console.log("버튼 클릭됨 (직접 DOM 이벤트)");
      };

      // 또는
      // button.addEventListener('click', () => {
      //   console.log('버튼 클릭됨');
      // });
    </script>
    ```

  - 리액트 애플리케이션에서 DOM에 이벤트 추가

    - React는 이벤트를 각 DOM에 직접 달지 않고, document(16)/루트 요소(17)에 위임하고 이벤트 버블링을 활용해 처리한다.
    - 이벤트 타입(click, change) 당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라고 한다.

      - 추가한 이벤트가 직접적으로 보이지 않음
      - DOM에 직접 이벤트를 달지 않음
      - JSX에 이벤트를 선언
      - 실제 이벤트는 React가 위임해서 처리
      - 버튼에는 noop 핸들러만 붙어 있음
        - 해당 버튼의 이벤트 리스너에 noop이라는 핸들러 추가(no operation; 아무 일도 하지 않음. 이벤트가 “있다”는 표시용)

    ````jsx
    function App() {
    const handleClick = () => {
    console.log('버튼 클릭됨 (React 이벤트)');
    };

          return (
            <button onClick={handleClick}>
              Submit
            </button>
          );
        }

        export default App;
        ```
    ````

    - 루트 요소로 변경한 이유

      - 점진적 업그레이드 지원
        - 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경 → 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리 되므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다.
        - 만약 여러 리액트 버전이 한 서비스에 공존, 모든 이벤트가 document에 달려있다면 → stopPropagation을 실행해도 document의 이벤트 전파는 막을 수 없다. 즉, stopPropagation()으로 “다른 React의 이벤트 처리”를 막을 수 없다.
        ```
        document
        ├─ React 16 이벤트 리스너
        ├─ React 17 이벤트 리스너
        ```
        - stopPropagation()은 React의 SyntheticEvent 레벨에서만 전파를 막음
        - document는 버블링의 종착역. 버블링은 이미 끝남 → document에 달린 리스너들끼리는 서로를 막을 수 없음
        - document로 이벤트를 위임하는 특성으로 인해, 리액트 16에서 document와리액트가 렌더링되는 루트 컴포넌트 사이에서 이벤트를 막는 코드를 추가하면 리액트의 모든 핸들러가 작동하지 않도록 막을 수 있었다.
      - 다른 바닐라 JS 코드 또는 JQuery 등이 혼재돼 있을 경우 혼란을 방지하기 위해
      - 리액트 17의 경우, 컴포넌트 루트에 이벤트가 달려있다.
        - 만약 코드에 document.addEventListener를 활용해 리액트의 모든 이벤트를 document에서 확인하는 코드가 있다면, 여기까지 이벤트가 전파되지 않는 경우도 존재할 수 있으니 확인 필요.
        - React로 처리할 수 없는 전역 이벤트라면 document.addEventListener 사용(keydown, scroll, resize)

      ```

        document
        │
        ├─ #legacy-root
        │    └─ React 16 이벤트
        │
        └─ #new-root
              └─ React 18 이벤트


      ```

#### import React from 'react'가 더이상 필요 없음: 새로운 JSX transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요
- 16까지는 이러한 JSX변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없어도 import React from 'react'가 필요했었다.
  - createElement를 사용했었기 때문
- 17부터는 import 구문 없이도 JSX 변환 가능 → 불필요한 import 구문 삭제로 번들링 크기 약간 감소, 내부 로직 간결화
  - require()구문을 사용해 JSX를 변환할 때 필요한 모듈인 react/jsx-runtime을 불러오는 코드 같이 추가
  - 불필요한 import React 제거 `npx react-codemod update-react-imports`
  - import React를 방지하고 싶다면 ESLint 사용

#### 이벤트 풀링 제거

- SyntheticEvent = 브라우저의 원래 이벤트를 React가 한 번 감싸서 만든 “인공 이벤트 객체”
  - 리액트는 이렇게 브라우저 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이벤트를 새로 만들어야 했고, 그 과정에서 메모리 할당 작업이 일어날 수 밖에 없고, 메모리 누수를 방지하기 위해 이렇게 만든 이벤트를 주기적으로 해제해야 하는 번거로움
- 이벤트 풀링
  - SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것
  - 이벤트 풀링 시스템에서는 다음과 같이 이벤트가 발생
    1. 이벤트 핸들러가 이벤트를 발생시킨다.
    2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
    3. 발생한 이벤트 정보를 합성 이벤트 객체에 넣어준다.
    4. 유저가 지정한 이벤트 리스너가 실행된다.
    5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.
  - 언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어 효과적으로 보이지만, 풀에서 이벤트를 받아오고 이벤트가 종료되자마자 다시 초기화하는(null로 변경) 방식은 사용하는 쪽에서는 직관적이지 않다.
    - 서로 다른 이벤트 간에 이벤트 객체를 재사용하고, 이 재사용하는 사이에 모든 이벤트 필드를 null로 변경. 즉, 한번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화. 따라서 비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게된다.
    - 비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 e.persist()같은 처리가 필요.
  - 비동기 코드로 이벤트 핸들러에 접근하기 위해서는 이렇게 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 이는 성능 향상에 도움이 안된다는 점 때문에 이벤트 풀링 개념이 삭제됐다.
  - 17붙터는 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩 가능

#### 그 외 변경사항

useEffect 클린업 함수의 비동기 실행

- useEffect 클린업 함수는 16까지는 동기적으로 처리
- 17부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행
  - 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다.
  - 16에서는 클린업 함수가 리렌더링 이전에 실행(profiler에서 update = rerendering), 17에서는 리렌더링 이후 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 조금이나마 빨라짐

컴포넌트의 undefined 반환에 대한 일관적인 처리

- 16에서 forwardRef나 memo에서 undefined를 반환하는 경우 별다른 에러가 발생하지 않는 문제가 있었다. 17부터는 에러 발생.
- 리액트 16, 17은 컴포넌트 내부에서 undefined를 반환하면 에러 발생
- 18부터는 undefined를 반환해도 에러 발생 안함

### 리액트 18

#### 동시성 지원

- 과거 렌더링 과정은 중간에 일시 중지를 한다거나 렌더링 도중에 해당 렌더링 결과물을 포기한다든가 하는 동시성 렌더링 메커니즘이 없었다.
- 동시성 렌더링을 위해 리액트는 트리 전체가 계산이 완료된 이후에 DOM수정이 완료되기 까지 기다린다. 이 작업은 메인 스레드를 차단하지 않고 백그라운드에서 수행되며 새로운 화면을 만들 작업을 준비하게 된다.
- 메인스레드를 차단하지 않음으로써 사용자는 웹 애플리케이션에서 렌더링으로 인해 UI가 방해받는 현상을 겪지 않을 수 있고 사용자의 반응성 또한 확보할 수 있게 된다.
- 외부 상태를 관리하는 외부 상태 관리 라이브러리가 동시성 렌더링을 지원하기 위해서는 useSyncExternalStore의 도움을 필수로 받아야 한다.
  - 리액트 외부에 있어 보장이 안되는 상태값이 존재한다면 useSyncExternalStore 같은 훅을 제공해 일관성을 유지하게 유도

#### 새로 추가된 훅

- useID

  - 컴포넌트별로 유니크한 값을 생성
  - useId를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성 가능
    - 리액트 17까지는 서비스에서 컴포넌트 별로 고유한 값을 사용해야 한다면 반드시 하이드레이션을 고려해야해서 매우 까다로운 작업이었다.
    - useId를 사용하면 같은 컴포넌트임에도(e.g. Input 공통 컴포넌트) 서로 인스턴스가(각 <Input />) 다르면 다른 랜덤한 값을 만들어 낸다.
      - 인스턴스(instance) = 같은 설계도(컴포넌트)로 만들어진 실제 한 개의 실행 대상
    - 서버와 클라이언트 간에 동일한 값이 생성되어 하이드레이션 이슈도 발생하지 않는다.
    - useId가 생성하는 값은 :로 감싸져 있는데, 이는 CSS 선택자나 querySelector에서 작동하지 않도록 하기 위한 의도적인 결과다.
  - useId활용 아이디 생성 알고리즘
    - id는 기본적으로 현재 트리에서 자신의 위치를 나타내는 32글자의 이진 문자열로 이뤄져 있다.
    - 왼쪽 5자리가 부모의 트리
    - 앞 글자가 R이면 서버에서 생성된 값, r이면 클라이언트에서 생성된 값

- useTransition

  - useTransition은 리액트18의 핵심 변경사항인 동시성(concurrency)을 다룰 수 있는 새로운 훅
  - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅
  - 상태를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며 사용자에게 조금 더 나은 UX 제공 가능
  - useTransition은 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환
    - isPending: 상태업데이트가 진행 중인지 확인할 수 있는 Boolean
    - startTransition: 긴급하지 않은 상태 업데이트로 간주할 set함수를 넣어둘 수 있는 함수를 인수로 받는다. 경우에 따라서는 여러개의 setter를 넣어줄 수도 있다.
  - useTransition을 사용하면 렌더링에 시간이 소요되는 컴포넌트는 마치 async와 await처럼 비동기로 렌더링된다. (브라우저의 다른 작업을 방해하면서 즉각 렌더링을 시작하지 않고) 그리고 렌더링 와중에 다른 상태 업데이트로 전환되면 해당 컴포넌트는 렌더링이 취소될 수도, 혹은 완성될때까지 기다리되 다른 렌더링을 가로막지 않을 수 있다.
  - useTransition과 같은 동시성을 지원하는 기능을 사용하면 느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.
  - 컴포넌트에서만 사용 가능한 훅이다.
  - 훅을 사용할 수 없는 상황이라면 단순히 startTransition을 바로 import할 수 있다.

  - useTransition을 사용할 때 주의할 점
    - startTransition 내부는 반드시 setState와 같은 상태를 업데이트 하는 함수와 관련된 작업만 넘길 수 있다.
      (만약, props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 useDeferredValue를 사용)
    - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다.
      - 예를 들어 타이핑으로 인해 setState가 일어난 경우, 타이핑이 끝날때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
    - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. 이는 startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문이다.

- useDeferredValue

  - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
  - vs 디바운스
    - 특정 시간동안 발생하는 이벤트를 하나로 인식해 한 번만 실행한다는 점에서 디바운스와 비슷
    - 디바운스는 고정된 지연 시간 필요.
    - useDeferredValue는 고정된 지연시간 없이 첫번째 렌더링 완료 후 지연된 렌더링 수행.
      → 때문에 지연된 렌더링은 중단할 수도 있으며 사용자의 인터랙션을 차단하지도 않는다.
      - e.g. list를 생성하는 기준을 text가 아닌 deferredText로 설정해 잦은 변경이 있는 text를 먼저 업데이트해 렌더링하고 이후 여유가 있을 때 지연된 deferredText를 활용해 list를 새로 생성
  - vs useTransition
    - 지연 렌더링을 한다는 점에서 동일한 역할. 상황에 맞는 방법 선택해 사용.
    - useTransition은 state값을 업데이트하는 setter 함수를 감싸서 사용
    - useDeferredValue는 state값 자체만을 감싸서 사용
    - 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트 할 수 있는 코드에 접근 가능하다면 useTransition 사용
    - 컴포넌트의 props와 같이 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 한다면 useDeferredValue사용

- useSyncExternalStore

  - tearing
    - 리액트에서 하나의 state값이 있음에도 서로 다른 값(보통 state나 props의 이전과 이후)을 기준으로 렌더링되는 현상
    - 리액트18에서 useTransition, useDeferredValue 훅처럼 렌더링을 중지, 지연 하는 최적화가 가능해 지면서 동시성 이슈 발생
    - 리액트에서 관리하는 state라면 내부적으로 이러한 문제를 해결하기 위한 처리가 되어있음
    - 리액트에서 관리할 수 없는 외부 데이터 소스에서는, 즉, 클로저 범위 밖에 있는 값들이 문제 (글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등). 즉, useState나 useReducer가 아닌 모든 것들이 바로 외부 데이터 소스인데, 동시성 처리가 안되어 있다면 tearing 현상 발생 가능 → useSyncExternalStore를 통해 해결
  - useSyncExternalStore
    - 첫번째 인수: subscribe
      - 콜백함수를 받고 스토어에 등록한다.
      - 스토어에 있는 값이 변경되면 이 콜백이 호출돼야 한다.
      - useSyncExternalStore는 이 훅을 사용하는 컴포넌트를 리렌더링한다.
    - 두번째 인수: 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수
      - 이 함수는 스토어가 변경되지 않았다면 배번 함수를 호출할 때마다 동일한 값을 반환해야 한다.
      - 스토어에서 값이 변경됐다면 이 값을 이전 값과 Object.is로 비교, 값이 변경됐다면 컴포넌트를 리렌더링한다.
    - 마지막 인수(옵셔널): SSR 시에 내부 리액트를 하이드레이션하는 도중에만 사용
      - 서버사이드에서 렌더링되는 훅이라면 반드시 이 값을 넘겨줘야하며, 클라이언트 값과 불일치가 발생할 경우 오류가 발생한다.

  ```js
  // counterStore.js
  let count = 0;
  const listeners = new Set();

  export const counterStore = {
    getSnapshot() {
      return count;
    },

    subscribe(listener) {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },

    increment() {
      count += 1;
      listeners.forEach((listener) => listener());
    },
  };

  - count는 React state가 아님
  - React는 이 값이 언제 바뀌는지 모름
  - 그래서 구독(subscribe) 구조가 필요함
  ```

  ```jsx
  import { useSyncExternalStore } from "react";
  import { counterStore } from "./counterStore";

  function Counter() {
    const count = useSyncExternalStore(
      counterStore.subscribe, // 연결 설정
      counterStore.getSnapshot, // 값 확인
      () => 0 // 서버에서의 snapshot
    );

    return (
      <div>
        <p>Count: {count}</p>
        <button onClick={() => counterStore.increment()}>+1</button>
      </div>
    );
  }

  export default Counter;
  ```

  ```
    [ mount ]
    → subscribe(listener)  // 구독 설정
    → getSnapshot()  // 초기값 읽기

    [ store change ]
    → listener 호출   // store가 변경이 일어났다는 사실 리액트에게 알려줌
    → getSnapshot()   // 이전 snapshot과 Object.is 비교
    → 다르면 리렌더 예약

    [ re-render ]
    → getSnapshot()   // 실제 렌더에 사용할 값 읽기

    [ unmount ]
    → unsubscribe (cleanup)

  ```

  - 리렌더링을 발생시키기 위해 useState나 useReducer를 호출하는 동작이 없다.
    즉, useSyncExternalStore 어딘가에 콜백을 등록하고 이 콜백이 호출될 때마다 렌더링을 트리거 하는 장치가 마련돼 있다.
  - useSyncExternalStore 훅의 외부 스토어 데이터 변경 또한 리렌더링을 발생 시킬 수 있다.
  - innerWidth같이 리액트 외부에 있는 데이터 값의 변경 여부를 확인해 리렌더링까지 이어지게 하려면 useSyncExternalStore 사용
  - 사용중인 관리 라이브러리가 외부에서 상태를 관리하고 있다면 useSyncExternalStore를 통해 외부 데이터 소스의 변경을 추적하고 있는지 확인해야 한다.

- useInsertionEffect

  - useSyncExternalStore가 상태 관리 라이브러리를 위한 훅이라면 useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅이다.
  - CSS의 추가, 수정은 매우 무거운 작업일 수 있고, 따라서 리액트는 클라이언트 렌더링 시 이러한 작업이 발생하지 않도록 서버사이드에서 스타일 코드를 삽입했다. 이러한 작업을 할 수 있도록 도와주는 훅이 useInsertionEffect다.
  - 기본적인 훅 구조는 useEffect와 동일
  - 실행 시점은 브라우저가 레이아웃을 계산하기 전에, DOM이 실제로 변경되기 전에 동기적으로 실행.
  - 실제 애플리케이션 코드를 작성할때는 사용될 일이 거의 없으므로 라이브러리를 작성하는 경우가 아니면 참고만하고 가급적 사용하지 않는 것 권고.

    - useInsertionEffect는 렌더링 파이프라인의 가장 민감한 구간을 건드리는 훅이라 라이브러리 작성자 외에는 사용을 권고하지 않는다.

    ```
    1. useInsertionEffect   ←  DOM 변경 직전 (스타일 삽입 타이밍)
    2. DOM mutation
    3. useLayoutEffect
    4. Paint
    5. useEffect

    이 시점은 JS 실행이 조금만 오래 걸려도 화면이 멈춘 것처럼 보이는 구간

    ```

    - This hook is intended for CSS-in-JS library authors. Most application code should not use it.
      - CSS-in-JS
        - 스타일이 런타임에 생성됨
        - DOM이 이미 그려진 뒤 스타일을 넣으면 → 심각한 성능 비용 - 스타일 재계산 - 레이아웃 재계산 - 페인트 다시 발생
          → DOM이 바뀌기 전에 스타일을 미리 넣어두자

  - vs useLayoutEffect
    - 둘 다 브라우저에 DOM이 렌더링 되기 전에 실행
    - useLayoutEffect는 모든 DOM 변경 작업이 다 끝난 이후에 실행
    - useInsertionEffect는 DOM 변경 작업 이전에 실행 → 브라우저가 다시금 스타일을 입혀서 DOM을 재계산하지 않아도 된다
  - 실행 순서
    1. useInsertionEffect
    2. useLayoutEffect
    3. useEffect

#### react-dom/client

- 클라이언트에서 리액트 트리를 만들대 사용되는 API 변경
- 아래 두 API는 새로운 옵션인 onRecoverableError를 인수로 받는다.
  이 옵션은 리액트가 렌더링 또는 하이드레이션 과정에서 에러가 발생했을때 실행하는 콜백함수다.
  기본값으로 reportError 또는 console.Error를 사용하지만 필요하다면 원하는 내용 추가 가능

- createRoot

  - createRoot와 render 함께 사용

- hydrateRoot
  - 서버사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 메서드
  - 뒤의 React DOM 서버 API와 함께 사용

#### react-dom/server

- 서버에서도 컴포넌트를 생성하는 API 변경

- renderToPipeableStream

  - Node.js 환경에서의 렌더링을 위해 사용
  - 리액트 컴포넌트를 HTML로 렌더링하는 메서드
  - 스트림 지원, HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다.
  - 리액트 18에서 제공하는 Suspense와 같은 코드 분할, 지연 렌더링을 서버사이드에서 완전히 사용하려면 이 메서드를 사용해야 한다.
  - 이를 통해 서버에서는 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링되게 할 수 있다.
  - 여기에 hydrateRoot를 호출하면 서버에서는 HTML을 렌더링하고 클라이언트에선 이벤트만 추가함으로써 첫번째 로딩을 매우 빠르게 수행할 수 있다.

- renderToReadableStream
  - 웹 스트림 환경에서의 렌더링을 위해 사용.
  - 서버 환경이 아닌 클라우드플레어나 디노 같은 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드.

#### 자동 배치(Automatic Batching)

- 배치: 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 수행, 성능을 향상
- 17이하의 과거 버전의 경우 이벤트 핸들러 내부에서 자동 배치 작업이 이뤄지고 있었지만,
  Promise, setTimeout같은 비동기 이벤트에서는 자동배치가 이뤄지고 있지 않았다. 즉, 동기와 비동기 배치 작업에 일관성이 없었다.
- 이를 보완하기 위해 리액트 18부터는 루트 컴포넌트를 createRoot를 사용해서 만들면서 모든 업데이트가 배치 작업으로 최적화 할 수 있게 됐다.
- 자동배치를 리액트18에서도 하고 싶지 않다면 flushSync 사용. flushSync는 react가 아닌 react-dom에서 제공

#### 더욱 엄격해진 엄격 모드

- 리액트의 엄격 모드는 리액트에서 제공하는 컴포넌트 중 하나
- 리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는데 도움이 되는 컴포넌트
- 엄격모드에서 수행하는 모드는 모두 개발자 모드에서만 작동

- 더이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
- 문자열 ref 사용 금지
- findDOMNode에 대한 경고 출력 → createRef, useRef를 사용하는 방향으로 전환되어 지원 중단
- 구 Context API 사용 시 발생하는 경고
- 예상치 못한 사이드이펙트 검사

  - 리액트 엄격 모드 내부에서는 다음 내용을 의도적으로 이중으로 호출
    - 클래스 컴포넌트의 constructor.render, shouldComponentUpdate, getDerivedStateFromProps
    - 클래스 컴포넌트의 setState의 첫 번째 인수
    - 함수 컴포넌트의 body
    - useState, useMemo, useReducer에 전달되는 함수
  - 함수형 프로그래밍의 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정하기 때문. 엄격 모드에서는 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜주기 위해 두번 실행.
    - 리액트에서는 state, props, context가 변경되지 않으면(입력값이 변경되지 않으면) 항상 동일한 JSX를(항상 같은 결과물) 반환해야 한다. 이러한 규칙을 위배하는 컴포넌트는 잠재적으로 버그가 존재할 수 있다고 판단하기 때문에 엄격모드에서는 순수해야 하는 함수, 메서드 등을 두 번 실행해 이러한 내용을 사전에 개발자가 파악할수 있도록 유도.

- 리액트18에서 추가된 엄격모드
  - 향후 리액트는 컴포넌트가 마운트 해제된 상태에서도(컴포넌트가 렌더링 트리에 존재하지 않는 상태) 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정.(예를 들어 사용자가 뒤로가기 했다가 다시 현재 화면으로 돌아왔을때 리액트가 즉시 이전 상태를 그대로 유지해 표시할 준비를 하는 기능 추가) 이러한 기능을 향후에 지원하기 위해 엄격 모드의 개발 모드에 새로운 기능 도입.
  - 컴포넌트가 최초에 마운트될때마다 자동으로 모든 컴포넌트를 마운트 해제 및 재마운트하고 두 번째 마운트에서 이전 상태로 복원. 이 기능은 오직 개발 모드에서만 적용되는 개발 전용 검사.
  - 참고로 React 19의 useOptimistic는 React 18 Strict Mode에서 예고한 “언마운트 후 상태 유지” 기능의 구현이 아니다.

```
React 18 개발 모드 + StrictMode일 때

1. mount
2. unmount
3. 다시 mount (이전 state 복원)

향후 컴포넌트를 렌더 트리에서 제거하더라도 상태를 유지하는 기능을 대비하기 위해,
(컴포넌트를 “렌더 트리에서는 제거”하지만 “상태는 메모리(캐시)에 보존”)
개발 모드에서 컴포넌트를 의도적으로
마운트–언마운트–재마운트하는 검사를 수행한다.

```

#### Suspense 기능 강화

- React.lazy: 컴포넌트를 첫번째 렌더링 시에 불러오지 않고, 지연시켜 불러온다.
- Suspense: 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능.
  - Suspense는 lazy로 지연시켜 불러온 컴포넌트를 렌더링하는 역할
- lazy와 suspense는 주로 같이 사용되고, 애플리케이션에서 상대적으로 중요하지 않은 컴포넌트를 분할해 초기 렌더링 속도를 향상시키는 데 많은 도움을 준다.
- Suspense를 사용할 수 있는 시나리오는 제한적

  - Suspense는 “로딩 컴포넌트”가 아니라 “렌더링 제어 장치”

  - lazy를 사용해 컴포넌트를 지연시켜 불러오거나 Next.js와 같이 Suspense를 자체적으로 지원하는 프레임워크에서만 사용 가능
  - 리액트 공식 문서에는 Promise를 바로 사용할 수 있는 use 훅을 활용한 예제가 있는데 이러한 방식을 활용한 Suspense가 공개될 것으로 보인다.
  - 19 업데이트 내용:
    - use() 훅: Promise(또는 Context)를 그대로 받아서 해결될 때까지 Suspense로 중단 시키는 훅
    - React 19에서는 use() 훅이 공식 API로 공개되었다. 이 훅은 Suspense와 결합되어 데이터가 준비될 때까지 렌더링을 중단하는 패턴을 제공
    - 그러나 Suspense는 여전히 모든 상황에서 자유롭게 사용할 수 있는 기능은 아니며, 주로 Server Components 및 Suspense를 지원하는 프레임워크 환경에서 사용된다.

  ```jsx
  import { use } from "react";

  function fetchUser() {
    return fetch("/api/user").then((res) => res.json());
  }

  function UserProfile() {
    const user = use(fetchUser());
    return <div>{user.name}</div>;
  }

  export default function App() {
    return (
      <Suspense fallback={<Loading />}>
        <UserProfile />
      </Suspense>
    );
  }
  ```

- Suspense가 하는 일은 크게 두 가지:

  - 이 컴포넌트를 지금 화면에 보여줄지 말지 결정
  - 보여줄 때 / 숨길 때 lifecycle을 정확히 맞춤

- 18 이전의 문제(p710)

  - 마운트 되기 직전임에도 useEffect가 빠르게 실행되는 문제. 즉, 컴포넌트가 실제로 화면에 안 나왔는데 effect가 먼저 실행돼 버리는 타이밍 불일치 문제
  - 서버에서 사용 불가

- 18에서 개선

  - 이제 컴포넌트가 실제로 화면에 노출될 때 effect 실행
  - Suspense의 ‘노출/가림’ 타이밍에 맞춰 useLayoutEffect가 정확히 언제 실행·정리되어야 하는지가 React 18에서 정교해졌다.
    - suspense에 의해 노출이 된다면 useLayoutEffect의 effect(componentDidMount)가 실행
    - suspense에 의해 가려진다면 useLayoutEffect의 cleanUp(componentWillUnmount)가 실행
  - suspense를 이제 서버에서도 실행
  - suspense 내에 스로틀링 추가
    - throttling: 너무 자주 발생하는 업데이트를 일정 시간 간격으로 묶어서 보여주는 것
    - 화면이 너무 자주 업데이트되어 시각적으로 방해받는것을 방지하기 위해 리액트는 다음 렌더링을 보여주기 전에 잠시 대기한다.
      즉, 중첩된 suspense의 fallback이 있다면 자동으로 스로틀되어 최대한 자연스럽게 보여주기 위해 노력한다.

- 스로틀링 vs 디바운싱
  | 구분 | 의미 | 기준 | 설명 예시 |
  |------|------|------|-----------|
  | Throttling | 일정 주기마다 실행 | 시간 | 이벤트가 계속 발생해도 100ms마다 한 번만 실행 |
  | Debouncing | 멈춘 뒤 한 번 실행 | 이벤트 정지 | 입력이 멈춘 뒤 마지막 이벤트만 실행 |

#### 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- 아래 세 기능을 지원하지 않는 브라우저에서 서비스해야 한다면 세 기능을 위한 폴리필을 반드시 추가
  - Promise: 비동기 연산이 종료된 이후에 실패 또는 결괏값을 확인할 수 있는 객체
  - Symbol: 자바스크립트의 새로운 데이터 형식. 익명의 객체 속성을 만들수 있는 객체
  - Object.assign: 객체의 열거 가능한 모든 속성을 다른 객체로 붙여 넣는 메서드

#### 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않고, null반환과 동일하게 처리

### 리액트 19

- [리액트19](https://ko.react.dev/blog/2024/12/05/react-19)

- React 19는 새로운 렌더링 엔진을 도입한 버전이 아님
- React 18에서 도입된 동시성, Suspense, Server Components를 실제 애플리케이션에서 기본으로 사용 가능한 수준까지 끌어올림
- 비동기 · 서버 · 폼 · 데이터 변경을 React의 기본 렌더링 모델 안으로 완전히 편입한 버전이다.

#### 핵심 신규 기능 요약

- Actions
- 새로운 Hook: `useActionState`, `useOptimistic`, `use`
- React DOM `<form>` 액션 및 `useFormStatus`
- React Server Components (안정화)
- React DOM 정적 API (`prerender`)
- ref, Context, hydration, metadata, stylesheet, script 관련 개선

#### 1. 비동기 작업을 위한 새로운 모델 (Async & Actions)

- React 19의 가장 큰 변화: 비동기 작업을 React가 1급 개념으로 이해하기 시작함
- 1급 개념(First-class concept): 언어·프레임워크가 어떤 대상을 주요 구성 요소로 직접 다루는 것
  - 함수는 JS에서 1급 객체: 언어가 함수를 핵심 단위로 취급한다는 의미

##### 1-1. Actions (핵심 개념)

- 비동기 함수를 React가 직접 인식하고 관리
  - Actions: **비동기 함수를 React가 직접 인식하고 관리하는 실행 단위**
- 데이터 변경 → UI 업데이트 흐름을 하나로 통합
- React가 다음을 자동으로 처리
  - 대기 상태(pending): 요청 시작 시 활성화 → 커밋 시 자동 해제
  - 에러 처리: Error Boundary + 자동 롤백
  - 낙관적 업데이트: `useOptimistic`
  - 완료 후 리렌더링

##### 1-2. 새로운 Hook: `useActionState`

- Action의 전형적인 패턴을 표준화
- 액션을 감싸는 래퍼를 반환
- 반환 값:
  - 이전 결과(state)
  - submitAction
  - pending 상태
- 기존: ReactDOM.useFormState
- 변경: useActionState (useFormState 제거)

```js
const [state, submitAction, isPending] = useActionState(...)
```

##### 1-3. 새로운 Hook: useOptimistic

- 비동기 요청 중 낙관적 UI 업데이트 지원
- Actions와 결합되어 사용되는 훅
- 비동기 Action 실행 중에 “미래에 성공할 상태”를 UI에 임시로 반영하는 도구
- 요청 완료 또는 실패 시 React가 자동으로 이전 상태 복원
- 특징

  - 요청 시작 시 즉시 UI 반영
  - 에러 발생 시 자동 롤백

- 낙관적 UI의 전제 조건: UX에서의 진짜 문제는 “실패”가 아니라 “지연”
  - 지연은 불확실성을 만든다
    - 버튼을 눌렀는데 → 아무 반응이 없음 → 눌렸는지 안 눌렸는지 모름
    - 네트워크가 느릴수록 더 심해짐
    - 사용자는 다시 누르거나 이탈함

#### 2. 폼 처리의 패러다임 변화 (Forms & Mutations)

- 폼 제출을 React 렌더링 모델 안으로 흡수
- 폼 제출 = React Action 실행

##### 2-1. React DOM `<form>` Actions

- `<form>`, `<input>`, `<button>`의 `action`, `formAction`에 함수 전달 가능
- `<form action={fn}>` `<button formAction={fn}>`
- 함수 전달 시 **자동으로 Action으로 처리**
- 성공 시 비제어 폼 자동 reset
- 필요 시 `requestFormReset`로 수동 제어

##### 2-2. React DOM Hook: `useFormStatus`

- `<form>`을 Context처럼 취급하는 상태 Hook
- form 내부 어디서든 상태 접근 가능
- 기능:
  - pending 상태 자동 추적
  - 디자인 시스템 컴포넌트에 적합

```js
const { pending } = useFormStatus();
```

#### 3. 렌더링 중 리소스 소비 모델 (Suspense & use)

- 언제 렌더링할 것인가를 React가 직접 제어

##### 3-1. 새로운 API: `use`

- 렌더링 중 **리소스(Resource)를 읽기 위한 API**
- Promise 또는 Context를 직접 소비
- Promise가 해결될 때까지 **Suspense로 렌더링 중단**

```js
const data = use(promise);
```

- 중요 제약
  - 렌더링 중 Promise 생성 ❌
  - 캐시된 Promise만 전달 가능
  - Suspense-compatible 라이브러리/프레임워크 필요

##### 3-2. Context + use

- `useContext`와 달리 **조건부 호출 가능**
- 조기 return 이후에도 Context 소비 가능

##### 3-3. Suspense의 위상 변화

- 실험 기능 → 기본 렌더링 제어 메커니즘
- 데이터 / 코드 / 서버 결과 모두 제어
- Server Components에서 기본 전제

#### 4. 서버 중심 아키텍처의 안정화 (Server-first React)

##### 4-1. React Server Components (안정화)

- 서버 전용 렌더링 환경
- 빌드 타임 또는 요청 시 실행
- 클라이언트 번들에 포함되지 않음
- 클라이언트/SSR과 분리된 서버 환경에서 렌더링

- 주의
  - 서버 컴포넌트 자체에는 `"use server"` 지시어 없음
  - `"use server"`는 **서버 액션 전용**

##### 4-2. Server Actions

- 서버에서 실행되는 Action
- **클라이언트 컴포넌트에서 호출 가능**
- 프레임워크가 서버 함수 참조를 자동 생성
- React가 `요청 → 결과 → UI 반영`까지 관리

#### 5. 개선 사항

##### 5-1. ref 관련 변경

- 함수 컴포넌트에서 `ref`를 일반 prop처럼 사용 가능
- `forwardRef`는 점진적 제거 예정
- 클래스 컴포넌트 ref는 제외
- ref 콜백에서 **cleanup 함수 반환 가능**
- unmount 시 React가 cleanup 호출
- 기존 `ref(null)` 호출은 점진적 제거 예정

##### 5-2. Context Provider 간소화

- `<Context.Provider>` 대신 `<Context>` 사용 가능
- codemod 제공 예정
- 기존 Provider 패턴은 장기적으로 제거 계획

##### 5-3. Hydration 에러 리포팅 개선

- 다중 경고 대신 단일, 명확한 에러 메시지
- 불일치 원인과 diff를 명확히 표시
- 서드파티 스크립트/확장 프로그램에 더 관대해짐

##### 5-4. Error Handling 개선

- 에러 로그 중복 제거
- 새로운 루트 옵션 추가
  - `onCaughtError`
  - `onUncaughtError`
  - `onRecoverableError`

#### 6.Document & Platform 통합 기능

##### 6-1. React DOM 정적 API (Static APIs)

새로운 API:

- `prerender`
- `prerenderToNodeStream`

특징:

- `renderToString`과 달리 데이터 로드 완료까지 대기
- 정적 HTML 생성에 최적화
- Node Streams / Web Streams 지원

##### 6-2. Metadata 지원 (`<title>`, `<meta>`, `<link>`)

- 컴포넌트 내부에서 직접 메타데이터 렌더링 가능
- React가 자동으로 `<head>`로 호이스팅
- CSR, SSR, Streaming, Server Components 모두 지원

- 기존

  - 페이지 제목이 컴포넌트 안에서 결정되는 경우
  - <head>는 index.html에 있음
  - 둘이 너무 멀리 떨어져 있음
  - 그래서 전에는
    - useEffect로 document.title = ...
    - react-helmet 같은 라이브러리 사용
    - SSR에서는 더 복잡 (타이밍, 중복, 깜빡임 등)

- 리액트 19
  - React가 자동으로 컴포넌트 위치랑 상관없이 <head>로 호이스팅

```jsx
function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>

      <title>{post.title}</title>
      <meta name="author" content="Josh" />
      <meta name="keywords" content={post.keywords} />
      <link rel="author" href="https://twitter.com/joshcstory/" />

      <p>내용...</p>
    </article>
  );
}
```

```html
<head>
  <title>글 제목</title>
  <meta name="author" content="Josh" />
  <meta name="keywords" content="..." />
  <link rel="author" href="..." />
</head>
```

- react-helmet 같은 라이브러리의 필요성
  - 19만 써도 페이지별 title / meta 변경은 충분히 가능 → react-helmet의 핵심 역할 70~80%는 React가 흡수함
  - 기본 메타 + 페이지별 override를 정교하게 관리하고 싶을 때
  - OG 태그 / SEO 전략 / 중복 관리

##### 6-3. Stylesheet 지원

- `<link rel="stylesheet">`, `<style>`에 대한 내장 관리
- precedence 기반 삽입 순서 제어
- Suspense 및 스트리밍과 통합
- 중복 삽입 자동 제거

##### 6-4. Async Script 지원

- `<script async>`를 컴포넌트 트리 어디서든 안전하게 사용
- 중복 로드 제거
- SSR 시 `<head>`에 자동 배치

##### 6-5. 리소스 사전 로드 API

새로운 API:

- `preload`
- `preinit`
- `prefetchDNS`
- `preconnect`

목적:

- 초기 로딩 성능 개선
- 예상 네비게이션에 대한 선제적 리소스 준비

##### 6-6. Custom Elements 완전 지원

- Custom Elements Everywhere 테스트 통과
- SSR / CSR 모두에서 안정적 속성 처리
- props → property / attribute 자동 분기

### 기타

- 이벤트 위임: 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것

- 이벤트 구성 단계

1. 캡처(capture): 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것
2. 타깃: 이벤트 핸들러가 타깃 노드에 도달하는 단계. 이 단계에서 이벤트가 호출된다.
3. 버블링: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다.

- 동시성

  - UI 렌더링 작업을 한 번에 끝내려 하지 않고, 중간에 멈추고·재개하고·우선순위를 바꿀 수 있게 만든 렌더링 방식
  - 기존 React (동기 렌더링)의 문제
    - 상태 변경 발생 → 렌더링 시작 → 끝날 때까지 브라우저 멈춤
    - 렌더링이 무거우면 화면이 멈춘 것처럼 느낌
    - 입력, 스크롤, 클릭이 늦게 반응
    - UX 나쁨
  - 동시성 렌더링이 가능한 이유 (Fiber)

  - 동시성이 병렬 실행이라는 뜻은 아님

    - ❌ 멀티 스레드에서 동시에 실행
    - ⭕ 싱글 스레드에서 번갈아 처리

  - React 18에서 동시성이 어떻게 드러나냐면

    - createRoot

    ```js
    import { createRoot } from "react-dom/client";

    createRoot(container).render(<App />);
    ```

    - React 동시성 기능을 사용할 수 있는 기반 API
    - 사용한다고 해서 자동으로 느려지지 않음
    - 필요할 때만 동시성 기능이 활성화됨
    - 기존 `ReactDOM.render`와 달리 새로운 렌더링 엔진(**Fiber**)을 전제로 동작

    - startTransition

    ```js
    import { startTransition } from "react";

    startTransition(() => {
      setList(filteredList);
    });
    ```

    - 의미: 이 상태 업데이트는 급하지 않다
    - 사용자 입력, 클릭 같은 중요한 업데이트는 즉시 처리
    - 무거운 렌더링(리스트, 검색 결과 등)은 **우선순위를 낮춰 나중에 처리**

    - useTransition

    ```js
    const [isPending, startTransition] = useTransition();
    ```

    - 동시성 전환 상태를 관리하는 훅
    - isPending으로 전환 중 여부를 알 수 있음
    - 로딩 UI, 스켈레톤 UI와 함께 사용하기 좋음

    - Suspense

    ```js
    <Suspense fallback={<Loading />}>
      <UserProfile />
    </Suspense>
    ```

    - 아직 준비되지 않은 UI는 **잠시 미룸**
    - 준비된 UI부터 먼저 렌더링
    - 데이터 로딩, 코드 스플리팅, 서버 컴포넌트와 함께 사용
    - 동시성 UX를 구성하는 핵심 도구

- Fiber

  - React의 내부 **렌더링 엔진**이자 그 엔진을 이루는 **핵심 자료구조**
  - React 렌더링 엔진이 렌더링 작업을 쪼개고, 멈추고, 다시 시작할 수 있게 만든 노드 기반 작업 단위 자료구조
  - 컴포넌트 트리를 기반으로 React 내부에 별도의 “Fiber 노드 트리”가 만들어진다.
  - Fiber가 해결한 것:
    - 렌더링 작업을 **작은 단위(Fiber 노드)**로 분해
    - 작업 중간에 중단(pause) 가능
    - 더 중요한 업데이트가 오면 우선 처리
    - 나중에 다시 이어서 렌더링 재개(resume)

  ```
  컴포넌트 트리 (개념/설계)
        ↓
  Fiber 노드 트리 (실제 실행/관리) → 렌더링 작업을 조각 단위로 관리

  ```

  - 컴포넌트 트리
    - 우리가 작성하는 JSX / 함수 컴포넌트 구조
    - “어떤 UI를 만들고 싶은지”에 대한 선언
  - Fiber 트리
    - React가 내부적으로 만드는 실행용 트리
    - 렌더링, 스케줄링, 중단/재개, 우선순위 관리 담당
  - 즉, Fiber 트리가 있기 때문에 React는 렌더링 작업을 쪼개고, 멈추고, 다시 이어서 실행할 수 있다.

- Fiber는 컴포넌트를 1:1로 대응하는 내부 노드

```jsx
<App>
  <List>
    <Item />
  </List>
</App>
```

개념적으로 내부에서는 각 컴포넌트 인스턴스마다 Fiber 노드 하나

```
Fiber(App)
 └─ Fiber(List)
     └─ Fiber(Item)

```

```
[ 컴포넌트 트리 ]  ← 설계도
<App>
  <List />
</App>

        ↓ React 내부 변환

[ Fiber 트리 ]     ← 실행 구조
Fiber(App)
 └─ Fiber(List)

```

- 컴포넌트 트리는 우리가 작성한 선언 구조이고,
  React는 이를 바탕으로 별도의 Fiber 트리를 만들어
  현재(current)와 작업 중(workInProgress)을 동시에 관리한다.

- 더블 버퍼링(double buffering): 현재 화면과 다음 화면을 위한 구조를 동시에 유지하는 방식
  - React는 항상 Fiber 트리를 2개까지 동시에 관리한다.
    - 하나는 현재 화면에 반영된 트리 (current)
    - 하나는 다음 화면을 만들기 위한 트리 (workInProgress)
      - 상태 업데이트가 일어나면 리액트는 기존 Fiber트리를 직접 고치지 않고 새 트리를 하나 더 만든다.(workInProgress Fiber Tree)
      - 렌더링이 끝나면 커밋 → workInProgress를 current로 교체
