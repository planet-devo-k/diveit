# Takeaways

## 서버 사이드 렌더링이란?

#### SPA(CSR)와 MPA(SSR)의 차이

- 웹페이지 렌더링의 책임을 어디에 두는지의 차이
  - SPA(CSR): 번들(자바스크립트 코드를 묶고 압축해놓은 파일) 안에 들어 있는 JS 애플리케이션 코드가 렌더링
    - 번들 = 렌더링 로직(React/Vue 코드 포함) + 앱 로직이 묶인 파일
    - React/Vue(프레임워크)가 = 렌더링을 실제로 수행
  - MPA(SSR): 서버에서 렌더링 담당

#### SPA, CSR

| 개념                                                | 구분 기준                                                                                                           |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **SPA (Single Page Application)**                   | 페이지를 한 번만 로드하고, 이후 화면 전환을 **JS 로직(pushState 등)** 으로 처리하는 **애플리케이션 구조(아키텍처)** |
| **CSR (Client-Side Rendering)**                     | 렌더링이 **어디에서 발생하는가?** → 브라우저가 JS를 실행해 DOM을 생성하고 렌더링하는 방식                           |
| **서버로 데이터를 보내는 방법: AJAX**               | 페이지 이동 없이 비동기로 서버에 요청함                                                                             |
| **서버로 데이터를 보내는 방법: fetch/axios + JSON** | 현대 AJAX 방식 = fetch                                                                                              |

#### MPA(Multi Page Application), SSR

| 개념                                       | 기준                                                                         |
| ------------------------------------------ | ---------------------------------------------------------------------------- |
| **MPA (Multi Page Application)**           | 페이지 전환 시 **새 HTML을 서버에 요청**하느냐의 기준 (페이지 구조/아키텍처) |
| **SSR (Server-Side Rendering)**            | HTML을 **서버에서 렌더링**하느냐의 기준 (렌더링 방식)                        |
| **서버로 데이터를 보내는 방법: form POST** | 페이지가 새로고침되며 제출됨                                                 |

#### 자바스크립트의 모듈화

- 코드를 기능 단위로 쪼개고, 필요한 곳에서 불러와 쓰도록 구조화하는 것. 한 파일에 모든 JS를 몰아넣지 않고, 목적·기능별로 파일을 나누고 재사용 가능하게 만드는 것
- AMD(Asynchronous Module Definition)
  - 브라우저에서 모듈을 비동기로 로드하기 위한 자바스크립트 모듈 규칙(포맷). '옛날 모듈 시스템' (RequireJS 기반).
  - 브라우저가 JS 파일을 로딩하는 동안 UI가 멈추지 않게 백그라운드에서 모듈을 다운로드하고, 준비되면 실행하도록 만든 방식
  - 지금은 ESModules와 번들러로 대체됨. 번들러는 ES Module을 기반으로 최적화함
- CommonJS vs AMD vs ESM
  - CommonJS(CJS)는 레거시 생태계 때문에 레거시 호환성 역할로 여전히 남아있지만 프론트엔드에서는 사실상 사용 안 함.
    (Node.js는 기본 모듈 시스템이 오랫동안 CommonJS였기 때문)
  - 하지만 Node.js도 최근에는 ESM을 공식 표준으로 삼음
    | 특징 | CommonJS | AMD | ES Module (ESM) |
    |------|-----------|------|----------------------|
    | **환경** | Node.js (서버) | 브라우저 | 브라우저 & Node.js(최신) |
    | **로딩 방식** | 동기 로딩 | 비동기 로딩 | 정적 로딩 (빌드 타임 분석 가능) |
    | **문법** | `require()` / `module.exports` | `define()` / `require()` | `import` / `export` |
    | **목적** | 서버에서 모듈 관리 | 브라우저에서 비동기 모듈 로드 | 표준 모듈 시스템 (브라우저/서버 통합) |
    | **장점** | 단순, Node 환경 최적화 | 브라우저에서 비동기 의존성 해결 | 표준 지원, 트리쉐이킹, 최적화 가능 |
    | **단점** | 브라우저 비적합, 비동기 어려움 | 문법 복잡함, 콜백 다수 | 구형 브라우저 미지원(Polyfill/번들 필요) |
    | **대표 라이브러리** | Node.js 기본 | RequireJS | 브라우저 기본 지원, 번들러와 호환 |

#### JAM 스택

- LAMP 스택: Linux(운영체제), Apache(서버), MySQL(데이터베이스), PHP/Python 등(웹 프레임워크)
  - 클라우드 개념이 부족했던 시대에 서버 확장 문제가 있었다.
- JAM 스택: JavaScript, API, Markup(미리 빌드된 정적 HTML)
  - 자바스크립트와 HTML, CSS를 미리 빌드해 두고 정적으로 사용자에게 제공한 후 모든 작동은 모두 클라이언트에서 실행되므로 서버 확장성 문제에서 좀 더 자유로워짐.
  - 아예 API 서버 자체도 자바스크립트로 구현하는 구조가 인기를 끌었었다.
    - MEAN(MongoDB, Express.js, AngularJS, Node.js)
    - MERN(MongoDB, Express.js, React, Node.js)
  - 요즘은 Next.js, TypeSCript, SQL 기반이 인기

### SPA(CSR)

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 하나의 페이지에서만 렌더링을 수행
- 최초에 서버에서 최소한의 데이터를 불러온 이후에는 이미 가지고 있는 자바스크립트 리소스와 브라우저API를 기반으로 모든 작동이 이뤄진다.
  - 페이지 전환도 새로운 HTML로 페이지를 요청하는게 아니라 자바스크립트에서 다음 페이지 렌더링에 필요한 정보만 HTTP요청 등으로 가져온 다음 그 결과를 바탕으로 바디 내부에 DOM을 추가, 수정, 삭제하는 방법으로 페이지가 전환된다.
  - 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저의 history.pushState, history.replaceState로 이뤄진다.
    - history.pushState vs history.replaceState
      - 히스토리 스택을 추가하느냐, 교체하느냐 차이
      - pushState: 기록 추가
        - 브라우저 히스토리 스택에 새 기록 추가
        - 뒤로가기 가능
        - React Router의 navigate('/page', { replace: false }) 와 동일한 동작
      - replaceState: 기록 교체
        - 브라우저 히스토리 스택의 현재 기록 교체(기록이 안쌓임)
        - 뒤로가기 불가
        - React Router의 navigate('/page', { replace: true }) 와 동일한 동작
  - 소스보기로 HTML코드를 봤을때 <body/> 내부에 아무런 내용이 없다. 사이트 렌더링에 필요한 바디 내부 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링 하기 때문이다.
  - Gmail

#### CSR 장점

- 최초에 한번 모든 리소스를 다운로드 하고 이후 페이지를 전환 할때는 추가로 리소스 다운로드할 필요가 없어 시간이 절약된다.
- 전체 페이지를 새로 렌더링하지 않고 일부 영역만 다시 그리게 되므로 훨씬 매끄러운 UI를 보여줄 수 있다.

### MPA(SSR)

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식
- CSR은 사용자 기기 성능에 영향을 받지만 SSR은 서버에서 제공하므로 비교적 안정적인 렌더링 가능

#### 다시 SSR의 필요성(SPA의 한계)

- 웹 애플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가
- 사용자의 기기와 인터넷 속도 등 웹 전반을 이루는 환경이 크게 개선됐음에도 실제 사용자들이 느끼는 웹 애플리케이션 로딩 속도는 오히려 느려짐.
  - 자바스크립트 파싱을 위해 CPU를 소비하는 시간이 크게 증가
  - 모바일에서 사용자가 상호작용 할 수 있을 때 까지 대기해야하는 시간(FID) 증가
  - 모든 콘텐츠 로딩에 소요되는 시간 증가

#### SSR 장점 (최초 페이지 렌더링을 서버에서 수행)

- 최초 페이지 진입이 비교적 빠르다.
  - 페이지에 유의미한 정보가 그려지는 시간(First Contentful Paint)가 빠름
  - CSR의 경우 최초에 사용자에게 보여줘야 할 화면에 표시할 정보가 외부 API 호출에 많이 의지.
    - 사용자가 웹 페이지에 진입하고, 리소스 다운, HTTP 요청 이후 응답 결과를 가지고 화면을 렌더링.
  - 서버에서 HTTP 요청을 수행하면 더 빠르다.
  - 서버에서 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 빠르다.
  - 단, 서버가 사용자를 감당하지 못하고, 사용자에게 렌더링을 제공할 수 있을 정도의 충분한 리소스를 확보하지 못하면 오히려 SPA보다 느릴수 있다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

  - 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML응답으로 제공할 수 있으므로 검색 엔진 최적화에 유용
  - 검색 엔진이 사이트에서 필요한 정보를 가져가는 과정
    1. 검색 엔진 로봇이 페이지에 진입
    2. 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드. 단, 다운로드만 하고 자바스크립트 코드는 실행하지 않는다. 로봇은 페이지를 보는 것이 아닌 페이지의 정적인 정보를 가져오는 것이 목적이므로 자바스크립트를 다운로드하거나 실행할 필요가 없다.
    3. 다운로드한 HTML 페이지 내부의 오픈그래프나 메타 태그 정보를 기반으로 페이지의 검색(공유)정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다.
  - SPA는 메타 정보 또한 자바스크립트에 의존. 때문에 검색 엔진이 최초에 방문했을 때메타 정보를 제공할 수 있도록 조치를 취하지 않는다면 검색엔진이나 SNS공유 시에 불이익

- 누적 레이아웃(CLS) 이동이 적다.

  - CLS: 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는 것과 같은 부정적인 사용자 경험
  - CLS는 렌더링 타이밍 문제가 아니라 레이아웃 공간 확보 문제
  - SPA에서는 페이지 콘텐츠가 API요청에 의존하고 API요청의 응답 속도가 제각각
  - 반면 SSR은 요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 CLS문제에서 비교적 자유로움. 하지만 완전히 자유롭진 못하다.
    - useEffect는 컴포넌트가 마운트된 이후에 실행되므로 CSR이나 SSR 모두에서 문제의 소지가 있다.
    - API 속도가 모두 달랐을 떄, SSR에서는 모든 요청이 완료되기 전까지 페이지가 렌더링되지 않을 것이므로 최초 페이지 다운로드가 많이 느려짐.
      - 그러나 리액트18 이후 등장한 스트림으로 인해 이 부분은 해결.
      - **스트리밍 SSR**
        - 데이터를 한 번에 보내지 않고 ‘조각(chunk)’으로 나눠서 순차적으로 전달하는 방식
        - 전체 데이터를 다 만들어야만 보내는 게 아니라, 만들어지는 즉시 바로바로 사용자에게 보낼 수 있는 구조

- 사용자의 디바이스 성능에 비교적 자유롭다.

  - 자바스크립트 리소스 실행은 브라우저에서 실행되지만, 그 브라우저의 실행 속도는 사용자 디바이스 성능에 의해 결정된다.
  - CSR 속도 = 브라우저 속도 = 결국 CPU 속도
  - 단, 인터넷 속도가 느리다면 SSR로도 느리다.
    - 인터넷(네트워크) 속도 = 데이터를 다운받는 속도
    - 브라우저 속도 = 받은 데이터를 얼마나 빨리 렌더링해 보여주느냐
  - 사용자 방문이 폭증해 서버에 부담이 가중된다면, 그리고 이를 위한 적절한 처리가 수반돼 있지 않다면 SSR도 느릴 수 있다.

- 보안에 좀 더 안전하다.

  - JAM스택의 문제는 애플리케이션의 모든 활동이 브라우저에 노출된다. API호출과 인증 등 사용자에게 노출되면 안되는 민감한 작업도 포함될 수 있다.

    - 인증·권한이 필요한 백엔드 API 호출을 사용자의 브라우저가 직접 한다는 점이 위험하다는 뜻

    ```
    정상적인 인증 처리 방식 (안전함)
      1. 브라우저가 로그인 API 호출 → 이메일/비밀번호 보내기
      2. 서버가 인증 수행
          → 비밀번호 검사
          → 계정 상태 체크
          → 권한 체크

      3. 서버가 토큰을 HttpOnly Cookie로 내려줌 → 브라우저 JS가 접근할 수 없어 XSS로 훔치기 불가능
      4. 이후 요청에서 쿠키를 자동으로 보내며 인증됨
          → 브라우저가 자동 처리
          → 인증 로직은 서버에서 처리됨


    위험한 로그인 방식 (보안 취약)
      ❌ 브라우저에서만 비밀번호 검증 → 누구나 억지로 통과 가능
          -> 회원가입에서 비밀번호 확인 UI는 보안 검증이 아니라 단순 문자열 비교 → 클라이언트에서 해도 전혀 문제 없음
          -> 실제 로그인 비밀번호 검증은 반드시 서버에서 해야한다.
      ❌ localStorage에 accessToken 저장 → 쉽게 털림
      ❌ client만으로 권한 체크 → admin: true 를 클라이언트에서 조작 가능
      ❌ 외부 API 비밀키를 브라우저에 둠 → 모두가 접근 가능

    ```

    - 환경변수로 숨겨도, 그 값이 클라이언트 번들에 포함되는 순간 → 모두에게 공개된 값이다.
      - 프론트엔드 환경변수는 보안을 위해 쓰는 것이 아니다. 빌드 시점에 “환경에 따라 다른 값”을 주입하기 위해 쓴다. 즉, 빌드 환경을 개발, 배포 등 분리하기 위해.
      - VITE*, NEXT_PUBLIC*처럼 “브라우저에 보내는 환경변수”는 절대 비밀 키로 사용할 수 없음

  - SSR은 인증 등 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 보안 위협을 피할 수 있다.

#### SSR 단점

- 소스코드를 작성할 때 항상 서버 환경을 고려해야 한다.

  - 가장 큰 문제는 브라우저 전역 객체인 window 또는 sessionStorage와 같이 브라우저에만 있는 전역 객체 등이다.
    - 소스코드나 사용중인 라이브러리에서 window를 사용하고 있고, 이 코드가 만약 서버에서 실행된다면 'window is not defined' 에러
    - 서버에서도 실행될 가능성이 있는 코드라면 window에 대한 접근을 최소화, window 사용이 불가피하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리
  - 잠재적인 위험을 가진 코드를 모두 클라이언트에서 실행하면, 클라이언트에서만 실행되는 코드가 많아지고 SSR의 장점을 잃음

- 적절한 서버가 구축돼 있어야 한다.

  - 사용자의 요청을 받아 렌더링을 수행할 서버가 필요
  - 사용자의 요청에 따라 적절하게 대응할수 있는 물리적인 가용량을 확보
  - 요청을 분산
  - 프로세스가 예기치 못하게 다운될 때를 대비해 PM2 같은 프로세스 매니저의 도움도 필요
    - PM2 = Node.js 서버가 죽지 않도록 지켜주는 관리자. 서버가 죽으면 자동으로 다시 실행(restart) 시켜주는 도구
    - Node.js 서버는 예기치 못한 에러·메모리 누수·예외로 크래시할 수 있기 때문에 PM2가 대신 감시·관리·자동 재시작을 해준다.
    - 쿠버네티스(Kubernetes): 컨테이너(예: Docker)를 자동으로 배포·관리·확장해주는 플랫폼
    - PM2가 Node.js 한 프로세스”를 관리한다면, 쿠버네티스는 수백~수천 개의 서버와 컨테이너 전체를 관리하는 수준

- 서비스 지연에 따른 문제.

  - SPA는 그래도 최초에 어떤 화면이라도 보여준 상태에서 느린 작업이 수행되기 때문에 로딩 중 과 같이 작업이 진행 중임을 적절히 안내한다면 사용자가 기다릴 여지가 있다.
  - 반면 SSR은 특히 최초 렌더링에 지연이 발생한다면 사용자에게 어떠한 정보도 제공할 수 없어 안좋은 UX가 될 수 있다.

- 페이지 전환이 발생할 때마다 새롭게 페이지 요청하고 HTML 페이지를 다운로드해 파싱하는 작업을 거친다.
- 페이지를 처음부터 새로 그려야 해서 일부 사용자는 페이지가 전환될 때 부자연스러운 모습을 보게 된다. 페이지 전환이 서버에서 이뤄지므로 브라우저 환경이 충분히 빠르지 못하다면 흰 화면이 잠시 노출될수 있다.

#### SPA CSR과 MPA SSR(서버에서 모든 페이지를 각각 빌드)에 대해 확실한 것

1. 가장 뛰어난 SPA는 가장 뛰어난 MPA보다 낫다.

- 최초 페이지 진입 시 보여줘야 할 정보만 최적화해 요청해서 렌더링
- 이미지와 같은 중요성이 떨어지는 리소스는 레이지로딩으로 렌더링에 방해되지 않도록 처리
- code splitting(사용자에게 필요한 코드만 나눠서 번들링하는 기법)으로 불필요한 자바스크립트 리소스의 다운로드 및 실행 방지
- 라우팅이 발생하면 변경이 필요한 HTML 영역만 교체해 사용자의 피로감 최소화, 매끄러운 라우팅

2. 평균 SPA는 평균 MPA 보다 느리다.

- 평균적인 노력으로 평균적인 사용자 경험을 제공한다고 가정하면, 별도의 최적화를 거쳐야하는 SPA보다 MPA가 더 나은 경험을 제공
- MPA는 매번 서버에 렌더링 요청을 하고 서버는 안정적인 리소스를 기반으로 매 요청마다 비슷한 성능의 렌더링 수행
- SPA는 사용자 기기에 따라 성능이 들쑥날쑥하고, 페이지 전환시에 필요한 리소스와 공통으로 사용하는 리소스로 분류하고 이에 따른 다운로드나 렌더링 우선순위 전략을 잘 수립해 서비스하기란 매우 어렵다.
- 최근에는 MPA에서 발생하는 라우팅으로 인한 문제를 해결하기 위한 다양한 API가 브라우저에 추가
  - Paint Holding: 같은 origin에서 라우팅이 일어날 경우 화면을 잠깐 하얗게 띄우는대신 이전 페이지의 모습을 잠깐 보여주는 기법
    - 브라우저가 기존 페이지를 잠시 그대로 붙잡아두고(paint hold) 새 문서의 first paint 준비가 끝날 때까지 유지. 그래서 화면이 흰색으로 깜빡이지 않음
    - 페인트 홀딩은 페이지 간 이동(Navigation)에서만 동작하기 때문에, 최초 진입(첫 화면)에서는 절대 적용되지 않는다.
  - back forward cache(bfcache): 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
  - Shared Element Transitions: 페이지 라우팅이 일어났을 때, 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법

#### 현대의 SSR ➡ MPA가 아니라 SSR + SPA가 합쳐진 하이브리드 모델

옛날 SSR = MPA 였지만 현대의 SSR은 완전히 다른 의미다.

- Next.js, Remix, Nuxt 같은 현대 SSR 프레임워크는 SPA 기반 기술 위에서 ‘렌더링만 서버에서’ 수행하는 구조
- HTML은 서버에서 렌더링되지만
- 모든 페이지가 하나의 React 앱 구조 안에서 동작
- hydration, streaming 등 SPA 개념 포함
- Client-side navigation 지원
- MPA처럼 완전한 페이지 교체 없음

현대 SSR은 이렇게 동작함

1. 최초 요청 → 서버에서 React 컴포넌트를 HTML로 생성 (SSR)
2. HTML 전송 후 → JS가 hydrate (CSR)
3. 이후 페이지 이동 → SPA처럼 JS 기반 네비게이션

즉,

- 첫 렌더는 SSR
- 이후 렌더는 CSR
- 구조는 SPA
- 라우팅은 클라이언트
- SEO/LCP는 SSR 덕분에 빠름

- 초기 페이지 진입은 SSR로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 받은 자바스크립트를 바탕으로 CSR 처럼 작동
  - SSR은 초기 페이지 진입이 빠른 반면, 라우팅이 느리다.

### 잘못된 웹페이지 설계는 성능을 헤친다.

- 눈에 띄는 성능 개선도 얻지 못하고, 서버와 클라이언트 두 군데로 관리 포인트만 늘어나는 역효과를 낳을 수도 있다.
- 웹페이지의 설계와 목적, 그리고 우선순위에 따라 적절한 렌더링 방식 설계
  - 웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지
  - 어떤 우선순위에 따라 페이지의 내용을 보여줄지
- SPA가 제공하는 보일러플레이트나 라이브러리가 점차 완벽해지면서 잠재적인 모든 위험을 제거할 수도 있고
- MPA가 브라우저 API의 도움을 받아 SPA와 같은 끊김 없는 사용자 경험을 제공할 수도 있다.

## 서버 사이드 렌더링을 위한 리액트 API 살펴보기

- 기본적으로 리액트는 프론트엔드 라이브러리로, 브라우저 자바스크립트 환경에서 렌더링
- 하지만 리액트 애플리케이션을 서버에서 렌더링 할 수 있는 API도 제공. 이 API는 당연히 브라우저의 window환경이 아닌 Node.js와 같은 서버 환경에서만 실행할 수 있다.
- SSR을 실행할 때 사용되는 API는 리액트 저장소 react-dom/server.js 를 확인. react-dom이 서버에서 렌더링하기 위한 다양한 메서드를 제공.

#### renderToString

- SSR을 구현하는데 가장 기초적인 API. 최초의 페이지를 HTML로 먼저 렌더링하는 함수.
- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- 인수로 주어진 리액트 컴포넌트를 기준으로 빠르게 브라우저가 렌더링할 수 있는 HTML을 제공하는데 목적이 있는 함수.
- 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 해주지는 않는다.
- 루트 요소에 data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들어서 자바스크립트를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점으로 쓴다.

```js
// React 19 / React 18에서는 이렇게 씀
import { renderToString } from "react-dom/server";

const html = renderToString(<App />);
```

#### renderToStaticMarkup

- 루트 요소에 data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다. 리액트에서만 사용하는 속성을 제거해 결과물인 HTML의 크기를 아주 약간이라도 줄일 수 있다. hydrate을 수행하지 않는 다는 가정 하에 리액트와 관련된 코드인 data-reactroot가 사라진 완전히 순수한 HTML 문자열이 반환.
- 블로그 글, 상품의 약관 정보 등 아무런 브라우저 액션이 없는 정적인 내용만 필요한 경우 유용

#### renderToNodeStream

- 스트림: 큰 데이터를 청크로 분할해 조금씩 가져오는 방식

- renderToString과 결과물이 동일하지만 두가지 차이점 있음
  - renderToString, renderToStaticMarkup은 브라우저에서도 실행 가능(물론 브라우저에서 실행할 이유는 없지만). renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능.
  - renderToString은 결과물이 string이다. renderToNodeStream은 결과물이 Node.js의 ReadableStream이다. 궁극적으로 브라우저가 원하는 결과물, 즉 string을 얻기 위해서는 추가 처리 필요
    - ReadableStream은 utf-8로 인코딩된 바이트 스트림으로 Node.js나 Deno, Bun같은 서버 환경에서만 사용가능
    - ReadableStream 자체는 브라우저에서도 사용할 수 있는 객체다. 그러나 ReadableStream을 만드는 과정이 브라우저에서 불가능하게 구현돼 있다.
  - renderToString으로 생성해야하는 HTML의 크기가 매우 크다면, 큰 문자열을 한번에 메모리에 올려두고 응답을 수행해야 해서 Node.js가 실행되는 서버에 큰 부담. 렌더링 시간도 많이 소요. 스트림을 활용하면 큰 크기의 데이터를 청크해 순차적으로 처리.
    - 응답으로 HTML을 여러 청크로 분리해 내림. 브라우저에 제공해야 할 큰 HTML을 작은 단위로 쪼개 연속적으로 작성함으로써 Node.js 서버의 렌더링 부담을 덜 수 있다.

#### renderToStaticNodeStream

- renderToNodeStream과 제공하는 결과물은 동일하나, 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.
- 마찬가지로 hydrate할 필요 없는 순수 HTML 결과물이 필요할 때 사용

#### hydrate

- renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할
- renderToString의 결과물은 단순히 서버에서 렌더링한 HTML 결과물로 사용자에게 무언가 보여줄 수 있지만, 사용자가 페이지와 인터랙션하는 것은 불가능
- hydrate은 이처럼 정적으로 생성된 HTML에 이벤트와 핸들러를 붙여 완전한 웹페이지 결과물을 만든다.
- hydrate은 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다.
- hydrate으로 넘겨준 두번째 인수에는 이미 renderToString 등으로 렌더링된 정적인 HTML정보가 담겨 있어야 한다.
  - hydrate과 비슷하지만 브라우저에서만 사용되는 메서드인 render
    - render는 컴포넌트와 HTML의 요소를 인수로 받고, HTML의 요소에 해당 컴포넌트를 렌더링하며, 여기에 이벤트 핸들러를 붙이는 작업까지 모두 한번에 수행한다.
    - render는 클라이언트에서만 실행되는, 렌더링과 이벤트 핸들러 추가 등 리액트를 기반으로 한 온전한 웹페이지를 만드는 데 필요한 모든 작업을 수행.
- hydrate mismatch
  - hydrate작업은 단순히 이벤트를 추가하는 것 외에도 렌더링을 한번 수행하면서 hydrate이 수행한 렌더링 결과물 HTML과 인수로 넘겨받은 HTML을 비교한다. 여기서 발생한 불일치가 바로 에러의 원인.
  - 불일치가 발생하면 hydrate이 렌더링한 기준으로 웹페이지를 그린다.
  - 이렇게 렌더링 하는 것은 사실상 서버와 클라이언트에서 두 번 렌더링을 하게 되고, 결국 SSR의 장점을 포기하는 것이기 때문에 반드시 고쳐야한다.
  - 하지만 불가피하게 결과물이 다를 수 밖에 없는 경우도 있다.
    - 예를 들어 HTML 내부에서 현재 시간을 초 단위까지 기록해야 한다면, SSR과 hydrate이 아무리 빨리 끝난다 하더라도 1초 단위로 끝나지 않는 이상 불일치가 발생할 수 밖에 없으며 결국 hydrate은 에러를 발생시킨다.
    - 불가피하게 불일치가 발생할 수 있는 경우에는 해당 요소에 suppressHydrationWarning 을 추가해 경고를 끌 수 있다. 물론 필요한 곳에서만 제한적으로 사용해야 한다.
    - HTML에 정확한 시간을 기록하기 위한 목적이라면 서버에서 실행되는 것보다 차라리 useEffect를 통해 노출하는 편이 더 정확하므로 서버에서 굳이 해당 함수를 실행조차 하지 않는 것이 나을 수 있다.

### React Server Component(RSC)

컴포넌트를 서버에서 실행해서 HTML이 아니라 React 전용 데이터로 보내는 방식

- 단순 SSR과 전혀 다름. RSC는 SSR을 대체하는 게 아니라 새로운 렌더링 모델
- HTML이 아니라 RSC Payload라는 특별한 데이터 포맷이 사용됨

#### RSC는 SSR과 완전히 다르다

- SSR(Server-Side Rendering) → SSR은 “HTML 전달”

  - 서버에서 HTML을 만들어서 보내는 것
  - 그 HTML을 브라우저가 받아서 화면 렌더
  - 이후 React가 hydrate

- RSC(Server Component) → RSC는 “React Component 전달”
  - 서버에서 컴포넌트 로직을 실행하고
  - HTML이 아닌 “컴포넌트 구조 데이터”를 보내고
  - 클라이언트가 그걸 받아서 React로 다시 구성

### Suspense

Promise(비동기)을 기다리는 동안 보여줄 UI를 정하는 React API

```jsx
<Suspense fallback={<Loading />}>
  <UserProfile />
</Suspense>
```

### Concurrency(동시성 기능)

- React가 여러 렌더링 작업을 동시에 준비하고, 더 중요한 작업을 먼저 보여주는 기술
- React의 Concurrency은 Fiber(새로운 렌더링 엔진 구조: 렌더링 작업을 잘게 쪼개고, 중단하고, 다시 이어붙일 수 있게 만든 구조) 아키텍처 위에서 동작하도록 설계된 기능

### 기타

- 소스맵(Source Map): 브라우저가 번들된 코드 → 원본 코드로 연결해주는 지도 파일. 컴파일, 번들된 JS/CSS를 원래 코드로 되돌려 보여주는 번역기
- webpack.config.js : entry를 선언해 시작점을 선언, 필요한 파일과 그에 맞는 loader제공, 번들링에서 제외할 내용을 선언한 뒤 output으로 내보낸다.

#### 네이티브 앱 vs 웹 앱 vs 하이브리드 앱

- 하이브리드 앱은 앱 안에 WebView(내장 브라우저)를 넣고, 그 안에서 HTML/CSS/JS로 만든 페이지가 동작하는 앱이다.앱처럼 설치되지만 내부는 웹 페이지처럼 렌더링됨.

| 유형              | 화면이 어떻게 만들어짐?                                        | 예시                                              |
| ----------------- | -------------------------------------------------------------- | ------------------------------------------------- |
| **네이티브 앱**   | Swift(Kotlin) 등 네이티브 언어로 화면을 100% 제작              | 카카오톡 대화 화면, 인스타그램 피드               |
| **웹 앱**         | 브라우저에서 HTML/CSS/JS로 렌더링                              | 모바일 웹사이트, m.naver.com                      |
| **하이브리드 앱** | 네이티브 앱 안에 WebView를 넣고 그 안에서 HTML 페이지를 렌더링 | 배민·쿠팡 결제/이벤트 페이지, 앱 약관/공지 페이지 |

## Next.js 톺아보기
