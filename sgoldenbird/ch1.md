# Ch1

## 1.0 왜 리액트인가?

* <mark style="background-color:yellow;">단방향 바인딩</mark>만 지원 (Angular는 양방향 바인딩) → 데이터의 흐름이 한쪽으로만 간다.
* 기존 자바스크립트 문법에 HTML을 약간 가미한 수준으로 배우기 쉽고 간결. (Angular의 경우 뷰를 포현하기 위해 문자열 템플릿 사용, ngIf처럼 Angular 전용 문법 익혀야 함)
* 단순히 UI를 위한 라이브러리로만 작동함으로써 그 역할에 제한을 두고 그 외 모든 것에 자유도를 둠. 개발자들이 리액트를 기반으로 다양한 것을 시도하면서 커다란 커뮤니티를 얻게 됨.

### 단방향 vs 양방향

* 단방향 바인딩은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야 한다. 코드 규모 증가.
* 양방향으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠수도, 컴포넌트의 상태 변화가 뷰에 영향을 미칠수도 있다. 코드의 규모가 커질수록 상태 변화가 무엇으로 인해 일어났는지 파악하기 어려움.

## 1.1 자바스크립트의 동등 비교

* 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다.
* 자바스크립트 문자열은 원시타입, 변경 불가능.

### undefined vs null

* undefined: 선언되었지만 할당되지 않은 값
* null: 명시적으로 비어 있음을 나타내는 값

### 탬플릿 리터럴

* 백틱을 사용해서 표현
* 줄바꿈이 가능하고 문자열 내부에 표현식을 쓸 수 있다.

### Symbol

* 중복되지 않는 고유한 값
* 심벌 함수를 이용해서만 만들수 있다. `Symbol()`
* 심벌 함수에 같은 인수를 넘겨주더라도 동일한 값으로 인정되지 않는다.
* 동일한 값을 사용하기 위해서는 `Symbol.for()`를 사용한다.

### 객체 타입

* 객체 타입에는 배열, 함수, 정규식, 클래스 등이 있다.
* 객체는 프로퍼티를 삭제, 추가, 수정 할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장된다.
* 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

### Object.is

* 리액트에서 사용하는 동등비교는 Object.is다.
* 리액트는 Object.is를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 만들어 사용
* 리액트는 Object.is로 먼저 비교를 수행한 다음, shallowEqual로 Object.is에서 못하는 객체 간 얕은 비교를 한번 더 수행(1 depth)

### === 와 차이

* \==는 강제 형변환 후 비교

```js
-0 === +0; //true
Object.is(-0, +0); //false

Number.NaN === NaN; //false
Object.is(Number.NaN, NaN); //true

NaN === 0 / 0; //false
Object.is(NaN, 0 / 0); //true
```

*   왜 굳이 구분할까?

    * 몇몇 수학적 연산이나 부동소수점 연산에서 차이가 있기 때문

    ```js
    1 / +0; // Infinity
    1 / -0; // -Infinity
    ```
* 왜 0/0은 NaN일까?
  * 어떤 경우에는 0/0이 1처럼 보일 수 있고, 어떤 경우에는 무한대, 어떤 경우에는 다른 값… 즉 일관된 하나의 값으로 정의할 수 없기 때문에 JS는 NaN처리

### 호환성 도구(compatibility tools)

#### Polyfill

* 브라우저(혹은 런타임)가 지원하지 않는 기능을 흉내내어 똑같이 동작하게 만든 코드
* 구형 환경에서도 최신 기능을 쓸 수 있게 해주는 일종의 보완 코드

#### Transpiler

* 최신 자바스크립트 문법을 구형 자바스크립트 문법으로 변환해주는 도구
* Babel: 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일. (최신 → ES5)

## 1.2 함수

* 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것.
* 표현식: 무언가 값을 산출하는 구문
* <mark style="background-color:yellow;">일급객체</mark>: 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체. 즉, 보통 함수나 객체가 다른 일반 값들과 똑같이 취급될 수 있는지를 판별하는 개념. 자바스크립트 함수는 일급 객체. 함수는 다른 함수의 매개변수, 반환값, 할당도 가능.
* 이름을 가진 함수 리터럴은 코드 문맥에 따라 선언문으로도, 표현식으로도 사용될 수 있다.

#### 런타임

* <mark style="background-color:yellow;">코드가 실제로 실행되는 환경</mark>
* 프로그래밍 언어의 코드는 그냥 텍스트일 뿐이고, 이게 실행되려면 <mark style="background-color:yellow;">엔진, 라이브러리, API, 메모리 관리 시스템</mark> 같은 실행 환경이 필요. 이 실행 환경 전체를 통틀어 런타임이라고 부른다.
* 자바스크립트 런타임 (브라우저) → 아래 전체가 자바스크립트 브라우저 런타임 환경
  * V8 엔진(코드 해석/실행)
  * Web API (setTimeout, DOM, fetch 등)
  * 이벤트 루프(Event Loop) + 태스크 큐/마이크로태스크 큐
* Node.js 런타임 → 서버 사이드에서 JS를 실행할 수 있게 만드는 런타임
  * V8 엔진
  * Node.js API (fs, http, crypto 등)
  * 이벤트 루프(libuv 기반)
* Java 런타임 (JRE) → 자바 프로그램 실행 환경
  * JVM + 표준 라이브러리

### 함수 표현식과 선언문의 차이 - 호이스팅

* 함수 호이스팅: 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징. 함수에 대한 선언을 실행 전에 미리 메모리에 등록.
* 변수 호이스팅: 함수 표현식은 함수를 변수에 할당했기 때문에 변수 호이스팅 발생.
  * `var` vs `let, const`: 함수 호이스팅과 다르게 호이스팅 되는 시점에(런타임 이전에) var의 경우 undefined로 초기화. let, const는 TDZ

### 화살표 함수

* 생성자 함수로 화살표 함수를 사용할 수 없다.
* arguments가 존재하지 않는다.
* 화살표 함수는 함수 자체의 바인딩을 갖지 않는다.
* <mark style="background-color:yellow;">화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.</mark>
* 별도의 작업을 추가로 하지 않고 this에 접근할 수 있는 방법이 바로 화살표 함수.
* 화살표 함수가 디버깅이 어려운 이유&#x20;
  * 주로 **에러 스택 추적(stack trace)**&#xC774;나 **디버거에서 함수 이름이 어떻게 보이는가**랑 관련
  * 일반 기명함수는 에러 스택에 함수 이름이 나와서  어디서 문제인지 바로 알 수 있음
  * 화살표 함수는 변수에 할당하기 때문에 내부적으로는 익명 함수라서 스택 트레이스에 함수명이 안뜨거나 anonymous로 표시(무기명 함수처럼)

### this 바인딩

* 함수가 어떻게 호출되냐에 따라 동적으로 결정되는 자기 참조 변수
  * 전역에서 일반함수로 호출 → 전역 객체
  * 객체의 메소드로 호출 → 호출한 객체
  * new 키워드로 호출 → 새로 생성된 인스턴스
  * 이벤트 핸들러 → 이벤트가 발생한 DOM요소
  * 화살표 함수는 호출 방식과 무관하게 선언될 당시 상위 스코프의 this
  * 명시적으로 특정 객체를 this에 바인딩하고 싶다면 bind, call, apply 같은 메소드 사용

### 즉시 실행 함수(IIFE)

* 함수를 정의하고 그 순간 즉시 실행되는 함수.
* 단 한번만 호출되고 다시는 호출 할 수 없다.
* 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다. 즉시 실행 함수 내부에 있는 값은 그 함수 내부가 아니고서는 접근이 불가능 하기 때문.

### 고차 컴포넌트

* 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환한다.
* 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있다.

### 순수함수와 함수의 부수효과

* 함수의 부수효과: 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
  * 아래와 같은 것들은 **컴포넌트 UI를 그리는 과정과는 별개**라서 부수효과(side effect)라고 부른다.
    * 데이터 fetch (fetch, axios 요청)
    * DOM 직접 조작 (스크롤 위치, 포커스)
    * 이벤트 등록/해제
    * setTimeout / setInterval
    * 콘솔 출력, 로그 기록\

* <mark style="background-color:yellow;">순수 함수</mark>: 부수효과 없는 함수. 동일한 인수를 받으면 항상 동일한 결과를 반환 → 예측가능, 안정적
* 부수효과는 피할 수 없지만 최소화.
  * API 호출 → HTTP request로 서버 상태를 바꾸거나(POST/PUT/DELETE) 외부 상태에 의존해 결과가 달라질 수 있음(GET)
  * console.log → 브라우저 콘솔 창이라는 외부에 영향
* 부수효과를 처리하는 useEffect 훅의 작동을 최소화 → 함수의 역할을 좁히고 버그를 줄이고 컴포넌트의 안정성을 높임
  * useEffect가 부수효과 처리 훅이라고 불리는 이유는 의존성 배열 때문이 아니라, **그 안에서 하는 일이 렌더링 외적인 작업**이기 때문
  *   React는 함수 컴포넌트를 순수 함수처럼 다루려고 한다.&#x20;

      * 입력(props, state) → 출력(JSX)
      * 이 안에서는 예측 가능한 동작만 일어나야 함

      하지만 실제로 앱을 만들다 보면 위에서 말한 부수효과가 필요하다. \
      그래서 React가 부수효과 전용 훅인 useEffect를 따로 제공하는 것.&#x20;

### 함수를 만들 때 주의해야 할 사항

* 함수의 부수 효과를 최대한 억제하라
* 하나의 함수가 너무 많은 역할을 하지 않도록 작게 만들어라
* 누구나 이해할 수 있는 이름
  * useEffect 등 훅에 넘겨주는 콜백 함수에 네이밍하면 디버깅과 가독성 향상

## 1.3 클래스

* 특정한 형태의 객체를 반복적으로 만들기 위한 일종의 템플릿
* 프로토타입 체이닝: 직접 객체에서 선언하지 않았음에도 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것
* 클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것
* 정적 메서드 내부의 this는 클래스로 생성된 인스턴스가 아닌 클래스 자신을 가리키기 때문에 클래스 명으로 접근
  * 객체를 생성하지 않아도 여러곳에서 재사용이 가능하기 때문에 전역에서 사용하는 유틸함수를 정적 메서드로 많이 활용

## 1.4 클로저

* <mark style="background-color:yellow;">부수 효과가 없고 순수해야 한다는 목적</mark>을 달성하기 위해 적극적으로 사용된다.
* 선언된 어휘적 환경( Lexical Environment): 변수가 코드 내부에서 어디서 선언됐는지.
* 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존.
* 리액트가 관리하는 내부 상태값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.
* 전역 스코프는 누구든 접근할 수 있고 수정할 수 있다.
* 클로저를 활용하면 전역 스코프의 사용을 막고 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다.
*   활용 예시

    * `useState`도 클로저. state가 저장돼 있는 어딘가를 기억하기 때문에 계속 state값 사용 가능.
    * `useState`의 변수를 저장해 두고, 변수 접근 및 수정은 클로저 내부에서 확인이 가능해 값이 변하면 렌더링 함수를 호출.
    * innerFunction이 선언된 어휘적 환경, 즉 outerFunction에는 x가는 변수가 존재하며 반환된 innerFunction에서는 x라는 변수가 존재하던 환경을 기억한다.

    ```js
    function outerFunction() {
      var x = "hello";
      function innerFunction() {
        console.log(x);
      }

      return innerFunction;
    }

    const innerFunction = outerFunction();
    innerFunction(); // "hello"
    ```

    * counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막고, 접근하는 경우를 제한해 로그를 남길 수도 있음
    * counter 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막음

    ```js
    function Counter() {
      var counter = 0;

      return {
        increase: function () {
          return ++counter;
        },
        decrease: function () {
          return --counter;
        },
        counter: function () {
          console.log("counter에 접근!");
          return counter;
        },
      };
    }

    var c = Counter();
    ```
* 주의: <mark style="background-color:yellow;">클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가 비용</mark>이 든다. (메모리 저장 용량에 영향). 적절한 스코프로 가둬야함.

### 스코프

* 자바스크립트는 기본적으로 함수 레벨 스코프. 즉, { }블록이 스코프 범위를 결정하지 않는다.
* 자바스크립트에서 스코프는 일단 가장 가까운 스코프에서 변수가 존재하는지를 먼저 확인.

## 1.5 이벤트 루프와 비동기 통신의 이해

* 자바스크립트는 싱글 스레드, 동기 방식으로 작동
* 프로세스
  * 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
  * 하나의 운영체제에는 수백 개의 프로세스가 동시에 존재
  * 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리
    * 크롬 chrome.exe 라는 실행 파일이 메모리에 올라가면서 프로세스가 됨&#x20;
    * 크롬, 디스코드, VSCode 같은 실행 프로그램 하나하나가 최소 1개의 프로세스로 동작
      * 어떤 프로그램은 프로세스 1개만 실행할 수도 있고 (단일 프로세스)
      * 어떤 프로그램은 자체적으로 여러 프로세스를 띄울 수도 있다. (멀티 프로세스)
      * 예시:
        * 크롬(Chrome)
          * 최소 1개의 브라우저 프로세스 + 탭마다 별도의 렌더러 프로세스
          * 작업 관리자 열어보면 chrome.exe가 여러 개 떠 있는 걸 볼 수 있음
        * 디스코드
          * 보통 메인 프로세스(앱 껍데기) + 백그라운드 업데이트/보조 프로세스 몇 개
        * VSCode
          * 에디터 UI를 띄우는 메인 프로세스 + 확장 실행 프로세스 + Electron 기반 백엔드 프로세스 등

### 스레드 vs 동기

* 스레드
  * <mark style="background-color:yellow;">**CPU가 작업을 수행하는 실행단위**</mark>. 프로세스보다 더 작은 실행단위
  * 하나의 프로세스에는 여러 개의 스레드를 만들수 있다.
  * 스레드 끼리는 메모리를 공유할 수 있어 여러 작업을 동시에 수행할 수 있다.
  * 스레드는 하나의 프로세스에서 동시에 서로 같은 자원에 접근해 여러번 수정하는 등 동시성 문제가 발생할수 있다.
  * 각각 격리되어있는 프로세스와 달리 하나의 스레드가 문제 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제 발생
  * 싱글스레드: 한번에 하나의 작업만 처리하는 구조
  * 멀티스레딩은 메모리 공유로 인해 동시에 같은 자원에 접근 하면 타이밍 이슈 발생.
  * 멀티스레딩 환경: Node.js Worker, 브라우저 WebWorker
* 동기/비동기
  * <mark style="background-color:yellow;">**작업 순서**</mark>
  * 동기: 순차적, 기다림. 요청이 시작된 후에는 무조건 응답을 받은 후에야 비로소 다른 작업 처리할 수 있다.
  * 비동기: 비동기 함수 선언 시 쓰는 async. 응답이 오건 말건 다음 작업이 이루어진다.
  * <mark style="background-color:yellow;">자바스크립트가 싱글스레드임에도 비동기 처리가 가능한 것은 이벤트 루프 덕분이다.</mark>

### 이벤트 루프

* 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
* 콜스택: 자바스크립트에서 수행해야할 코드나 함수를 순차적으로 담아두는 스택
* 이벤트 루프는 호출 스택이 비어있는지 확인.
* 코드를 실행하는 것과 호출 스택이 비어있는지 확인하는 것 모두 단일 스레드에서 일어남. 즉, 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어남.

```js
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 3000);
  baz();
}

foo();
```

* setTimeout → 동기적으로 작동.
* 콜백 bar() → 비동기적으로 작동.
* JS엔진이 콜스택에서 setTimeout 실행 → <mark style="background-color:yellow;">**브라우저(WebAPIs영역)에게 타이머 작업 위임**</mark> → setTimeout완료, 다음 작업 실행
* <mark style="background-color:yellow;">**타이머 카운트다운은 브라우저가 실행**</mark> → **브라우저(WebAPI)가** 타이머를 돌려 <mark style="background-color:yellow;">**일정 시간(3000)이 지나면 콜백을 태스크 큐에 넣음**</mark>
* 이벤트 루프가 콜스택이 완전히 비면 태스크 큐에서 콜백을 콜스택으로 가져옴
* 콜백함수 실행은 콜스택에서 자바스크립트 엔진이 수행

#### Web API

* 브라우저가 자바스크립트에 제공하는 API
* <mark style="background-color:yellow;">자바스크립트 자체에는 없는 기능을 브라우저가 추가 기능으로 제공</mark>해서, 예를 들어 _<mark style="background-color:yellow;">DOM 조작, 비동기 타이머, 네트워크 통신</mark>_ 같은 작업을 할 수 있습니다.
* 즉, 웹 애플리케이션이 브라우저 환경과 상호작용할 수 있도록 하는 인터페이스라고 할 수 있습니다.
* 자바스크립트 자체만으로는 브라우저나 OS에 접근할 방법이 없기 때문에 브라우저가 Web API를 제공하고, 자바스크립트는 이걸 이용해:
  * DOM 조작
  * 이벤트 처리
  * 네트워크 통신
  * 파일 시스템 접근
  * 디바이스 기능 활용(GPS, 카메라, 마이크 등)
* 대표적인 Web API 예시
  * DOM API: document.querySelector(), element.addEventListener()
  * Timer API: setTimeout(), setInterval()
  * Network API: fetch(), XMLHttpRequest
  * Storage API: localStorage, sessionStorage, IndexedDB
  * Worker API: Web Worker, Service Worker
  * 기타: Canvas API, Geolocation API, WebRTC, Web Audio API 등

### 태스크 큐(마크로 큐, 이벤트 큐), 마이크로 태스크 큐

#### 태스크 큐

* 비동기 함수의 콜백 함수나 이벤트 핸들러 등
* <mark style="background-color:yellow;">이벤트 루프는 태스크 큐를 한 개 이상 가지고 있다.</mark>
* 태스크 큐는 자료 구조의 큐가 아니고 set 형태를 띄고 있다. 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다.
* 자료 구조 큐: FIFO
* 메인 스레드가 아닌 _태스크 큐가 할당되는 별도의 스레&#xB4DC;_&#xC5D0; 작업을 할당해 브라우저나 Node.js가 수행

#### 마이크로 태스크 큐

* <mark style="background-color:yellow;">이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있다.</mark> Promise
* 태스크 큐보다 우선. 마이크로 태스크 큐가 빌 때까지 태스크 큐의 실행은 뒤로 미뤄진다.
* <mark style="background-color:yellow;">**동기 → micro task → requestAnimationFrame → 브라우저 렌더링 → macro task**</mark>
  * 마이크로 태스크를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날때마다 한번씩 렌더링할 기회를 얻게 된다.
  * 동기 코드는 물론이고 마이크로 태스크 또한 렌더링에 영향을 미칠 수 있다.
  * 마이크로 태스크는 렌더링 보다 우선이고 큐가 빌때까지 연속실행. 그 사이에는 화면이 갱신되지 않는다. 그래서 동기처럼 밀리고 한번에 끝난 후 갱신.

#### rAF (vs setTimeout)

* requestAnimationFrame(rAF)은 _브라우저가 다음 프레임을 그리기 직전에 특정 콜백 함수를 실행하도록 예약하는 API_
* rAF를 쓰면 <mark style="background-color:yellow;">브라우저의 렌더링 주기와 맞춰서 애니메이션을 최적화</mark>
* requestAnimationFrame은 브라우저에 다음 리페인트 전에 콜백 함수 호출을 가능하게 한다.
*   보통 60fps(16.7ms 간격)로 동작하는 디스플레이에 맞춰 최적의 타이밍에 실행되므로, 애니메이션이 부드럽습니다.

    * FPS (Frames Per Second) = 초당 화면이 몇 번 갱신되냐
    * 60fps → 1초에 60번 화면 갱신
    * 1프레임당 약 16.7ms (1000ms ÷ 60 ≈ 16.7ms) 가 할당됨
    * 렌더링이 일어나는 주기
      * 화면 주사율이 60Hz라면, 디스플레이가 16.7ms마다 한 번씩 새로운 화면을 그릴 준비
      * 브라우저는 이 리듬에 맞춰 최대 1프레임의 화면만 준비할 수 있다.
      * 즉, 16.7ms마다 1프레임이 만들어지는 것
    * 1초 시간축(1000ms) ⏱️

    ```lua

    0ms       16.7ms       33.4ms       50.1ms ... 1000ms(1초)
     |----------|------------|------------| ... |
       frame1      frame2        frame3        ... frame60

    ```
* 반면 setTimeout(fn, 16) 같은 방식은 정확히 16ms마다 실행된다고 보장되지 않는다. 브라우저 리페인트 시점과 어긋날 수 있어서 티어링(끊김) 같은 현상이 생긴다.
* rAF는 탭이 비활성화되거나 브라우저가 백그라운드로 가면 자동으로 중단되거나 느려짐. 즉, 불필요한 CPU 자원 소모를 막음 → 배터리 절약, 성능 최적화에 유리.
* setTimeout은 브라우저가 알아서 최적화하지 않으면 계속 돌아갈 수 있음.

#### 프레임

* 프레임은 사용자가 보는 화면의 한 "정지된 그림". 렌더링의 결과물.
* 애니메이션이나 동영상은 사실 정지 그림(프레임)을 아주 빠르게 연속해서 보여주는 것일 뿐이다. 에니메이션은 렌더링의 반복.
* 60fps → 1초에 정지 그림 60장을 보여줌
* 120fps → 1초에 정지 그림 120장을 보여줌
* 브라우저는 프레임을 짧은 간격(보통 16.7ms)으로 계속 만들어내서 갱신
* 브라우저가 한 프레임을 만드는 과정은 보통 이렇게 흘러감
  * 자바스크립트 실행 (JS): DOM 변경, 스타일 변경, 좌표 이동 같은 작업이 일어남.
  * 스타일 계산 (Style): 어떤 CSS가 적용되는지 다시 계산.
  * 레이아웃 (Layout): 요소의 크기와 위치를 다시 배치.
  * 페인트 (Paint): 실제 픽셀 단위로 색칠.
  * 합성 (Composite): 여러 레이어를 합쳐 최종 그림(프레임) 완성.\
    이 “최종 그림”이 바로 프레임이고, 그게 모니터에 출력. 렌더링 과정이 프레임을 만들어내는 과정.

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

* 현재 Edge는 chromium 기반, 크롬과 거의 같다.

### 구조 분해 할당

배열, 객체의 값을 분해해 개별 변수에 즉시 할당하는 것

#### 배열 구조 분해 할당

* `useState`
* 변수 이름 자유롭게 선언
* undefined일 때만 기본값 사용
* 전개 연산자는 앞에서 사용 불가 (...rest)

#### 객체 구조 분해 할당

* 변수 이름은 객체 내부 이름 사용
* 객체 내부 키와 이름이 다르면 새로운 이름으로 다시 할당
* computed property name `[]` : 변수나 표현식을 \[ ]안에 넣어서 동적으로 키 이름 결정

```js
const {age} = user; 도 const {age:age} =user; 가 축약된것

const {[key]} = object // SayntaxError
```

* \[key]는 어떤 속성을 꺼낼지는 알려주지만 꺼낸 값을 어떤 변수에 담을지는 알려주지 않음. 그래서 : 뒤에 직접 변수명을 지정해야 함.

### 전개 구문

* 배열이나 객체, 문자열 같이 순회할 수 있는 값에 대해 전개
* iterable: 내부에 Symbol.iterator 메서드를 가지고 있어서 iterator를 반환할 수 있는 객체
* iterator는 next()를 호출하면 {value, done} 형태로 값을 하나씩 내놓는다.
* 객체 전개 구문에 있어서는 순서가 중요하다. 키와 값으로 이루어져 있어 덮어쓰일수 있기 때문.

### 객체 초기자 (object shorthand assignment)

* 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 간결하게 `a: a` 대신 `a`만 써도 된다.

### Array 프로토타입 메서드: map, filter, reduce, forEach

* 기존 배열의 값을 건드리지 않고 새로운 값을 만든다.

#### Array.prototype.map

* 배열의 각 아이템을 순회하며 각 아이템을 콜백으로 연산한 결과로 구성된 똑같은 길이의 새로운 배열 반환

#### Array.prototype.filter

* 콜백함수에서 truthy조건을 만족하는 경우에만 해당 원소를 반환

#### Array.prototype.reduce

* 콜백함수와 초깃값을 인수로 받음
* 콜백함수 반환값을 초깃값에 누적
* 합계 뿐 아니라 배열을 하나의 객체로 변환하는 등 활용

#### Array.prototype.forEach

* 배열을 순회하면서 단순히 그 콜백함수를 실행하기만 한다.
* forEach는 아무런 반환값이 없고, undefined다.
* 에러를 던지거나 프로세스를 종료하지 않는 이상, 멈출 수 없다. break, return, 그 무엇을 이요해도 배열 순회를 멈출 수 없다. (<mark style="background-color:yellow;">**for...of는 break, return 사용하면 순회를 멈출 수 있다.**</mark>)
* forEach내부의 콜백함수는 무조건 0(n)만큼 실행

## 1.7 선택이 아닌 필수, 타입스크립트
