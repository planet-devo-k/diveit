---
icon: memo-pad
---

# 클래스

### 자바스크립트 클래스 소개

* 클래스: 동일한 모양의 객체를 더 쉽게 생성하도록 도와주는 문법. 객체를 생성하는 틀
* 인스턴스: 클래스를 이용해서 만든 객체
* 필드: 클래스가 생성할 객체가 갖는 프로퍼티
* 생성자: 특수한 메서드로 실질적으로 객체를 생성하는 함수
  * 생성자에서는 매개변수로 프로퍼티 값을 받아 this.프로퍼티의 값으로 할당합니다.
  * 이때 this는 객체이며 현재 만들고 있는 객체를 의미합니다.
  * 생성자 메서드는 현재 만들고 있는 객체의 프로퍼티 값을 매개변수로 전달받은 값으로 설정하는 역할을 합니다.

1. 클래스 선언
2. 필드 선언
3. 생성자 선언 → 클래스를 호출하여 객체를 생성할 수 있습니다.

* 클래스를 이용해 새로운 객체를 생성할 때에는 new 클래스이름 형태로 클래스의 생성자 함수를 호출합니다.

4. 메서드 선언

```ts
class Student {
  // 필드
  name;
  age;
  grade;

  // 생성자
  constructor(name, grade, age) {
    this.name = name;
    this.grade = grade;
    this.age = age;
  }

  // 메서드; 클래스가 생성할 객체의 메서드도 설정할 수 있습니다.
  study() {
    console.log("열심히 공부 함");
  }

  introduce() {
    console.log(`안녕하세요! 홍길동입니다.`);
  }
}

const studentB = new Student("홍길동", "A+", 27);

studentB.study(); // 열심히 공부 함
studentB.introduce(); // 안녕하세요! 홍길동입니다.
```

* 클래스에 생성자가 없다면 객체를 생성할 수 없을까?
  * 클래스에 **생성자가 명시적으로 선언되어 있지 않더라도** 자바스크립트 엔진이 **기본 생성자를 자동으로 추가**해주기 때문에 객체를 생성할 수 있습니다.
  * 단, 이 경우에는 **매개변수가 없는 기본 생성자가 추가**되므로 new 클래스이름() 형태로만 객체를 생성할 수 있습니다.
* 언제 생성자를 꼭 써야 할까요?
  * 객체를 생성하는 순간에 외부에서 값을 받아와서 초기화해야 한다면 반드시 생성자가 필요합니다.
  * **생성자가 필요한 경우**: 객체마다 서로 다른 이름을 부여하고 싶을 때
  * **생성자가 필요 없는 경우**: 모든 객체가 동일한 초기값을 가지거나, 나중에 따로 값을 할당해도 될 때
* 상속(extends) 관계에서의 주의점
  * 상속을 받을 때는 생성자 규칙이 조금 더 엄격해집니다.
  * **자식 클래스에 생성자가 없다면**: **부모 클래스의 생성자를 자동으로 호출**합니다.
  * **자식 클래스에 생성자를 직접 쓴다면**: 반드시 **super()를 호출**해서 부모의 생성자를 먼저 실행시켜야 합니다.

#### this 활용하기

* this: 클래스가 생성할 객체 자신을 가리키는 특별한 식별자. 현재 만들고 있는 객체
* 메서드에 this를 활용해 객체 프로퍼티의 값을 활용하는 것 또한 가능합니다.

```ts
class Student {
  (...)

  introduce() {
    console.log(`안녕하세요 ${this.name} 입니다!`); // this는 만들어진 객체.
  }
}

let studentB = new Student("고양이", "A+", 27);

studentB.introduce(); // 안녕하세요 고양이 입니다!
```

#### 상속

* 앞서 만든 Student 클래스를 기반으로 추가적인 필드와 메서드를 갖는 클래스를 선언하고 싶다면 상속을 이용하면 됩니다.
* StudentDeveloper 클래스에서 Student 클래스의 생성자를 함께 호출해줘야 합니다.\
  그렇지 않으면 생성되는 객체의 name, grade, age 값이 제대로 설정되지 않습니다.
* 따라서 super 라는 메서드를 호출하고 인수로 name, grade, age를 전달하면\
  슈퍼 클래스(확장 대상 클래스)의 생성자를 호출합니다. → this.name, this.grade, this.age의 값을 설정하게 됩니다.

```ts
class StudentDeveloper extends Student {
  // 필드
  favoriteSkill;

  // 생성자
  constructor(name, grade, age, favoriteSkill) {
    super(name, grade, age); // 슈퍼 클래스의 생성자 호출
    this.favoriteSkill = favoriteSkill;
  }

  // 메서드
  programming() {
    console.log(`${this.favoriteSkill}로 프로그래밍 함`);
  }
}
```

### 타입스크립트의 클래스

* 타입스크립트에서는 클래스의 필드를 선언할 때 타입 주석으로 타입을 함께 정의해주어야 합니다.\
  그렇지 않으면 함수 매개변수와 동일하게 암시적 any 타입으로 추론되는데\
  엄격한 타입 검사 모드(strict 옵션이 true로 설정되어 있을 경우)일 때에는 오류가 발생하게 됩니다.
* 생성자에서 각 필드의 값을 초기화 하지 않을 경우 초기값도 함께 명시해주어야 합니다.
* 생성자 함수에서 필드의 값들을 잘 초기화 해 준다면 필드 선언시의 초기값은 생략해도 됩니다.

```ts
class Employee {
  // 필드
  name: string = "";
  age: number = 0;
  position?: string = "";

  // 생성자
  constructor(name: string, age: number, position: string) {
    this.name = name;
    this.age = age;
    this.position = position;
  }

  // 메서드
  work() {
    console.log("일함");
  }
}
```

#### 클래스는 타입입니다.

* 타입스크립트의 클래스는 타입으로도 사용할 수 있습니다.
* 클래스를 타입으로 사용하면 **해당 클래스가 생성하는 객체의 타입과 동일한 타입**이 됩니다.

```ts
class Employee {
  (...)
}

const employeeC: Employee = {
  name: "",
  age: 0,
  position: "",
  work() {},
};
```

#### 상속

* 타입스크립트에서 클래스의 상속을 이용할 때 서브 클래스에서 생성자를 정의 했다면\
  반드시 super 메서드를 호출해 슈퍼 클래스의 생성자를 호출해야 하며, \
  **호출 위치는 생성자의 최상단**이어야만 합니다.\
  자바스크립트와 달리 super 호출을 생략하면 오류가 발생합니다.

```ts
class ExecutiveOfficer extends Employee {
  officeNumber: number;

  constructor(
    name: string,
    age: number,
    position: string,
    officeNumber: number,
  ) {
    super(name, age, position);
    this.officeNumber = officeNumber;
  }
}
```

### 접근 제어자(Access Modifier)

* 클래스의 특정 필드나 메서드에 접근할 수 있는 범위를 설정하는 기능
* 타입스크립트 3개의 접근 제어자
  * public : 모든 범위에서 접근 가능. 기본
  * private : 클래스 내부에서만 접근 가능
  * protected : 클래스 내부 또는 파생(서브) 클래스 내부에서만 접근 가능

#### public

* public 접근 제어자를 직접 명시하는것도 가능합니다.

#### private

* name 필드를 private으로 설정했으므로 클래스 외부에서는 접근이 불가합니다. \
  (readonly랑 달리 읽을 수 조차 없음)\
  그러나 클래스 내부에서는 work 메서드 처럼 접근이 자유롭게 가능합니다.

```ts
class Employee {
  private name: string; // private 접근 제어자 설정
  public age: number;
  public position: string;

  ...

  work() {
    console.log(`${this.name}이 일함`); // 여기서는 접근 가능
  }
}

const employee = new Employee("이정환", 27, "developer");

employee.name = "홍길동"; // 오류
employee.age = 30;
employee.position = "디자이너";
```

#### protected

* private과 public의 중간으로 클래스 외부에서는 접근이 안되지만 클래스 내부와 파생 클래스에서 접근이 가능
* Employee 클래스를 확장(상속)하는 파생 클래스 ExecutiveOfficer를 선언한 다음 메서드 func를 만들었습니다. 이 메서드에서는 name은 private으로 접근이 불가하지만 age는 protected이므로 접근 가능합니다.\
  클래스 외부에서는 접근이 불가합니다.

```ts
class Employee {
  private name: string;
  protected age: number; // protected 접근 제어자 설정
  public position: string;

  ...

  work() {
    console.log(`${this.name}이 일함`);
  }
}

class ExecutiveOfficer extends Employee {
 // 메서드
  func() {
    this.name; // 오류 -> private은 파생클래스 내부에서도 접근안됨
    this.age; // 가능
  }
}

const employee = new Employee("이정환", 27, "devloper");

employee.name = "홍길동"; // 오류
employee.age = 30; // 오류
employee.position = "디자이너";
```

#### 필드 생략하기

* 접근 제어자는 생성자의 매개변수에도 설정할 수 있습니다.
* 그러나 생성자에 접근 제어자를 설정하면 동일한 이름의 필드를 선언하지 못하게 됩니다.\
  그 이유는 **생성자 매개변수에 접근 제어자가 설정되면 자동으로 필드도 함께 선언**되기 때문입니다.\
  따라서 동일한 이름으로 필드를 중복 선언할 수 없게 됩니다.
* 타입스크립트에서 클래스를 사용할 때에는 보통 생성자 매개변수에 접근 제어자를 설정하여\
  필드 선언과 생성자 내부 코드를 생략하는것이 훨씬 간결하고 빠르게 코드를 작성할 수 있어 좋습니다.

```ts
class Employee {
  // 필드 -> 제거
  private name: string; // ❌
  protected age: number; // ❌
  public position: string; // ❌

  // 생성자
  constructor(
    private name: string,
    protected age: number,
    public position: string,
  ) {
    this.name = name;
    this.age = age;
    this.position = position;
  }

  // 메서드
  work() {
    console.log(`${this.name} 일함`);
  }
}
```

* **접근 제어자가 설정된 매개변수들은 `this.필드 = 매개변수`가 자동으로 수행**됩니다.\
  따라서 모두 this 객체의 프로퍼티 값으로 자동 설정되기 때문에 생성자 내부의 코드를 제거해도 됩니다.

```ts
class Employee {
  constructor(
    private name: string,
    protected age: number,
    public position: string,
  ) {
    // 생성자 내부 자동 설정
  }

  work() {
    console.log(`${this.name} 일함`);
  }
}
```

### 인터페이스를 구현하는 클래스

* 타입스크립트의 인터페이스는 클래스의 설계도 역할을 할 수 있습니다.
* 인터페이스를 이용해 클래스에 어떤 필드들이 존재하고, 어떤 메서드가 존재하는지 정의할 수 있습니다.
* 클래스가 인터페이스를 implements 하면 이 클래스가 생성하는 객체는 모두 이 인터페이스 타입을 만족해야 합니다.
* **인터페이스는 무조건 public 필드만** 정의할 수 있다.

```ts
interface CharacterInterface {
  name: string;
  moveSpeed: number;
  move(): void;
}

class Character implements CharacterInterface {
  constructor(
    public name: string, // public 이어야 함(<-- 인터페이스 필드는 무조건 public)
    public moveSpeed: number, // public 이어야 함(<-- 인터페이스 필드는 무조건 public)
    private extra: string,
  ) {}

  move(): void {
    console.log(`${this.moveSpeed} 속도로 이동!`);
  }
}
```
