- 인터페이스: 타입 별칭과 동일하게 타입에 이름을 지어주는 또 다른 문법
- 인터페이스에서도 동일한 방법으로 옵셔널 프로퍼티, 읽기전용 프로퍼티 설정이 가능
- 인터페이스는 주로 객체의 구조를 정의하는 데 특화되어 있으며, 객체가 아닌 기본 타입이나 특수한 타입 구조를 정의하는 데는 한계가 있습니다.
- 객체 타입을 다루는 여러가지 특수한 기능들(상속, 합침 등) 제공

```ts
interface Person {
  readonly name: string;
  age?: number;
}

const person: Person = {
  name: "이정환",
  // age: 27,
};

person.name = "홍길동"; // ❌
```

## 메서드 타입 정의하기

- 함수 표현식으로 메서드 타입 정의

```ts
interface Person {
  readonly name: string;
  age?: number;
  sayHi: () => void;;
}
```

- 호출 시그니쳐로 메서드 타입 정의
  - 사실 엄밀히 말하면 메서드 앞에 이름이 붙어서 호출 시그니쳐는 아님

```ts
interface Person {
  readonly name: string;
  age?: number;
  sayHi(): void;
}
```

- 객체 안의 메서드 (일반적인 인터페이스)

```ts
interface Calculator {
  add(a: number, b: number): number; // 메서드 정의
}

// 사용 예시
const myCalc: Calculator = {
  add: (x, y) => x + y,
};

// myCalc 자체는 함수가 아니라 객체입니다.
// myCalc(); (오류 발생)
// myCalc.add(1, 2); (정상 작동)
```

- 함수 타입 인터페이스 (Call Signature)
  <br/>인터페이스 자체가 함수처럼 호출 가능하게 만들려면 호출 시그니처(Call Signature)라는 특수한 문법을 사용해야 합니다.
  <br/>호출시그니처가 정의돼있으면 타입 자체가 함수타입이 된다.
  <br/>이때는 메서드 이름을 쓰지 않고 괄호부터 시작합니다.

```ts
interface SumFunction {
  (a: number, b: number): number; // 이름 없이 바로 인자 정의
}

// 사용 예시
const mySum: SumFunction = (x, y) => x + y;

// mySum 자체가 함수이므로 직접 호출 가능합니다.
mySum(1, 2); // 정상 작동
```

- 하이브리드 타입 (객체이면서 함수인 경우)

```ts
interface Counter {
  (start: number): string; // 함수 역할 (호출 시그니처)
  interval: number; // 속성
  reset(): void; // 메서드
}
```

## 메서드 오버로딩

- 함수 타입 표현식으로 메서드의 타입을 정의하면 메서드의 오버로딩 구현이 불가능합니다.
- 그러나 호출 시그니처를 이용해 메서드의 타입을 정의하면 오버로딩 구현이 가능합니다.

```ts
interface Person {
  readonly name: string;
  age?: number;
  sayHi: () => void;
  sayHi: (a: number, b: number) => void; // ❌
}
```

```ts
interface Person {
  readonly name: string;
  age?: number;
  sayHi(): void;
  sayHi(a: number): void;
  sayHi(a: number, b: number): void;
}
```

## 하이브리드 타입

- 인터페이스 또한 함수이자 일반 객체인 하이브리드 타입을 정의할 수 있습니다.

```ts
interface Func2 {
  (a: number): string;
  b: boolean;
}

const func: Func2 = (a) => "hello";
func.b = true;
```

## 주의할 점 1

- 인터페이스는 대부분의 상황에 타입 별칭과 동일하게 동작하지만 몇가지 차이점이 존재합니다.
- 타입 별칭에서는 Union이나 Intersection 타입을 정의할 수 있었던 반면 인터페이스에서는 할 수 없습니다.
- 따라서 인터페이스로 만든 타입을 Union 또는 Intersection으로 이용해야 한다면 타입 별칭과 함께 사용하거나 타입 주석에서 직접 사용해야 합니다.

```ts
type Type1 = number | string;
type Type2 = number & string;

interface Person {
  name: string;
  age: number;
} | number // ❌
```

```ts
type Type1 = number | string | Person;
type Type2 = number & string & Person;

const person: Person & string = {
  name: "이정환",
  age: 27,
};
```

## 인터페이스 확장(=상속)

- 하나의 인터페이스를 다른 인터페이스들이 상속받아 중복된 프로퍼티를 정의하지 않도록 도와주는 문법
- 확장 대상 타입인 Animal은 Dog 타입의 슈퍼타입이 됩니다.

```ts
interface Animal {
  name: string;
  color: string;
}

interface Dog extends Animal {
  breed: string;
}

interface Cat extends Animal {
  isScratch: boolean;
}

interface Chicken extends Animal {
  isFly: boolean;
}

const dog: Dog = {
  name: "돌돌이",
  color: "brown",
  breed: "진도",
};
```

### 프로퍼티 재정의하기

- 확장과 동시에 프로퍼티의 타입을 재정의 하는 것 또한 가능합니다.
- 한가지 주의할 점은 원본 타입을 A, 재정의된 타입을 B라고 하면 반드시 A가 B의 슈퍼 타입이 되도록 재정의 해야 합니다. Dog 타입이 Animal 타입을 확장한 다는 것은 Animal 타입의 서브타입이 된다는 의미이기 때문입니다.

```ts
interface Animal {
  name: string;
  color: string;
}

interface Dog extends Animal {
  name: "doldol"; // 타입 재 정의 string literal
  breed: string;
}

interface Cat extends Animal {
  name: number; // 오류.
  breed: string;
}
```

### 타입 별칭 확장하기

- 인터페이스는 인터페이스 뿐만 아니라 타입 별칭으로 정의된 객체도 확장할 수 있습니다.

```ts
type Animal = {
  name: string;
  color: string;
};

interface Dog extends Animal {
  breed: string;
}
```

### 다중 확장

- 여러개의 인터페이스를 확장하는 것 또한 가능합니다.

```ts
interface Animal {
  name: string;
  color: string;
}

interface Mammal {
  hasBaby: boolean;
}

interface Dog extends Animal, Mammal {
  breed: string;
}

const dog: Dog = {
  name: "돌돌이",
  color: "brown",
  hasBaby: true,
  breed: "진도",
};
```

## 선언 합침(Declaration Merging)

- 동일한 이름의 인터페이스들이 합쳐지는 것
- 타입 별칭은 동일한 스코프 내에 중복된 이름으로 선언할 수 없지만 인터페이스는 가능합니다.
  <br/>중복된 이름의 인터페이스 선언은 결국 모두 하나로 합쳐지기 때문입니다.

```ts
type Person1 = {
  name: string;
};

type Person1 = {
  // ❌
  age: number;
};

interface Person2 {
  name: string;
}

interface Person2 {
  // ✅
  age: number;
}

//  Person2 인터페이스들을 결국 합쳐져 다음과 같은 인터페이스가 됩니다.
interface Person2 {
  name: string;
  age: number;
}

const person: Person = {
  name: "이정환",
  age: 27,
};
```

- 단, 동일한 이름의 인터페이스들이 동일한 이름의 프로퍼티를 서로 다른 타입으로 정의한다면 오류가 발생합니다.  
  <br/>동일한 프로퍼티의 타입을 다르게 정의한 상황을 ‘충돌’ 이라고 표현하며 선언 합침에서 이런 충돌은 허용되지 않습니다.
- 인터페이스를 확장할때는 동일한 이름의 프로퍼티 타입을 재정의 할 수 있었다. (단, 서브타입일때)
- 그러나 선언 합침에서는 동일한 이름의 프로퍼티 타입을 재정의 할 수 없습니다. (서브타입이어도 안됨)

```ts
interface Person {
  name: string;
}
interface Person {
  name: "hello"; // ❌ 충돌 발생 -> string이거나 name을 제거하거나.
  age: number;
}
```

- 보통 타입스크립트의 모듈(라이브러리) 타입 정의가 좀 부실할 때 우리가 타입을 좀 추가하는 등 모듈 보강할때 사용
  - 보통의 라이브러리들은 타입 정의가 끝나있기 때문에 우리가 임의대로 타입을 추가할 수 없지만 인터페이스 선언 합침을 이용하면 가능

```ts
// some-library/index.d.ts
export interface LibraryOptions {
  debug: boolean;
}

const lib: LibraryOptions = {
  debug: true,
  logging: string, // ❌ 오류 발생: 'logging' 속성은 'LibraryOptions'에 존재하지 않습니다.
};

// my-code.ts
import { LibraryOptions } from "some-library";
declare module "some-library" {
  interface LibraryOptions {
    logging: string; // 'logging' 속성 추가
  }
}
```
