# 타입 조작

- 기본 타입이나 별칭 또는 인터페이스로 만든 원래 존재하던 타입들을
  <br/>상황에 따라 유동적으로 다른 타입으로 변환하는 타입스크립트의 독특한 기능
- 제네릭도 함수나 인터페이스, 타입 별칭, 클래스 등에 적용해서 상황에 따라 달라지는 가변적인 타입을 정의할 수 있기 때문에 타입을 조작하는 기능에 포함됩니다.
- 타입스크립트에서는 제네릭 이외에도 다양한 타입 조작 기능을 제공합니다.

![타입 조작](./assets/type-manipulation.png)

## 인덱스드 액세스 타입 (Indexed Access Types)

- 객체, 배열, 튜플 타입에서 특정 프로퍼티나 특정 요소의 타입만 추출하는 타입
- 인덱스를 이용해 다른 타입내의 특정 프로퍼티의 타입을 추출하는 타입
- 객체, 배열, 튜플에 사용

### 객체 프로퍼티 타입 추출하기

```typescript
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
  };
}

const post: Post = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "이정환",
  },
};

function printAuthorInfo(author: { id: number; name: string }) {
  console.log(`${author.id} - ${author.name}`);
}
```

- 매개변수의 타입을 위처럼 정의하면 나중에 Post 타입의 author 프로퍼티의 타입이 수정되면 매개변수의 타입도 그때 마다 계속 수정해줘야 하는 불편함이 존재합니다.

```ts
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number; // 추가
  };
}

function printAuthorInfo(author: { id: number; name: string, age: number }) {
	// age 프로퍼티도 추가
  console.log(`${author.id} - ${author.name}`);
}

(...)

```

- 이럴 때는 인덱스드 엑세스 타입을 이용해 Post에서 author 프로퍼티의 타입을 추출해 사용하면 편리합니다.
- `Post["author"]`는 Post 타입으로부터 author 프로퍼티 타입을 추출합니다.
  <br/>그 결과 author 매개변수의 타입은 `{id : number, name: string, age:number}`가 됩니다.
- 이때 대괄호 속에 들어가는 String Literal 타입인 “author” 를 인덱스 라고 부릅니다.
  <br/>그래서 인덱스를 이용해 특정 타입에 접근하다고 하여 인덱스드 엑세스 타입이라 부릅니다.
- 인덱스를 중첩하여 사용할 수도 있습니다.

```ts
interface Post {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number;
  };
}

function printAuthorInfo1(author: Post["author"]) {
  console.log(`${author.id} - ${author.name}`);
}

function printAuthorInfo2(authorId: Post["author"]["id"]) {
  console.log(authorId);
}
```

- 주의할 점
  - 인덱스에는 값이 아니라 타입만 들어갈 수 있습니다.
    <br/>따라서 “author”를 문자열 값으로 다른 변수에 저장하고 인덱스로 사용하려고 하면 오류가 발생합니다.
  - 인덱스에 존재하지 않는 프로퍼티 이름을 쓰면 오류가 발생합니다.

```ts
const authorKey = "author";

function printAuthorInfo1(author: Post[authorKey]) {
  // ❌
  console.log(`${author.id} - ${author.name}`);
}

function printAuthorInfo2(author: Post["what"]) {
  // ❌
  console.log(`${author.id} - ${author.name}`);
}
```

### 배열 요소 타입 추출하기

- 인덱스드 엑세스 타입을 이용해 PostList 배열 타입에서 하나의 요소의 타입만 뽑아올 수 있습니다.
- `PostList[number]`는 PostList 배열 타입으로부터 요소의 타입을 추출하는 인덱스드 엑세스 타입입니다.
  <br/> 배열의 요소 타입을 추출할 때에는 인덱스에 number 타입을 넣어주면 됩니다.
- 인덱스에 Number Literal 타입을 넣어도 됩니다. 숫자와 관계없이 모두 Number 타입을 넣은 것과 동일하게 동작합니다.

```typescript
// PostList 배열 타입 정의
type PostList = {
  title: string;
  content: string;
  author: {
    id: number;
    name: string;
    age: number;
  };
}[];

// PostList[number] 인덱스드 엑세스 타입 정의
const post: PostList[number] = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "이정환",
    age: 27,
  },
};

// PostList[0] 인덱스드 엑세스 타입 정의. PostList[number] 와 동일
const post: PostList[0] = {
  title: "게시글 제목",
  content: "게시글 본문",
  author: {
    id: 1,
    name: "이정환",
    age: 27,
  },
};
```

### 튜플 요소 타입 추출하기

- 튜플의 각 요소들의 타입 또한 인덱스드 엑세스 타입으로 쉽게 추출할 수 있습니다.
- 한가지 주의할 점은 인덱스에 number 타입을 넣으면 마치 튜플을 배열 처럼 인식해 배열 요소의 타입을 추출하게 됩니다.

```typescript
type Tup = [number, string, boolean];

type Tup0 = Tup[0]; // number

type Tup1 = Tup[1]; // string

type Tup2 = Tup[2]; // boolean

type Tup3 = Tup[number]; // number | string | boolean
```

## keyof & typeof 연산자 (Keyof Types)

- keyof 연산자: 특정 객체 타입으로부터 프로퍼티의 모든 키들을 스트링 리터럴 유니온 타입으로 추출하는 연산자
- `keyof 타입` 형태로 사용. 타입의 모든 key를 String Literal Union 타입으로 추출
- keyof Person의 결과값은 “name” | “age” | “location”
- 주의할 점은 keyof 연산자는 오직 타입에만 적용할 수 있는 연산자 라는 점 입니다. 따라서 값과 함께 사용하려고 하면 오류가 발생합니다.

```ts
interface Person {
  name: string;
  age: number;
  location: string; // 추가
}

// 새로운 프로퍼티가 추가되거나 수정될 때 마다 키 타입도 계속 바꿔야 합니다.
function getPropertyKey1(person: Person, key: "name" | "age") {
  return person[key];
}

// Keyof 연산자
function getPropertyKey2(person: Person, key: keyof Person) {
  return person[key];
}

// 값(person)과 함께 사용 하면 오류
function getPropertyKey(person: Person, key: keyof person) {
  // ❌
  return person[key];
}

const person: Person = {
  name: "이정환",
  age: 27,
};
```

### Typeof와 Keyof 함께 사용하기

- typeof 연산자: 자바스크립트에서 특정 값의 타입을 문자열로 반환하는 연산자.
  <br/>타입을 정의할 때 사용하면 특정 변수의 타입을 추론하는 기능도 가지고 있습니다.

```ts
type Person = typeof person;
// {name: string, age: number, location:string}
```

```ts
(...)

function getPropertyKey(person: Person, key: keyof typeof person) {
  return person[key];
}

const person: Person = {
  name: "이정환",
  age: 27,
};

```

## 맵드 타입 (Mapped Types)

- 기존의 객체 타입을 기반으로 새로운 객체 타입을 만드는 타입
- interface에서는 사용할 수 없고 타입 별칭으로 사용

```ts
interface User {
  id: number;
  name: string;
  age: number;
}

function fetchUser(): User {
  return {
    id: 1,
    name: "이정환",
    age: 27,
  };
}

function updateUser(user: User) {
  // ... 유저 정보 수정 기능
}

updateUser({
  // ❌
  age: 25,
});
```

- updateUser 함수의 매개변수 타입 User -> 수정하고 싶은 프로퍼티만 골라서 보낼 수 없는 상황
- 따라서 어쩔 수 없이 새로운 타입을 만들어 주어야 합니다.

```ts
interface User {
  id: number;
  name: string;
  age: number;
}

type PartialUser = {
  id?: number;
  name?: string;
  age?: number;
}

(...)

function updateUser(user: PartialUser) {
  // ... 유저 정보 수정 기능
}

updateUser({ // ✅
  age: 25
});
```

- 중복은 언제나 좋지 않습니다. 따라서 이럴 때 바로 맵드 타입을 이용하면 좋습니다.

```ts
interface User {
  id: number;
  name: string;
  age: number;
}

type PartialUser = {
  [key in "id" | "name" | "age"]?: User[key];
};

type BooleanUser = {
  [key in "id" | "name" | "age"]: boolean;
}

(...)
```

- `[key in “id” | “name” | “age”]`
- 3개의 프로퍼티를 갖는 객체 타입으로 정의됩니다.
  - key가 “id” 일 때 → `id : User[id]` → `id : number`
  - key가 “name”일 때 → `name : User[user]` → `name : string`
  - key가 “age”일 때 → `age : User[age]` → `age : number`
- 결론적으로 이 타입은 모든 프로퍼티가 옵셔널인 타입과 같은 타입이 됩니다.

```ts
{
  id?: number;
  name?: string;
  age?: number;
}
```

- keyof 연산자를 이용해 한번 더 업그레이드

```ts
interface User {
  id: number;
  name: string;
  age: number;
}

type PartialUser = {
  [key in keyof User]?: User[key];
};

// 모든 프로퍼티가 읽기 전용 프로퍼티가 된 타입
type ReadonlyUser = {
  readonly [key in keyof User]: User[key];
};
```

## 탬플릿 리터럴 타입 (Template Literal Types)

- 템플릿 리터럴을 이용해 특정 패턴을 갖는 String 타입을 만드는 기능
- 기존의 스트링 리터럴 타입을 기반으로 정해진 패턴의 문자열만 포함하는 타입

```ts
type Color = "red" | "black" | "green";
type Animal = "dog" | "cat" | "chicken";

// Color와 Animal을 조합해 만들 수 있는 모든 가지수의 String Literal 타입으로 이루어진 Union 타입
type ColoredAnimal = `red-dog` | 'red-cat' | 'red-chicken' | 'black-dog' ... ;
```

- 경우의 수가 많아질 수록 ColoredAnimal 타입에 추가해야하는 타입이 점점 많아지게 됩니다.
  <br/>이럴 때 템플릿 리터럴 타입을 이용하면 좋습니다.

```ts
type ColoredAnimal = `${Color}-${Animal}`;
```
