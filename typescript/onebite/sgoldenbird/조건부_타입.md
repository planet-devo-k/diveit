# 조건부 타입

- extends와 삼항 연산자를 이용해 조건에 따라 각각 다른 타입을 정의하도록 돕는 문법

```ts
// 조건식 number extends string은 number 타입이 string 타입의 서브타입이 아니기 때문에 거짓
// 그 결과 타입 A는 string 타입이 됩니다.
type A = number extends string ? number : string;
```

```ts
type ObjA = {
  a: number;
};

type ObjB = {
  a: number;
  b: number;
};

// ObjB는 ObjA의 서브 타입 이므로 조건식이 참이되어 number 타입이 됩니다.
type B = ObjB extends ObjA ? number : string;
```

## 제네릭 조건부 타입

- 조건부 타입은 제네릭과 함께 사용할 때 그 위력이 극대화 됩니다.

```ts
// 타입변수T에 Number 타입이 할당되면 String 타입을 반환하고 그렇지 않다면 Number 타입을 반환하는 조건부 타입
type StringNumberSwitch<T> = T extends number ? string : number;

let varA: StringNumberSwitch<number>;
// string

let varB: StringNumberSwitch<string>;
// number
```

```ts
// 매개변수로 String 타입의 값을 제공받아 공백을 제거한 다음 반환하는 함수
function removeSpaces(text: string | undefined | null) {
  return text.replaceAll(" ", ""); // ❌ text가 string이 아닐 수 있어 오류 발생
}

let result = removeSpaces("hi im winterlood");
```

```ts
function removeSpaces(text: string | undefined | null) {
  // 이런 경우 다음과 같이 타입을 좁혀 사용해야 합니다.
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood");
// string | undefined
// 변수 result의 타입이 아까와는 달리 string | undefined 타입으로 추론됩니다.
```

- 조건부 타입을 이용해 인수로 전달된 값의 타입이 String이면 반환값 타입도 String, 아니라면 반환값 타입을 undefined 으로 만듭니다.
- 그런데 이렇게 수정하니 2개의 return문 모두 오류가 발생. 조건부 타입의 결과를 함수 내부에서 알 수 없기 때문입니다.

```ts
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  if (typeof text === "string") {
    return text.replaceAll(" ", ""); // ❌
  } else {
    return undefined; // ❌
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

- 따라서 타입 단언을 이용해 반환값의 타입을 any 타입으로 단언해봅니다.
- 그런데 any로 단언하는것은 별로 좋지 않습니다. 첫번째 return 문에서 string이 아닌 타입의 값을 반환 해도 오류를 감지하지 못합니다.

```ts
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  if (typeof text === "string") {
    return 0 as any; // 문제 감지 못함
  } else {
    return undefined as any;
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

- 따라서 이럴 때에는 타입 단언보다는 함수 오버로딩을 이용하는게 더 좋습니다.
- 오버로딩에서는 string인지 여부가 타입 선언부(오버로드 시그니처)에서 호출 시점에 결정되고 끝.
  <br/>구현부에서는 더 이상 타입을 결정하지 않는다.

```ts
// 오버로드 시그니처 → 타입 시스템
function removeSpaces<T>(text: T): T extends string ? string : undefined;

// 구현 시그니처 → 실제 JS 실행
// 이 시점에서 이미 반환 타입이 string인지 undefined인지 확정
function removeSpaces(text: any) {
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

## 분산적인 조건부 타입

- number | string은 number의 서브타입이 아니므로 조건식이 거짓이 되어 변수 c의 타입이 number가 될거라고 예상할 수 있습니다.
  그러나 변수 c는 string | number 타입으로 정의됩니다.
- 조건부 타입의 타입 변수에 Union 타입을 할당하면 분산적인 조건부 타입으로 업그레이드 되기 때문입니다.

```ts
type StringNumberSwitch<T> = T extends number ? string : number;

(...)

let c: StringNumberSwitch<number | string>;
// string | number
```

- 분산적인 조건부 타입은 다음과 같이 동작합니다.
  - 타입 변수에 할당한 Union 타입 내부의 모든 타입이 분리됩니다.
    <br/>따라서 `StringNumberSwitch<number | string>` 타입은 다음과 같이 분산됩니다.
    - StringNumberSwitch<number>
    - StringNumberSwitch<string>
  - 그리고 분산된 각 타입의 결과를 모아 다시 Union 타입으로 묶습니다. 결과 : string | number

### Exclude 조건부 타입 구현하기

- 분산적인 조건부 타입의 특징을 이용하면 매우 다양한 타입을 정의할 수 있습니다.
- 예를 들어 Union 타입으로부터 특정 타입만 제거하는 Exclude 타입을 다음과 같이 정의할 수 있습니다.

```ts
type Exclude<T, U> = T extends U ? never : T;

type A = Exclude<number | string | boolean, string>;
```

위 코드는 다음의 흐름으로 동작합니다.

1. Union 타입이 분리된다.

- Exclude<number, string>
- Exclude<string, string>
- Exclude<boolean, string>

2. 각 분리된 타입을 모두 계산한다.

- T = number, U = string 일 때 number extends string 은 거짓이므로 결과는 number
- T = string, U = string 일 때 string extends string 은 참이므로 결과는 never
- T = boolean, U = string 일 때 boolean extends string 은 거짓이므로 결과는 boolean

3. 계산된 타입들을 모두 Union으로 묶는다

- 결과 : number | never | boolean

계산 결과 타입 A는 number | never | boolean 타입으로 정의됩니다.
<br/>그런데 여기서 공집합을 의미하는 never 타입은 Union으로 묶일 경우 사라집니다.
<br/>공집합과 어떤 집합의 합집합은 그냥 원본 집합이 되기 때문입니다.
<br/>따라서 최종적으로 타입 A는 number | boolean 타입이 됩니다.

## infer

- 조건부 타입 내에서 특정 타입을 추론하는 문법
- 특정 함수 타입에서 반환값의 타입만 추출하는 특수한 조건부 타입인 ReturnType을 만들 때 이용할 수 있습니다.

```ts
type ReturnType<T> = T extends () => infer R ? R : never;

type FuncA = () => string;

type FuncB = () => number;

type A = ReturnType<FuncA>;
// string

type B = ReturnType<FuncB>;
// number
```

- 조건식 `T extends () => infer R`에서 `infer R`은 이 조건식을 참으로 만들 수 있는 최적의 R 타입을 추론하라는 의미.

- 따라서 A 타입을 계산할 때의 위 코드의 흐름은 다음과 같습니다.

1. 타입 변수 T에 함수 타입 FuncA가 할당됩니다.
2. T는 `() ⇒ string`이 됩니다.
3. 조건부 타입의 조건식은 다음 형태가 됩니다. `() ⇒ string extends () ⇒ infer R ? R : never`
4. 조건식을 참으로 만드는 R 타입을 추론 합니다 그 결과 R은 string이 됩니다.
5. 추론이 가능하면 이 조건식을 참으로 판단합니다 따라서 결과는 string이 됩니다.

- 만약 다음과 같이 추론이 불가능하다면 조건식을 거짓으로 판단합니다.

```ts
type ReturnType<T> = T extends () => infer R ? R : never;

type FuncA = () => string;

type FuncB = () => number;

type A = ReturnType<FuncA>;
// string

type B = ReturnType<FuncB>;
// number

type C = ReturnType<number>;
// 조건식을 만족하는 R추론 불가능
// never
```

- 다음은 Promise의 resolve 타입을 infer를 이용해 추출하는 예 입니다.

```ts
type PromiseUnpack<T> = T extends Promise<infer R> ? R : never;
// 1. T는 프로미스 타입이어야 한다.
// 2. 프로미스 타입의 결과값 타입을 반환해야 한다.

type PromiseA = PromiseUnpack<Promise<number>>;
// number

type PromiseB = PromiseUnpack<Promise<string>>;
// string
```
