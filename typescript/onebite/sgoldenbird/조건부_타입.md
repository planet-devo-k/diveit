---
icon: memo-pad
---

# 조건부 타입

* extends와 삼항 연산자를 이용해 조건에 따라 각각 다른 타입을 정의하도록 돕는 문법

```ts
// 조건식 number extends string은 number 타입이 string 타입의 서브타입이 아니기 때문에 거짓
// 그 결과 타입 A는 string 타입이 됩니다.
type A = number extends string ? number : string;
```

```ts
type ObjA = {
  a: number;
};

type ObjB = {
  a: number;
  b: number;
};

// ObjB는 ObjA의 서브 타입 이므로 조건식이 참이되어 number 타입이 됩니다.
type B = ObjB extends ObjA ? number : string;
```

## 제네릭 조건부 타입

* 조건부 타입은 제네릭과 함께 사용할 때 그 위력이 극대화 됩니다.

```ts
// 타입변수T에 Number 타입이 할당되면 String 타입을 반환하고 그렇지 않다면 Number 타입을 반환하는 조건부 타입
type StringNumberSwitch<T> = T extends number ? string : number;

let varA: StringNumberSwitch<number>;
// string

let varB: StringNumberSwitch<string>;
// number
```

```ts
// 매개변수로 String 타입의 값을 제공받아 공백을 제거한 다음 반환하는 함수
function removeSpaces(text: string | undefined | null) {
  return text.replaceAll(" ", ""); // ❌ text가 string이 아닐 수 있어 오류 발생
}

let result = removeSpaces("hi im winterlood");
```

```ts
function removeSpaces(text: string | undefined | null) {
  // 이런 경우 다음과 같이 타입을 좁혀 사용해야 합니다.
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood");
// string | undefined
// 변수 result의 타입이 아까와는 달리 string | undefined 타입으로 추론됩니다.
```

* 조건부 타입을 이용해 인수로 전달된 값의 타입이 String이면 반환값 타입도 String, 아니라면 반환값 타입을 undefined 으로 만듭니다.
* 그런데 이렇게 수정하니 2개의 return문 모두 오류가 발생. 조건부 타입의 결과를 함수 내부에서 알 수 없기 때문입니다.

```ts
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  if (typeof text === "string") {
    return text.replaceAll(" ", ""); // ❌
  } else {
    return undefined; // ❌
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

* 따라서 타입 단언을 이용해 반환값의 타입을 any 타입으로 단언해봅니다.
* 그런데 any로 단언하는것은 별로 좋지 않습니다. 첫번째 return 문에서 string이 아닌 타입의 값을 반환 해도 오류를 감지하지 못합니다.

```ts
function removeSpaces<T>(text: T): T extends string ? string : undefined {
  if (typeof text === "string") {
    return 0 as any; // 문제있지만 감지 못함
  } else {
    return undefined as any;
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

* 따라서 이럴 때에는 타입 단언보다는 함수 오버로딩을 이용하는게 더 좋습니다.
* 오버로딩에서는 string인지 여부가 타입 선언부(오버로드 시그니처)에서 호출 시점에 결정되고 끝.\
  구현부에서는 더 이상 타입을 결정하지 않는다.

```ts
// 오버로드 시그니처 → 타입 시스템
function removeSpaces<T>(text: T): T extends string ? string : undefined;

// 구현 시그니처 → 실제 JS 실행
// 이 시점에서 이미 반환 타입이 string인지 undefined인지 확정
function removeSpaces(text: any) {
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  } else {
    return undefined;
  }
}

let result = removeSpaces("hi im winterlood");
// string

let result2 = removeSpaces(undefined);
// undefined
```

* 위 예시는 사실 엄밀히 말하면 오버로딩은 아니다. 위 예시는 제네릭+조건부타입 이고 \
  오버로딩은 매개변수의 케이스 별로 선언부를 직접 여러번 작성해야한다.&#x20;

```typescript
// 오버로드 시그니처 (선언부)
function removeSpaces(text: string): string;
function removeSpaces(text: undefined): undefined;

// 구현 시그니처 (실제 로직)
function removeSpaces(text: any) {
  if (typeof text === "string") {
    return text.replaceAll(" ", "");
  }
  return undefined;
}
```

#### 오버라이딩 vs 오버로드&#x20;

오버라이딩(Overriding)은 반드시 상속 관계가 있어야 합니다.

* 부모 클래스에 이미 정의된 메서드를 자식 클래스가 가져와서 내용을 완전히 바꾸는(덮어쓰는) 행위입니다.
* 작성하신 코드는 상속 구조 없이 하나의 함수가 여러 타입을 처리하려고 하므로 오버라이딩과는 관련이 없습니다.

오버로드의 핵심은 함수 이름은 하나인데, 매개변수의 타입에 따라 결과(반환 타입이나 로직)가 달라지는 것입니다.

* 사용자가 `removeSpaces("문자열")`을 넣으면 `string`이 나오고, `removeSpaces(undefined)`를 넣으면 `undefined`가 나옵니다.
* 이처럼 하나의 이름으로 다양한 타입 케이스를 대응하는 모습이 오버로드의 목적과 일치합니다.

<table data-header-hidden><thead><tr><th width="102.5999755859375"></th><th></th><th></th></tr></thead><tbody><tr><td><strong>구분</strong></td><td><strong>오버로드 (Overload)</strong></td><td><strong>오버라이딩 (Override)</strong></td></tr><tr><td>핵심 개념</td><td>이름은 같지만 매개변수가 다른 함수들을 여러 개 만드는 것</td><td>부모의 함수를 자식이 가져와서 내용을 완전히 바꾸는 것</td></tr><tr><td>필수 조건</td><td>매개변수(타입, 개수)가 달라야 함</td><td>상속 관계가 반드시 있어야 함</td></tr><tr><td>발생 범위</td><td>클래스 내부, 일반 함수, 전역 공간 등 어디서나 가능</td><td>클래스 상속이나 인터페이스 구현 시에만 발생</td></tr><tr><td>함수 모양</td><td>이름만 같고 나머지는 다를 수 있음</td><td>이름, 매개변수, 반환 타입이 모두 같아야 함</td></tr><tr><td>작동 원리</td><td>입력값에 맞는 함수를 찾아가는 과정</td><td>물려받은 기능을 새로운 기능으로 덮어씌우는 과정</td></tr></tbody></table>

## 분산적인 조건부 타입

* number | string은 number의 서브타입이 아니므로 조건식이 거짓이 되어 변수 c의 타입이 number가 될거라고 예상할 수 있습니다. 그러나 변수 c는 string | number 타입으로 정의됩니다.
* 조건부 타입의 타입 변수에 Union 타입을 할당하면 분산적인 조건부 타입으로 업그레이드 되기 때문입니다.

```ts
type StringNumberSwitch<T> = T extends number ? string : number;

// 만약 분산적인 조건부 타입이 되는걸 막고싶다면 아래처럼 분산을 방지 한다.
// type StringNumberSwitch<T> = [T] extends [number] ? string : number;

(...)

let c: StringNumberSwitch<number | string>;
// string | number
```

* 분산적인 조건부 타입은 다음과 같이 동작합니다.
  * 타입 변수에 할당한 Union 타입 내부의 모든 타입이 분리됩니다.\
    따라서 `StringNumberSwitch<number | string>` 타입은 다음과 같이 분산됩니다.
    * StringNumberSwitch\<number>
    * StringNumberSwitch\<string>
  * 그리고 분산된 각 타입의 결과를 모아 다시 Union 타입으로 묶습니다. 결과 : string | number
* 제네릭 $$T$$를 대괄호로 감싸서 `[T]`로 만들면, 타입스크립트는 이를 더 이상 분산 가능한 상태(Naked Type)가 아니라고 판단합니다. 즉, 유니온 타입을 하나의 덩어리로 묶어서 검사하게 됩니다.
  * 분산 방지 (`[T]`): 유니온 전체(`number | string`)를 하나의 배열 타입인 `[number | string]`으로 간주하고 단 한 번만 조건을 검사합니다.

### Exclude 조건부 타입 구현하기

* 분산적인 조건부 타입의 특징을 이용하면 매우 다양한 타입을 정의할 수 있습니다.
* 예를 들어 Union 타입으로부터 특정 타입만 제거하는 Exclude 타입을 다음과 같이 정의할 수 있습니다.

```ts
type Exclude<T, U> = T extends U ? never : T;

type A = Exclude<number | string | boolean, string>;
```

위 코드는 다음의 흐름으로 동작합니다.

1. Union 타입이 분리된다.

* Exclude\<number, string>
* Exclude\<string, string>
* Exclude\<boolean, string>

2. 각 분리된 타입을 모두 계산한다.

* T = number, U = string 일 때 number extends string 은 거짓이므로 결과는 number
* T = string, U = string 일 때 string extends string 은 참이므로 결과는 never
* T = boolean, U = string 일 때 boolean extends string 은 거짓이므로 결과는 boolean

3. 계산된 타입들을 모두 Union으로 묶는다

* 결과 : number | never | boolean

계산 결과 타입 A는 number | never | boolean 타입으로 정의됩니다.\
그런데 여기서 공집합을 의미하는 never 타입은 Union으로 묶일 경우 사라집니다.\
공집합과 어떤 집합의 합집합은 그냥 원본 집합이 되기 때문입니다.\
따라서 최종적으로 타입 A는 number | boolean 타입이 됩니다.

* 분산적인 조건부 타입을 이용해서 union 타입 중 특정 타입만 제거하는 것이 가능
  * 위 예시 string타입 제거
* 아래 예시는 union 타입 중 특정 타입만 뽑아내는 것

```ts
type Extract<T, U> = T extends U ? T : never;

type B = Extract<number | string | boolean, string>;
```

## infer

* **조건부 타입 내에서** 특정 타입을 추론하는 문법
* 특정 함수 타입에서 반환값의 타입만 추출하는 특수한 조건부 타입인 ReturnType을 만들 때 이용할 수 있습니다.

```ts
type ReturnType<T> = T extends () => infer R ? R : never;

type FuncA = () => string;

type FuncB = () => number;

type A = ReturnType<FuncA>;
// string

type B = ReturnType<FuncB>;
// number
```

* 조건식 `T extends () => infer R`에서 `infer R`은 이 조건식을 참으로 만들 수 있는 최적의 R 타입을 추론하라는 의미.
* 따라서 A 타입을 계산할 때의 위 코드의 흐름은 다음과 같습니다.

1. 타입 변수 T에 함수 타입 FuncA가 할당됩니다.
2. T는 `() ⇒ string`이 됩니다.
3. 조건부 타입의 조건식은 다음 형태가 됩니다. `() ⇒ string extends () ⇒ infer R ? R : never`
4. 조건식을 참으로 만드는 R 타입을 추론 합니다 그 결과 R은 string이 됩니다.
5. **추론이 가능하면 이 조건식을 참으로 판단**합니다 따라서 결과는 string이 됩니다.\
   만약 다음과 같이 추론이 불가능하다면 조건식을 거짓으로 판단합니다.

```ts
type ReturnType<T> = T extends () => infer R ? R : never;

type FuncA = () => string;

type FuncB = () => number;

type A = ReturnType<FuncA>;
// string

type B = ReturnType<FuncB>;
// number

type C = ReturnType<number>;
// 조건식을 만족하는 R추론 불가능
// never
```

* 다음은 Promise의 resolve 타입을 infer를 이용해 추출하는 예 입니다.
* `Promise<number>`는 미래에 `number` 타입의 값을 돌려주겠다고 약속된 Promise 객체
  * `Promise<number>`에서 `<number>` 자리는 해당 비동기 작업이 성공(resolve)했을 때 돌려줄 리턴값의 타입을 정의하는 공간

```ts
type PromiseUnpack<T> = T extends Promise<infer R> ? R : never;
// 1. T는 프로미스 타입이어야 한다.
// 2. 프로미스 타입의 결과값 타입을 반환해야 한다.

type PromiseA = PromiseUnpack<Promise<number>>;
// number

type PromiseB = PromiseUnpack<Promise<string>>;
// string
```

```typescript
async function getData(): Promise<string> {
  return "완료"; // 리턴하는 값의 타입이 string
}

const result = await getData(); 
```
