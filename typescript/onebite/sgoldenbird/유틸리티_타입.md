---
icon: memo-pad
---

# 유틸리티 타입

* 타입스크립트가 자체적으로 제공하는 특수한 타입들
* 제네릭, 맵드 타입, 조건부 타입 등의 타입 조작 기능을 이용해 실무에서 자주 사용되는 유용한 타입들을 모아 놓은 것
* 타입스크립트는 굉장히 다양한 유틸리티 타입을 제공합니다.
  * [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
* 대표적인 유틸리티 타입
  * Partial: T 타입의 모든 속성을 선택적으로 만듦
  * Readonly: T 타입의 모든 속성을 읽기 전용으로 만듦
  * Record\<K, T>: K 타입의 키와 T 타입의 값을 가지는 **객체 타입**을 만듦
  * Pick\<T, K>: T 타입에서 K에 해당하는 속성들만 선택하여 새로운 타입을 만듦
  * Omit\<T, K>: T 타입에서 K에 해당하는 속성들을 제외한 새로운 타입을 만듦
  * Exclude\<T, U>: T 타입에서 U에 할당 가능한 타입을 제외한 새로운 타입을 만듦
  * Extract\<T, U>: T 타입에서 U에 할당 가능한 타입만 추출한 새로운 타입을 만듦
  * NonNullable: T 타입에서 null과 undefined를 제외한 새로운 타입을 만듦
  * ReturnType: 함수 타입 T의 반환 타입을 추출함
  * Parameters: 함수 타입 T의 매개변수 타입들을 튜플 형태로 추출함

```ts
interface Person {
  name: string;
  age: number;
}

// Readonly<T>와 같은 유틸리티 타입을 이용해
// 특정 객체 타입의 모든 프로퍼티를 읽기 전용 프로퍼티로 변환할 수 있습니다.
const person1: Readonly<Person> = {
  name: "이정환",
  age: 27,
};

// Partial<T> 유틸리티 타입을 이용해 특정 객체 타입의 모든 프로퍼티를 선택적 프로퍼티로 변환
const person2: Partial<Person> = {
  name: "이정환",
};

person1.name = ""; // ❌ 오류 -> name은 Readonly 프로퍼티입니다.
```

![utility type](../.gitbook/assets/utility-type.png)

## 맵드 타입 기반 유틸리티 타입

### Partial

* 특정 객체 타입의 모든 프로퍼티를 옵셔널 프로퍼티로 변환합니다.\
  따라서 기존 객체 타입에 정의된 프로퍼티들 중 일부분만 사용할 수 있도록 도와주는 타입입니다.

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

// 임시저장 기능
const draft: Post = {
  // ❌ tags 프로퍼티가 없음
  title: "제목은 나중에 짓자...",
  content: "초안...",
};
```

* 게시글의 일부 정보가 아직 설정되어 있지 않은 임시 저장 게시글의 경우에도 변수에 저장할 수 있어야 하는데 해당 변수를 Post 타입으로 정의하면 오류가 발생
* 그렇다고 임시 저장 게시글 기능을 위해 Post 타입의 모든 프로퍼티를 선택적 프로퍼티로 설정하는 것도 곤란합니다. 진짜 작성이 완료되어 화면에 렌더링 될 게시글들은 이 모든 프로퍼티를 진짜 다 가지고 있어야 하기 때문입니다.
* `Partial<T>` 타입은 타입 변수 T로 전달한 객체 타입의 모든 프로퍼티를 다 선택적 프로퍼티로 변환합니다.

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

// Partial<Post> 타입은 모든 프로퍼티가 선택적 프로퍼티가 된 Post 타입
const draft: Partial<Post> = {
  title: "제목 나중에 짓자",
  content: "초안...",
};
```

* 기존 객체 타입을 다른 타입으로 변환하는 타입은 맵드 타입이었습니다.
* T에 할당된 객체 타입의 모든 프로퍼티를 선택적 프로퍼티로 변경

```ts
type Partial<T> = {
  [key in keyof T]?: T[key]; // T[key]는 인덱스드 엑세스 타입
};
```

### Required

* 특정 객체 타입의 모든 프로퍼티를 필수 프로퍼티로 변환

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

// 반드시 썸네일 프로퍼티가 존재해야 하는 게시글
const withThumbnailPost: Post = {
  title: "한입 타스 후기",
  tags: ["ts"],
  content: "",
  // thumbnailURL: "https://...",
  // Post 타입의 thumbnailURL 프로퍼티가 현재 선택적 프로퍼티로 설정되어 있기 때문에
  // 실수로 주석 처리하거나 삭제한다고 해도 타입 오류가 발생하지는 않습니다.
};
```

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

// Required<Post>는 Post 타입의 모든 프로퍼티가 필수 프로퍼티로 변환된 객체 타입
const withThumbnailPost: Required<Post> = { // ❌
  title: "한입 타스 후기",
  tags: ["ts"],
  content: "",
  // thumbnailURL: "https://...",
  // thumbnailURL 프로퍼티를 생략하면 이제 오류가 발생
};

```

* 모든 프로퍼티에서 ‘선택적’ 이라는 기능을 제거. -?를 프로퍼티 이름 뒤에 붙여주면 됩니다.
* -? 는 ?가 붙어있는 선택적 프로퍼티가 있으면 ?를 제거하라는 의미입니다.

```ts
type Required<T> = {
  [key in keyof T]-?: T[key];
};
```

### Readonly

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)
// 절대 객체 내부를 수정할 수 없는 보호된 게시글이어야 함
const readonlyPost: Post = {
  title: "보호된 게시글입니다.",
  tags: [],
  content: "",
};

readonlyPost.content = '해킹당함';
```

* `Readonly<Post>`는 Post 타입의 모든 프로퍼티를 readonly 프로퍼티로 변환
* 점표기법을 이용해 특정 프로퍼티의 값을 수정하려고 하면 오류를 발생시킵니다.

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

const readonlyPost: Readonly<Post> = {
  title: "보호된 게시글입니다.",
  tags: [],
  content: "",
};

readonlyPost.content = '해킹당함'; // ❌

```

```ts
type Readonly<T> = {
  readonly [key in keyof T]: T[key];
};
```

### Pick\<T, K>

* 특정 객체 타입으로부터 특정 프로퍼티만을 골라내는 타입
* Pick 타입에 T가 name, age가 있는 객체 타입이고 K가 name 이라면 결과는 name만 존재하는 객체 타입이 됩니다.
* legacyPost에 저장되어 있는 게시글은 태그나 썸네일 기능이 추가되기 이전에 만들어진 게시글이라고 가정합니다. 이 변수를 Post 타입으로 설정하면 tags 프로퍼티가 존재하기 때문에 오류가 발생하게 됩니다. 옛날에 작성된 게시글이 몇개나 될 지도 모르기 때문에 일일이 tags를 추가해 줄 수도 없고 그렇다고 옛 게시글들 만을 위한 타입을 별도로 만들어 줄 수도 없는 노릇입니다. 이럴 때 `Pick<T, K>` 유틸리티 타입을 이용해서 Post 타입에서 title과 content 프로퍼티만 골라내면 됩니다.

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

const legacyPost: Post = { // ❌
  title: "",
  content: "",
};
```

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

// Post 타입으로부터 “title”과 “content” 프로퍼티만 뽑아낸 객체 타입
const legacyPost: Pick<Post, "title" | "content"> = {
  title: "",
  content: "",
};
// 추출된 타입 : { title : string; content : string }
```

* T로 부터 K 프로퍼티만 뽑아낸 객체 타입

```ts
// 맵드타입 in 연산자 우측에는 key가 뭐가 있는지 표현하기 위해 string literal로 만든 union타입이 들어온다.
// K가 T의 key로만 이루어진 String Literal Union 타입임을 보장
type Pick<T, K extends keyof T> = {
  // K extends 'title' | 'tags' | 'content' | 'thumbnailURL'
  [key in K]: T[key];
};
```

### Omit\<T, K>

* 특정 객체 타입으로부터 특정 프로퍼티만을 제거하는 타입

```ts
interface Post {
  title: string;
  tags: string[];
  content: string;
  thumbnailURL?: string;
}

(...)

const noTitlePost: Post = { // ❌ 오류
  content: "",
  tags: [],
  thumbnailURL: "",
};
```

```ts
const noTitlePost: Omit<Post, "title"> = {
  content: "",
  tags: [],
  thumbnailURL: "",
};
```

* 일단 T는 Post, K는 ‘title’ 이라고 가정하겠습니다.
* 그럼 이때 keyof T는 ‘title’ | ‘content’ | ‘tags’ | ‘thumbnailURL’이므로\
  `Pick<T, Exclude<keyof T, K>>` 는 `Pick<Post, Exclude<'title' | 'content' | 'tags' | 'thumbnailURL' , 'title>` 이 됩니다.\
  Exclude 타입은 2개의 타입 변수를 할당받는데 T로부터 K를 제거합니다.\
  `Pick<Post, 'content' | 'tags' | 'thumbnailURL'>`

```ts
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
```

### Record\<K, V>

* **객체 타입**을 만들어주는 유틸리티 타입
* 첫번째 타입 변수: 객체 프로퍼티 키를 union으로 받는다.
* 두번째 타입 변수: 키들의 value 타입

```ts
// 화면 크기에 따라 3가지 버전 썸네일 지원
// 프로퍼티를 계속 추가해야 할 수도 있음 -> 중복코드
type Thumbnail = {
  large: {
    url: string;
  };
  medium: {
    url: string;
  };
  small: {
    url: string;
  };
};
```

* K에는 어떤 프로퍼티들이 있을지 String Literal Union 타입을 할당하고 V에는 프로퍼티의 값 타입을 할당합니다.
* large, medium, small 프로퍼티가 있는 객체 타입
* 각 프로퍼티 value의 타입은 V에 할당한 { url : string }

```ts
type Thumbnail = Record<
  "large" | "medium" | "small",
  { url: string; size: number }
>;
```

```ts
// K를 어떤 객체의 key를 추출한 union 타입으로 제한
type Record<K extends keyof any, V> = {
  [key in K]: V;
};
```

## 조건부 타입 기반 유틸리티 타입

### Exclude\<T, K>

* T로부터 U를 제거하는 타입

```ts
type A = Exclude<string | boolean, string>; // boolean
```

```ts
type Exclude<T, U> = T extends U ? never : T;
```

1. T의 각 요소가 U에 속하는지 검사합니다.
2. 속한다면(True) 그 자리를 never로 바꿉니다.
3. 속하지 않는다면(False) 원래 타입 T를 유지합니다.
4. 최종 결과에서 never는 자동적으로 사라집니다.

```ts
type MyTypes = "a" | "b" | "c";
type Result = Exclude<MyTypes, "a">;
```

TypeScript 내부에서는 유니온 타입(MyTypes)을 하나씩 분산해서 검사합니다.

1. 'a' extends 'a' ? -> True이므로 never
2. 'b' extends 'a' ? -> False이므로 'b'
3. 'c' extends 'a' ? -> False이므로 'c'

결과적으로 Result는 never | 'b' | 'c'가 됩니다.

* 왜 never를 사용할까?
  * 유니온 타입에서 never는 공집합과 같은 존재입니다. TypeScript는 유니온 타입을 구성할 때 의미 없는 타입인 never를 제거하고 합치는 특성이 있습니다.
  * 예: string | never는 결국 string이 됩니다.
  * 예: 'b' | 'c' | never는 결국 'b' | 'c'가 됩니다.
  * 즉, 특정 타입을 제외하고 싶을 때 그 자리에 "아무것도 없음"을 뜻하는 never를 배치함으로써 자연스럽게 해당 타입을 목록에서 지워버리는 것입니다.

### Extract\<T, K>

* T로 부터 U를 추출하는 타입

```ts
type B = Extract<string | boolean, boolean>;
// boolean
```

```ts
type Extract<T, U> = T extends U ? T : never;
```

### ReturnType

* 함수 타입 T의 반환 타입을 추출하는 타입 (타입변수 T에 할당된 함수 타입의 반환값 타입을 추출하는 타입)

```ts
type ReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : never;

function funcA() {
  return "hello";
}

function funcB() {
  return 10;
}

type ReturnA = ReturnType<typeof funcA>;
// string

type ReturnB = ReturnType<typeof funcB>;
// number
```

1. `<T extends (...args: any) => any>` 이 부분은 제약 조건입니다. **T는 반드시 함수 형태여야 한다는 뜻**입니다. 함수가 아닌 타입을 넣으면 에러가 발생합니다.
2. `T extends (...args: any) => infer R` 여기서 핵심은 infer R입니다. TypeScript에게 "T가 함수라면, 그 함수의 반환 타입을 추론해서 R이라는 변수에 담아줘"라고 요청하는 것입니다.
3. ? R : never

* 조건이 참이라면(함수가 맞다면): 추론된 타입 R을 반환합니다.
* 조건이 거짓이라면: 절대 발생할 수 없는 타입인 never를 반환합니다.
