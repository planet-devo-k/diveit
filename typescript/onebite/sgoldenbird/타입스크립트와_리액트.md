## js → ts 마이그레이션 과정

- 리액트에서 타입스크립트 쓸 때 아래 4가지 타입 선언 패키지 추가
  - `npm i @types/node @types/react @types/react-dom @types/jest`
- js를 ts로 바꾸는 과정은 파일 하나씩 진행
- tsconfig.json
  - compilerOptions > esModuleInterop
    - default로 내보낸 값이 없는 모듈에서도 default import할때처럼 값을 import할수 있도록 허용해주는 옵션. 보통 true로 하고 개발.
  - compilerOptions > jsx: react-jsx
    - 타입스크립트 컴파일러가 jsx를 해석할 수 있도록
- 정리하면
  1. 타입선언 패키지 설치
  2. tsconfig.json 만들기
  3. js, jsx파일들 하나씩 ts, tsx로

## useState 타입스크립트 환경에서 사용하기

- useState는 초기값으로 state와 setState 타입 자동 추론 → useState는 제네릭 함수다.
- useState 타입변수의 기본값은 undefined로 설정되어 있다. 따라서 초기값을 안넣으면 state타입은 undefined가 된다.
  - 때문에 setState()의 인수로 전달할수 있는 타입이 undefined밖에 없게 된다.
- 때문에 타입스크립트에서 useState에는 초기값을 꼭 넣어야한다.
  - 정 넣을 값이 없으면 타입변수를 설정해야한다. e.g. `useState<string>();`
  - 하지만 타입변수를 설정했을때는 state의 타입이 undefined와 함께 union 타입으로 추론 e.g. 위 예시는 string | undefined

```tsx
interface Todo {
  id: number;
  content: string;
}

export default function App() {
  const [text, setText] = useState("");
  const [todos, setTodos] = useState<Todo[]>([]);

  const idRef = useRef(0);

  const onChangeInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };

  const onClickAdd = () => {
    setTodos([...todos, { id: idRef.current++, content: text }]);
    setText("");
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <input value={text} onChange={onChangeInput} />
      <button onClick={onClickAdd}>추가</button>
    </div>
  );
}
```

- 컴포넌트 분리

```tsx
// App.tsx
export default function App() {
  const [todos, setTodos] = useState<Todo[]>([]);

  const idRef = useRef(0);

  const onClickAdd = (text: string) => {
    setTodos([...todos, { id: idRef.current++, content: text }]);
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <Editor onClickAdd={onClickAdd}>
        <div>child</div>
      </Editor>
    </div>
  );
}

// Editor.tsx
interface Props {
  onClickAdd: (text: string) => void;
  children: ReactElement;
}

export default function Editor(props: Props) {
  const [text, setText] = useState("");

  const onChangeInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    setText(e.target.value);
  };

  const onClickButton = () => {
    props.onClickAdd(text);
    setText("");
  };

  return (
    <div>
      <input value={text} onChange={onChangeInput} />
      <button onClick={onClickButton}>추가</button>
    </div>
  );
}
```

- todo 삭제

```tsx
interface Props extends Todo {
  onClickDelete: (id: number) => void;
}

export default function TodoItem(props: Props) {
  const onClickButton = () => {
    props.onClickDelete(props.id);
  };

  return (
    <div>
      {props.id}번 : {props.content}
      <button onClick={onClickButton}>삭제</button>
    </div>
  );
}
```

## useState → useReducer로 변경해보기

- useReducer 첫번째 인수: Reducer라는 상태 변화를 직접 처리하는 함수
- 두번째 인수: 상태의 초기값
  - dispatch의 인수: action 객체
  - reducer함수 인수: state, action객체

- 타입스크립트에서는 useReducer를 이용할 때 Action객체 타입을 서로소 union 타입으로 정의

```tsx
type Action =
  | {
      type: "CREATE";
      data: {
        id: number;
        content: string;
      };
    }
  | {
      type: "DELETE";
      id: number;
    };

function reducer(state: Todo[], action: Action) {
  switch (action.type) {
    case "CREATE": {
      return [...state, action.data];
    }
    case "DELETE": {
      return state.filter((it) => it.id !== action.id);
    }
  }
}

export default function App() {
  const [todos, dispatch] = useReducer(reducer, []);

  const idRef = useRef(0);

  const onClickAdd = (text: string) => {
    // setTodos([...todos, { id: idRef.current++, content: text }]);

    dispatch({
      type: "CREATE",
      data: {
        id: idRef.current++,
        content: text,
      },
    });
  };

  const onClickDelete = (id: number) => {
    // setTodos(todos.filter((todo) => todo.id !== id));

    dispatch({
      type: "DELETE",
      id: id,
    });
  };

  useEffect(() => {
    console.log(todos);
  }, [todos]);

  return (
    <div className="App">
      <h1>Todo</h1>
      <Editor onClickAdd={onClickAdd}>
        <div>child</div>
      </Editor>
    </div>
  );
}
```

## ContextAPI를 타입스크립트 환경에서 사용하기

```tsx
// createContext는 반드시 인수를 전달해야한다.
export const TodoStateContext = React.createContext<Todo[] | null>(null);
export const TodoDispatchContext = React.createContext<{
  onClickAdd: (text: string) => void;
  onClickDelete: (id: number) => void;
} | null>(null);


...


<TodoStateContext.Provider value={todos}>
  <TodoDispatchContext.Provider
  value={
    {
      onClickAdd,
      onClickDelete
    }
  }>

  ...


```

```tsx
// 커스텀 훅
export default function useTodoDispatch() {
  const dispatch = useContext(TodoDispatchContext);
  if (!dispatch) throw new Error("TodoDispatchContext에 문제가 있다");
  return dispatch;
}
```

## 타입스크립트 환경에서 외부 라이브러리 사용하기

- npm 등 외부 패키지
- 라이브러리 코드들에 대한 타입 정보가 필요함
- TS마크가 붙어있으면 명령어로 install만 하면 됨
  - react-router-dom: 리액트 페이지 이동을 구현하도록 돕는 라이브러리
    - 이 라이브러리는 애초에 타입스크립트 코드로 작성되어서 설치하자마자 바로 사용 가능
- TS마크가 없으면 기본적으로 타입 정보가 제공 안된다.
  - lodash: 자바스크립트의 배열과 객체를 쉽게 사용할수 있도록 돕는 라이브러리
  - DT마크가 붙어있다면 DT 마크 클릭
    - @types/lodash: lodash 라이브러리의 타입 정보를 갖고 있는 패키지도 추가로 install

## 타입스크립트 탬플릿으로 시작하기

- 프로젝트를 타입스크립트 탬플릿으로 시작할 수 있다.
