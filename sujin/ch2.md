# 1. JSX란?

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법. 페이스북에서 독자적으로 개발했으나 ECMAScript(자바스크립트 표준)의 일부는 아님. 다양한 트랜스파일러에서 다양한 속성을 가진 트리구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있음.

## 1. 정의

### JSXElement

JSX를 구성하는 가장 기본적인 요소. HTML의 요소와 비슷한 역할을 함. JSXElement가 되기 위해서는 다음과 같은 형태 중 하나여야 함

- <JSXElement JSXAttributes(optional)></JSXElement>
- <JSXElement JSXAttributes(optional)/>
- <>JSXChildren(optional)</>
- JSXElementName
  - JSXIdentifier: JSX내부에서 사용할 수 있는 식별자. 자바스크립트 식별자 규칙과 동일.
  - JSXNamespacedName: JSXIdentifier:JSXIdentifier의 조합
  - JSXMemberExpression: JSXIdentifier.JSXIdentifier의 조합. :과 이어서 사용하는 것은 불가능.

### JSXAttributes

JSXElement에 부여할 수 있는 속성을 의미. 모든 경우에서 필수값이 아님.

- JSXSpreadAttributes: 자바스크립트의 전개연산자와 동일한 역할
- JSXAttribute: 속성을 나타내는 키와 값으로 짝을 이루어서 표현. 키는 JSXAttributeName, 값은 JSXAttributeValue로 불림
  - JSXAttributeName: 속성의 키 값. JSXIdentifier와 JSXNamespacedName이 가능하며. :을 이용해 키를 나타낼 수 있다.
  - JSXAttributeValue: 속성의 키에 할당할 수 있는 값. 다음 중 하나를 만족해야 함
    - 큰따옴표로 구성된 문자열
    - 작은 따옴표로 구성된 문자열
    - { AssignmentExpression }: 자바스크립트의 AssignmentExpression을 의미한다. ⇒ 자바스크립트에서 값을 할당할떄 쓰는 표현식을 말함. 자바스크립트에서 변수에 값을 넣을 수 있는 표현식은 JSX 속성의 값으로도 가능
    - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다.

### JSXChildren

JSXElement의 자식 값. JSX는 속성을 가진 트리구조를 나타내기 위해 만들어졌기 떄문에 JSX로 부모와 자식 관계를 나타낼 수 있음. 그 자식을 JSXChildren이라고 함.

- JSXChild: JSXChildren을 이루는 기본 단위. JSXChildren은 JSXChild를 0개 이상 가질 수 있음. ⇒ 없어도 됨
  - JSXText: 중괄호, 꺽쇠를 제외한 문자열. 사용하고 싶다면 문자열로 표시하는 방법이 있음
  - JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다.
  - JSXFragment: 값으로 빈 JSX요소인 <></>가 들어갈 수 있다
  - { JSXChildExpressions (optional) }: 이 JSXChildExpression은 자바스크립트 AssignmentExpression을 의미.

### JSXStrings

JSXAttributeValue, JSXText는 HTML과 JSX사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계되어 있음. HTML에서 사용할 수 있는 문자열은 모든 사용가능.

- 자바스크립트와의 차이점 : 이스케이프 문자 형태소. \를 표현하기 위해서는 \\로 표현해야 하지만 HTML에서는 아무런 제약 없이 사용가능. ⇒ JSX에서는 HTML처럼 \를 이스케이프 문자열로 처리하고 있지 않음.

## JSX 예제

## JSX가 자바스크립트로 변환되는 방법

자바스크립트가 JSX로 변환되는 방법을 알려면 리액트에서 JSX를 변환하는 @babel/plugin-transform-react-jsx 플러그인을 알아야 함. 이 플러그인은 JSX구문을 자바스크립트가 이해할 수 있는 형태로 변환함

1. JSXElement를 첫번쨰 인수로 선언해 요소를 정의한다
2. 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리

이 점을 이용하면 요소 전체를 감싸지 않아도 처리할 수 있어 JSXElement만 다르고 JSXAttributes, JSXChildren이 완전히 동일한 상황에서 코드를 최소화 할 수 있음.

# 2. 가상 DOM과 리액트 파이버

## 1. DOM과 브라우저 렌더링 과정

- DOM이란: 웹페이지에 대한 인터페이스. 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄 지에 대한 정보를 담고 있음.
  1. 브라우저가 사용자가 요청한 주소를 방문해 HTML파일 다운로드
  2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM노드로 구성된 트리를 만듬
  3. 2번 과정에서 CSS파일을 만나면 해당 CSS 파일 다운로드
  4. 이것도 브라우저 렌더링 엔진이 CSS노드로 구성된 트리를 만듦(CSSOM)
  5. 브라우저는 2번에서 만든 DOM노드를 순회. 모든 노드를 방문하는 것이 아닌 사용자 눈에 보이는 노드만 방문.(display:none)
  6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS스타일 정보를 이 노드에 적용. DOM노드에 CSS를 적용하는 과정은 크게 두가지로 나뉨
     1. 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정
     2. 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

## 2. 가상 DOM 탄생 배경

렌더링 이후 추가 렌더링 작업은 SPA에서 더욱 많이 보임. SPA의 특징 덕분에 페이지의 깜빡임 없이 자연스러운 웹 페이지 탐색을 할 수 있지만 그만큼 DOM을 관리하는 과정에서 부담해야할 비용이 커짐 ⇒ 개발자는 인터랙션에 대한 모든 DOM의 변경보다 결과적으로 만들어지는 DOM만 알고 싶을 것.

이러한 문제점을 해결하기 위해 가상 DOM이 등장.

웹페이지가 표시해야 할 DOM을 메모리에 저장하고, 리액트가 실제 변경에 대한 준비가 완료 되었을떄 실제 브라우저의 DOM에 반영.(여기서 리액트는 package.json에 있는 리액트가 아닌 react-dom을 의미)

하지만 리액트의 이러한 방식이 일반적인 DOM을 관리하는 브라우저보다 무조건 빠르다는 건 아니며, 대부분의 상황에서 충분히 빠르다는 것임.

## 3. 가상 DOM을 위한 아키텍쳐, 리액트 파이버

### 리액트 파이버란?

리액트에서 관리하는 평범한 자바스크립트 객체.

파이버는 파이버 재조정자(fiber reconciler)가 관리하며, 가상 DOM과 실제 DOM을 비교해 변경사항을 수집하여 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 함.

리액트 파이버의 목표는 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는것.

- 하는 일
  - 작업을 작은 단위로 분할하고 우선순위 매기기
  - 작업을 일시중지 하고 나중에 다시 시작 가능
  - 이전에 했던 작업을 다시 재사용하거나 폐기할 수 있음

이러한 과정은 비동기로 일어나며 파이버는 하나의 작업 단위로 구성되어 있음. 리액트는 이러한 작업단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리하고, 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경사항을 만들어 낸다. 그 과정을 아래의 두 단계로 나눌 수 있다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업 수행. 여기서 파이버의 작업이 일어남
2. 커밋 단계에서는 DOM에 실제 변경사항을 반영하기 위한 작업. commitWork()가 수행됨. 이 과정은 동기식으로 일어나고 중단 될 수도 없음.

리액트요소와의 차이점은 리액트 요소는 렌더링이 발생될 때마다 새롭게 생성되지만 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용됨. 생성된 파이버는 state가 변경, 생명주기 메서드가 실행, DOM의 변경이 필요한 시점 등에 실행.

### 리액트 파이버 트리

파이버 트리는 리액트 내부에 두개가 존재함. 하나는 현재의 모습을 담은 파이버트리, 다른 하나는 작업중인 상태를 나타내는 workInProgress 트리. 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버림(더블 버퍼링)

- 더블 버퍼링
  컴퓨터 그래픽 분야에서 사용하는 용어. 그래픽을 통해 화면에 표시되는 것을 그리기 위해서는 내부적으로 처리를 거쳐야 하는데, 이러한 처리를 거치게 되면 사용자에게 미쳐 다 그리지 못한 경우가 발생. 이러한 상황을 방지하기 위해 보이지 않는 곳에서 다음으로 그려야 할 그림을 미리 그린 후, 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 의미

이 더블 버퍼링은 커밋 단계에서 수행됨. ⇒ 현재 UI 렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업이 시작됨. ⇒ 업데이트가 발생시 리액트에서 새로 받은 데이터로 workInProgress 트리 빌드 ⇒ 빌드 작업이 끝나면 다음 렌더링에 이 트리를 사용 ⇒ current가 이 workInProgress로 변경됨

### 파이버의 작업 순서

1. 리액트는 beginWork() 함수를 실행

   자식이 없는 파이버를 만날떄까지 트리 형식으로 시작됨

2. 1번에서 작업이 끝나면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다
4. 2번 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

- setState 등으로 업데이트가 발생했을 때
  current 트리가 존재하고, setState로 인한 업데이트 요청을 받아 workInProgress 트리를 다시 빌드
  파이버가 이미 존재하기 때문에 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리.
  과거 동기식으로 처리했다는 작업이 이 작업이지만, 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트 작업을 일시중단 하거나, 새롭게 만들거나, 폐기힐 수 있다.

## 4. 파이버와 가상 DOM

가상DOM은 웹 애플리케이션에서만 통용되는 개념이며, 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기 때문에 파이버와 가상 DOM은 동일한 개념이 아님. 리액트와 네이티브의 렌더러가 서로 다르다 하더라도 내부적으로 파이버를 통해서 조정하는 과정은 동일함.

# 3. 클래스 컴포넌트와 함수 컴포넌트

## 1. 클래스 컴포넌트

기본적으로 클래스 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야함. extends 구문에 넣을 수 있는 클래스는 다음과 같음.

- React.Component
- React.PureComponent

이 둘의 차이점은 클래스 컴포넌트를 shouldComponentUpdate를 다루는데 있음.

### 클래스 컴포넌트의 생명주기 메서드

- 생명주기 메서드가 실행되는 시점
  - 마운트: 컴포넌트가 마운팅(생성) 되는 시점
  - 업데이트: 이미 생성된 컴포넌트의 내용이 변경되는 시점
  - 언마운트: 컴포넌트가 더이상 존재하지 않는 시점
- render()
  생명주기 메서드 중 하나로, 리액트 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰이며, UI를 렌더링 하기 위해서 쓰임. 마운트와 업데이트 과정에서 일어남.
  - 주의점
    이 함수는 항상 순수해야 하며 부수 효과가 없어야 함 ⇒ 같은 입력값(props, state)이 들어가면 항상 같은 결과물을 반환해야 한다는 뜻. == render() 내부에서 state를 직접 업데이트하는 this.state를 호출해서는 안됨.
- componentDidMount()
  클래스 컴포넌트가 마운트되고 준비가 됐다면 그다음으로 호출되는 생명주기 메서드. render()와 다르게 이 함수 내부에서는 this.setState()로 state값을 변경하는 것이 가능. 호출시 state변경 후 다시한번 렌더링 시도(UI 업데이트 전 실행) 성능 문제를 일으킬 수 있음에 주의하고, 일반적으로 state는 생성자에서 하는 것이 좋음
- componentDidUpdate()
  컴포넌트 업데이트가 일어난 후 바로 실행됨. 여기서도 this.setState() 사용이 가능하지만, 적절한 조건문으로 감싸지 않으면 계속 호출
- componentWillUnmount()
  컴포넌트가 언마운트되거나 더이상 사용되지 않기 직전에 호출. 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치. 이 메서드 내부에서는 this.setState 호출 불가
- shouldComponentUpdate()
  state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶다면 이 생명주기 메서드를 사용하면 됨. 이 메서드를 사용하는 것은 특정한 성능 최적화 상황에서만 고려
- static getDerivedStateFromProps()
  지금은 사라진 componentWillReceiveProps를 대체할 수 있는 메서드. 이 메서드는 render()를 호출하기 직전 호출. static으로 선언되어 this에 접근 불가. 여기서 반환하는 객체는 해당 객체의 내용이 모두 state로 들어가게 되지만 null반환 시 아무일도 일어나지 않음. 이 메서드도 render() 실행 시에 호출됨.
- getSnapShotBeforeUpdate()
  componentWillUpdate 를 대체할 수 있는 메서드. DOM이 업데이트되기 직전에 호출되며, 여기서 반환되는 값은 componentDidUpdate로 전달됨.
- getDerivedStateFromError()
- componentDIdCatch

### 클래스 컴포넌트의 한계

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 어렵다
- 기능이 많아질수록 컴포넌트의 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다
- 핫 리로딩을 하는데 상대적으로 불리하다
  - 핫 리로딩 : 코드에 변경사항이 발생했을때, 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경사항을 빠르게 적용하는 기법. 흔히 이 기능은 개발 단계에서 많이 사용됨.

## 2. 함수 컴포넌트

클래스 컴포넌트와 비교했을 떄 간결해졌으며, render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요도 없으며, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해짐. state는 객체도 관리 가능하며 return 에서도 this없이 props와 state에 접근 가능

## 3. 함수 컴포넌트 vs 클래스 컴포넌트

### 생명주기 메서드의 부재

함수 컴포넌트에서는 클래스 컴포넌트의 생명주기 메서드가 존재하지 않지만 useEffect훅을 사용해 componentDidMount, componentDidUpdate, componentWillUnmount를 비슷하게 구현할 수 있음. ⇒ 절대 똑같은 것이 아니며, useEffect는 생명주기를 위한 훅이 아닌 useEffect의 state를 활용해 동기적으로 부수효과를 만드는 메커니즘임.

### 함수 컴포넌트와 렌더링된 값

함수컴포넌트는 렌더링된 값을 고정한다. 클래스 컴포넌트는 props의 값을 항상 this로부터 가져오며, 클래스의 props는 외부에서 변경되지 않는 이상 불변 값이지만 this가 가리키는 객체(컴포넌트이 인스턴스의 멤버)는 변경가능한 값임. 따라서 render 메서드를 비롯한 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있게 된다.

### 클래스 컴포넌트를 공부해야할까?

많은 코드들이 클래스 컴포넌트로 작성되었기 때문에 이런 흐름을 알기 위해서는 어느정도 클래스 컴포넌트에 지식도 필요함. 특히 자식 컴포넌트에서 발생한 에러에 대한 처리는 클래스 컴포넌트로만 가능하기 때문

# 4. 렌더링은 어떻게 일어나는가?

## 1. 리액트의 렌더링이란?

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 ui를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미

## 2. 리액트의 렌더링이 일어나는 이유

- 렌더링 발생 시나리오
  1. 최초 렌더링: 사용자가 처음 애플리케이션에 진입시 브라우저에 정보를 제공하기 위해 수행
  2. 리렌더링 : 최초 렌더링 이후 발생하는 모든 렌더링.
     - 렌더링이 발생하는 경우
       - 클래스 컴포넌트의 setState가 실행되는 경우
       - 클래스 컴포넌트의 forceUpdate가 실행되는 경우
       - 함수 컴포넌트의 useState()의 두번째 배열 요소인 setter가 실행되는 경우
       - 함수 컴포넌트의 useReducer()의 두번째 배열 요소인 dispatch가 실행되는 경우
       - 컴포넌트의 key props가 변경되는 경우
       - props가 변경되는 경우
       - 부모 컴포넌트가 렌더링될 경우: **부모 컴포넌트가 리렌더링되면 자식 컴포넌트도 무조건 리렌더링 발생**

MobX와 Redux는 각자의 방법으로 상태를 관리해 주지만 상태관리가 리액트의 리렌더링으로 이어지지는 않는다. mobx-react, react-redux가 앞의 라이브러리로부터 변경된 상태를 바탕으로 위에서 언급한 방법 중 하나를 사용해 리렌더링을 발생시키는 것. Recoil처럼 별도의 리액트 패키지가 없어도 상태관리가 되는 라이브러리의 경우에는 내부에서 useState등을 통해 리렌더링을 발생시킴

## 3. 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정되어있는 컴포넌트를 찾는다. 발견하면 클래스 컴포넌트의 경우 클래스 내부의 render()함수를 실행하고, 함수 컴포넌트의 경우에는 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장함.

렌더링 프로세스가 실행되면서 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집 후, 재조정(Reconcilation)과정을 거치게 됨. 이 과정이 모두 끝나면 모든 변경사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 됨.

리액트의 렌더링은 렌더 단계와 커밋 단계 두단계로 분리되어 실행됨.

## 4. 렌더와 커밋

- 렌더 단계(Render Phase)
  컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업. ⇒ 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계. 여기서 비교하는 것은 type, props, key. 이중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둠.
- 커밋 단계(Commit Phase)
  렌더 단계의 변경사항을 실제 DOM에 적용해 사용자에게 보여주는 과정. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생
  > 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는것은 아님.
  > 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면 이 커밋 단계는 생략될 수 있음. ⇒ 꼭 가시적인 변경이 일어나지 않아도 발생할 수 있다.

이 두가지 과정으로 이뤄진 리액트의 렌더링은 항상 동기식으로 작동했다. 렌더링이 비동기 방식으로 이뤄질 경우 사용자는 하나의 상태에 대해 여러가지 다른 UI를 보게 될 것이고, 이는 사용자에게 혼란을 줄 수 있음. 그럼에도 비동기 렌더링 시나리오는 몇가지 상황에서 유효할 수 있어서 리액트 18부터 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링(동시성 렌더링)이 도입됨.

- 동시성 렌더링
  렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단, 재시작, 포기가 가능. 이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있어서 매끄러움 사용자 경험을 누릴 수 있음.

## 5. 일반적인 렌더링 시나리오 살펴보기

# 4. 컴포넌트 함수의 무거운 연산을 기억해두는 메모이제이션

## 1. 주장1: 필요한 곳에만 메모이제이션을 추가하자

```jsx
function sum(a, b) {
  return a + b;
}
```

위와 같은 함수가 있다고 할떄, 이와같은 가벼운 함수는 자바스크립트 메모리 어딘가에 두었다가 그것을 다시 꺼내오는 것보다는 매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를수도 있다.

메모이제이션에도 비용이 든다. 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 꺼내와야 한다는 두가지 비용이 있음. 이 비용이 리렌더링 비용보다 저렴하다고 할 수 있느냐는 상황에 따라 다름. 항상 메모이제이션은 신중하게 접근해야 하며, 섣부른 최적화는 항상 경계해야함.

메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법. 메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하는 상황을 마주하게 됨.

리액트 공식문서에 다음과 같은 내용도 나와있음.

<aside>
useMemo는 성능 최적화를 위해 사용할 수 는 있지만 의미상으로 그것이 보장된다고 생각하지는 마세요. 가까운 미래에 리액트에서는 이전에 메모이제이션된 값들의 일부를 “잊어버리고” 다음 렌더링 시에 그것들을 재계산하는 방향을 택할지도 모르겠습니다. 예를 들면, 오프스크린 컴포넌트의 메모리를 해제하는 등이 있을 수 있습니다. useMemo를 사용하지 않고도 작동할 수 있도록 코드를 작성하고 그것을 추가해 성능을 최적화 하세요

</aside>

미래의 어떤 경우에는 캐시가 무효화되는 경우도 있을 것임. 리액트가 useMemo를 언제까지고 성능 최적화를 위해 제공해줄 것이라는 보장은 없기 떄문에 섣불리 최적화하는 것은 옳지 못함

## 2. 주장2: 렌더링 과정의 비용은 비싸니까 다 하자

두가지 주장에서 공통으로 깔고가는 전제는 다음과 같다.

- 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다
  섣부른 최적화인지 여부는 관계없이, 만약 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함되 있고, 자식 컴포넌트도 많이 가지고 있다면 memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 떄가 분명히 있다.

리액트 애플리케이션의 규모가 커지고, 개발자는 많아지고, 컴포넌트의 복잡성이 증가하는 상황에서는 주장1의 기조를 유지하기 어렵다. 따라서 일단 memo로 감싼뒤에 생각해보자. 이것이 괜찮은지 생각해보려면 잘못된 컴포넌트에 이뤄진 최적화(렌더링 비용이 저렴하거나 렌더링이 별로 안되는 컴포넌트에)시에 역으로 지불해야 하는 비용을 생각해보자.

잘못된 memo로 지불해야 하는 비용 ⇒ props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용

리액트의 기본적인 알고리즘 때문에 이전 결과물을 어떻게든 저장해두고 있음. 따라서 memo로 지불해야 하는 비용은 props에 대한 얕은 비교 뿐임. 하지만 props가 크고 복잡해지면 이 비용또한 커질 수 있음

반면 memo를 하지 않았을 때 발생할 수 있는 문제는 다음과 같음

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두가지 모두가 모든 자식 컴포넌트에서 반복적으로 일어남
- 리액트가 구 트리와 신규 트리를 비교
- useMemo와 useCallback
  리렌더링이 발생할 떄 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 됨. 이 달라진 참조에 대한 값을 어디서든 쓰지않는다면 큰 문제가 되지 않을 수 있지만 이 값이 useEffect와 같은 의존성 배열에 쓰이면 변경된 참조로 인해 다른 쪽에도 영향을 미칠 것임

  ```jsx
  function useMath(number: number) {
    const [double, setDouble] = useState(0);
    const [triple, setTriple] = useState(0);

    useEffect(() => {
      setDouble(number * 2);
      setTriple(number * 3);
    }, [number]);

    return useMemo(() => ({ double, triple }), [double, triple]);
  }
  ```

### 5. 정리

1. 리액트를 배우고 있거나 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다 ⇒ 1번의 의견대로해보기
2. 현업에서 사용하고 있거나 시간적 여유가 없는 상황 ⇒ 2번
