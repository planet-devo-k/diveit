# Interview

**MVC 패턴 vs Flux 패턴**

1. MVC 패턴 (Model-View-Controller) 데이터를 다루는 Model, 사용자에게 보여지는 View, 이 사이의 로직을 처리하는 Controller

* 구조: Controller가 사용자의 입력을 받아 Model을 업데이트하면, 그 변화가 View에 반영됩니다.
* 데이터 흐름: 뷰와 모델 사이의 관계가 복잡해지면 데이터가 양방향으로 흐를 수 있습니다.
* 한계: 대규모 애플리케이션에서는 하나의 모델이 여러 뷰를 업데이트하거나, 하나의 뷰가 여러 모델을 업데이트하면서 데이터 흐름이 거미줄처럼 꼬이게 됩니다. 특정 상태 변화가 어디서 시작되었는지 추적하기가 매우 어려워집니다.

2. Flux 패턴 페이스북이 MVC의 예측 불가능한 데이터 흐름을 해결하기 위해 고안한 단방향 데이터 흐름(Unidirectional Data Flow) 패턴입니다.

* 구조: Action -> Dispatcher -> Store -> View의 고정된 흐름을 가집니다.
  * Action: 어떤 이벤트가 발생했는지 알려주는 객체입니다.
  * Dispatcher: 액션을 받아 스토어로 전달하는 중앙 허브입니다.
  * Store: 애플리케이션의 상태와 로직을 담고 있습니다.
  * View: 스토어의 데이터를 화면에 출력하고, 다시 액션을 발생시킵니다.
* 데이터 흐름: 데이터는 반드시 한 방향으로만 흐릅니다. 뷰에서 상태를 직접 바꾸는 것은 불가능하며, 반드시 액션을 통해 디스패처를 거쳐야만 스토어가 갱신됩니다.

**서버 상태(Server State)와 클라이언트 상태를 어떻게 구분해서 관리하시나요?**

서버 상태 (Server State)

* 정의: DB에 저장되어 있으며 API를 통해 가져와야 하는 외부 데이터입니다. (예: 사용자 프로필, 상품 목록)
* 특징: 비동기적으로 동작하며, 여러 사용자가 공유하므로 내가 모르는 사이에 변할 수 있습니다.
* 관리: React Query나 SWR을 사용합니다. 수동으로 관리하기 까다로운 캐싱, 중복 요청 제거, 에러 처리를 라이브러리에 맡겨 비즈니스 로직에 집중합니다.

클라이언트 상태 (Client State)

* 정의: UI의 현재 상태를 나타내며 브라우저 메모리에만 존재합니다. (예: 모달 오픈 여부, 입력 폼 값, 다크모드)
* 특징: 동기적으로 즉시 접근 가능하며, 현재 사용자의 액션에 의해서만 변합니다.
* 관리: Zustand나 전역 Context API를 사용하여 컴포넌트 간에 공유합니다. 단순한 상태는 useState로 지역화하여 관리 범위를 최소화합니다.

**우리 서비스의 사용자 경험(UX)을 개선하기 위해 어떤 데이터 페칭 전략을 쓰겠습니까?**

사용자가 느끼는 로딩 체감 시간을 줄이고 흐름을 끊기지 않게 하는 것이 핵심입니다.

* SWR (Stale-While-Revalidate) 전략 사용
* 낙관적 업데이트 (Optimistic Update)
* Prefetching (미리 가져오기)
* Suspense와 스켈레톤 UI
