# Interview

**훅을 사용할 때 지켜야 할 규칙은 무엇인가요?**

* 최상위에서만 호출 (조건문·반복문 내부 X)
* 오직 리액트 함수 컴포넌트 또는 커스텀 훅 내부에서만 호출

**훅의 호출 순서가 왜 중요한가요?**

리액트는 훅 순서로 상태를 추적하기 때문에 순서가 바뀌면 잘못된 state에 접근하게 됨

**useState는 어떤 원리로 상태를 유지하나요?**

클로저와 파이버 구조를 통해 state를 기억하고, setState가 클로저로 이전 state를 참조함.

**useState의 초깃값으로 함수를 넣는 이유는?**

초기 연산이 비쌀 때, 최초 한 번만 실행되도록 성능 최적화하기 위해(게으른 초기화; lazy initialization)

**useEffect의 실행 시점은 언제인가요?**

브라우저 렌더링 직후

**useEffect와 useLayoutEffect의 차이는?**

* useLayoutEffect → DOM 변경 직후(화면 반영 전) 동기 실행
* useEffect → 화면 렌더링 후 비동기 실행

**useEffect와 일반 함수 실행의 차이는 무엇인가요?**

* useEffect는 렌더링 후 클라이언트 전용
* 일반 함수는 렌더링 중 실행되어 SSR에도 포함됨.

**Context API를 사용할 때 주의할 점?**

* 전역 리렌더링 주의 (필요한 범위만 Provider로 감싸기)

**Zustand나 Redux 같은 상태관리 라이브러리와 Context 차이?**

* Context는 값 전달만
* Zustand/Redux는 상태 변경, 최적화 로직까지 포함

**useReducer를 사용하는 이유는?**

복잡한 상태 전이를 규칙(action) 기반으로 명시적으로 관리하기 위해.

**useMemo와 useCallback의 차이를 설명해보세요.**

* useMemo: 값 메모이제이션
* useCallback: 함수 메모이제이션

**커스텀 훅과 고차컴포넌트(HOC)의 차이와 각각 언제 사용하면 좋을지?**

* 커스텀 훅 → 로직 재사용 (렌더링 X)
* HOC → 렌더링 결과 제어 (컴포넌트 감싸기)

**useMemo와 React.memo의 차이는 무엇인가요?**

* useMemo: 값(계산 결과) 캐싱
* React.memo: 컴포넌트 자체 렌더링 방지

**React.memo는 어떤 원리로 리렌더링을 방지하나요?**

이전 props와 새 props를 얕게 비교해 같으면 리렌더링 생략.
