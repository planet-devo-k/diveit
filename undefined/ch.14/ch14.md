# Takeaways

## 웹사이트 보안

### 리액트에서 발생하는 <mark style="background-color:yellow;">크로스 사이트 스크립팅(XSS)</mark>

* XSS: **웹사이트 개발자가 아닌 제3자가 웹사이트에 악성 스크립트를 삽입해 실행할 수 있는 취약점**. \
  일반적으로 게시판과 같이 사용자가 입력을 할 수 있고 이 입력을 다른 사용자에게 보여줄 수 있는 경우에 발생. 쿠키를 획득해 사용자의 로그인 세션 등을 탈취하거나 사용자의 데이터를 변경 하는 등 위험.

#### XSS 이슈는 어떻게 발생할 수 있을까?

* dangerouslySetInnerHTML prop
  * 특정 브라우저 DOM의 innerHTML을 특정한 내용으로 교체할 수 있는 방법
  * 게시판 같이 사용자나 관리자가 입력한 내용을 브라우저에 표시하는 용도로 사용
  * 오직 `__html`을 키로 가지고 있는 객체만 인수로 받을 수 있으며, 이 인수로 넘겨받은 문자열을 DOM에 그대로 표시
  * 문제는 이 인수로 받는 문자열에 제한이 없다는 것. 자바스크립트 코드가 들어갈 수 있다.
* useRef를 활용한 직접 삽입
  * useRef를 사용하면 DOM에 직접 접근할 수 있다.
  * innerHTML에 보안 취약점이 있는 스크립트를 삽입하면 위와 동일한 문제 발생
* `<script>`나 svg/onload를 사용하는 방식 외에도 \
  a태그에 잘못된 href를 삽입하거나 \
  onclick, onload등 이벤트를 활용하는 등 여러 방식의 XSS가 있다.

#### 리액트에서 XSS 문제를 피하는 방법

* **sanitize** 또는 **escape**: 제3자가 삽입할 수 있는 HTML을 **안전한 HTML코드로 한번 치환한다.**
* sanitize하기 위해 npm 라이브러리 사용
  * DOMpurity
  * sanitize-html: 허용할 태그와 목록을 일일히 나열하는 allow list 방식.
  * js-xss
* 보여줄때 뿐 아니라 **사용자가 콘텐츠를 저장할 때도 한번 이스케이프 과정을 거치는 것이 효율적이고 안전**.
  * 애초에 XSS 위험성이 있는 콘텐츠를 데이터베이스에 저장하지 않는것이 더 안전하고, 한번 이스케이프하면 보여줄때마다 일일이 이스케이프 과정을 거치지 않아도 되므로.
* **치환과정은 되도록 서버에서 수행**. 서버는 클라이언트에서 사용자가 입력한 데이터는 일단 의심한다는 자세로 **클라이언트의 POST요청에 있는 HTML을 이스케이프**한다.
* **치환과정을 클라이언트에서 할 경우** 일반적인 사용자라면 문제가 되지 않지만 **POST요청을 스크립트나 curl등으로 직접 요청하면 스크립트에서 실행하는 이스케이프 과정을 생략하고 바로 저장될 가능성이 있다.**
  * 일반적인 사용자의 요청 (브라우저 이용)
    * 보통의 사용자는 개발자가 만든 웹 페이지(UI)를 통해 데이터를 보냅니다.
      * 사용자가 게시판에 글을 쓰고 '저장' 버튼을 누름 → 브라우저 내의 자바스크립트 코드가 실행됨 → (코드에 적힌 대로) HTML 치환(Sanitize) 실행 → 깨끗해진 데이터를 서버로 전송.
      * 개발자가 설계한 '치환 과정'이 담긴 자바스크립트 로직을 반드시 거치게 됩니다.
  * 스크립트나 curl 등을 이용한 요청 (직접 호출)
    * 하지만 해커나 숙련된 사용자는 브라우저 화면을 거치지 않고 서버의 주소(API 엔드포인트)로 직접 데이터를 쏴버릴 수 있습니다.
    * curl이란?: 터미널(검은 화면)에서 명령어로 웹 서버에 데이터를 보내는 도구입니다. 브라우저 없이도 "이 주소로 이 내용을 보내줘"라고 명령할 수 있습니다.
    * 공격자가 터미널을 염 → curl -X POST -d "content=`<script>alert('XSS')</script>`" http://api.service.com/post 명령 실행.
    * 이 과정에서는 개발자가 리액트(클라이언트)에 짜놓은 치환 로직이 아예 실행될 기회가 없습니다. 브라우저를 쓰지 않았으니까요.
* 게시판 같은 예시가 웹사이트에 없다고 해도 XSS 문제는 발생할 수 있다. \
  예를 들어 **쿼리스트링에 있는 내용**을 그대로 실행하거나 보여주는 경우에도 보안 취약점이 발생할 수 있다.
* 따라서 개발자는 자신이 작성한 코드가 아닌 **query, GET파라미터, 서버에 저장된 사용자가 입력한 데이터 등 외부에 존재하는 모든 코드를 위험한 코드로 간주하고 이를 적절하게 처리**하는 것이 좋다.

### getServerSideProps와 서버 컴포넌트를 주의하자

* 서버에는 일반 사용자에게 노출되면 안되는 정보들이 있기 때문에 **클라이언트(브라우저)에 정보를 내려줄 때 조심**해야한다.
* getServerSideProps가 반환하는 props값은 모두 사용자의 HTML에 기록되고 전역변수로 등록되어 스크립트로 충분히 접근할 수 있는 보안 위협에 노출되는 값이 된다.
* getServerSideProps가 반환하는 값 또는 서버 컴포넌트가 클라이언트 컴포넌트에 반환하는 props는 반드시 필요한 값으로만 철저하게 제한되야 한다.
  * 예를 들어 **쿠키 전체를 제공하지 말고 클라이언트에서 핊요한 token값만 제한적으로 반환**하고 \
    이 값이 없을 때 예외 처리할 리다이렉트도 모두 서버에서 처리.
* window.PRELOADED\_STATE 값은 XSS에 취약할 수 있으므로 반드시 새니타이즈하고 꼭 필요한 값만 제공.

### `<a>`태그 값에 적절한 제한을 둬야한다.

* a태그의 href에 `javascript:` 로 시작하는 자바스크립트 코드를 넣는 경우 → XSS 등 보안 이슈
  * a태그의 기본 기능인 href로 선언된 URL로 페이지 이동하는 것을 막고 onClick이벤트 같이 별도 이벤트 핸들러만 작동시키기 위한 용도.
  * 이러한 방식은 안티패턴.
    * a태그는 반드시 페이지 이동이 있을 때만 사용.
    * 페이지 이동 없이 핸들러만 작동시키고 싶다면 button사용
  * 정확히는 href가 작동하지 않는 것이 아니라 `javascript:` 만 실행된것. 즉, 자바스크립트 코드가 존재하면 이를 실행한다.
* **href값 제한**
* **피싱 사이트로 이동하는 것을 막기 위해 origin도 확인해 처리**

### HTTP 보안 헤더 설정하기

* **HTTP 보안 헤더**: 브라우저가 렌더링하는 내용과 관련된 보안 취약점을 미연에 방지하기 위해 **브라우저와 함께 작동하는 헤더**. **보안 헤더는 일종의 '브라우저 행동 지침서'**
  * 브라우저가 사이트에 접속(Request) → 서버가 HTML 데이터와 함께 보안 헤더를 보냄(Response) → 브라우저가 헤더를 읽고 "아, 이 사이트에서는 이런 보안 규칙을 지켜야겠구나!"라고 판단하여 스스로를 통제함
* **보안 헤더는 서버가 브라우저(클라이언트)에게 보내는 응답 헤더에 포함**됩니다.
* **보안 헤더를 설정하는 주체는 웹 서버(Nginx, Apache)나 백엔드 애플리케이션(Node.js, Spring, Python 등)입니다.**

#### HTTP 보안 헤더

<mark style="background-color:yellow;">**Strict-Transport-Security**</mark>

* HTTP의 Strict-Transport-Security 응답 헤더는 모든 사이트가 HTTPS를 통해 접근해야 하며 만약 HTTP로 접근하는 경우 이러한 모든 시도는 HTTPS로 변경되게 한다.
* `Strict-Transport-Security: max-age=<expire-time>; includeSubDomains`
* expire-time은 브라우저가 이 설정을 기억해야 하는 시간. 초 단위. 권장 값은 2년이다.
  * HTTP 접근이 불가능하기 때문에 무기한(또는 지나치게 긴 시간)으로 설정하면 나중에 사이트 운영 방식이 바뀌었을 때 되돌리기가 매우 어렵습니다.&#x20;
* includeSubDomains는 이 규칙이 모든 하위 도메인에 적용

**X-XSS-Protection**

* 비표준 기술로 사파리와 구형 브라우저에서만 제공
* 페이지에서 XSS 취약점이 발견되면 페이지 로딩을 중단하는 헤더
* **Content-Security-Policy가 있다면 그다지 필요 없지만** CSP를 지원하지 않는 구형 브라우저에서는 사용 가능.
* 이 헤더를 전적으로 믿어서는 안되며 반드시 페이지 내부에 XSS에 대한 처리가 존재하는 것이 좋다.

```
X-XSS-Protection: 0
X-XSS-Protection: 1
X-XSS-Protection: 1; mode=block
X-XSS-Protection: 1; report=<reporting-uri>
```

* 0: XSS 필터링을 끈다.
* 1: 기본값. XSS공격이 페이지 내부에서 감지되면 XSS 관련 코드를 제거한 안전한 페이지를 보여준다.
* 1; mode=block : XSS공격이 페이지 내부에서 감지되면 아예 접근 자체를 막아버린다.
* X-XSS-Protection: 1; report= : 크로미움 기반 브라우저에서만 작동. XSS 공격이 감지되면 보고서를 report= 쪽으로 보낸다.

<mark style="background-color:yellow;">**X-Frame-Options**</mark>

* 외부에서 자신의 페이지가 삽입되는 것을 막아주는 헤더. frame, iframe, embed, object 내부에서 렌더링 안되도록.

```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
```

* DENY: 무조건 막는다.
* SAMEORIGIN: 같은 origin에 대해서만 프레임을 허용한다.

<mark style="background-color:yellow;">**Permissions-Policy**</mark>

* 웹사이트에서 **사용할 수 있는 기능과 사용할 수 없는 기능을 명시적으로 선언**하는 헤더(카메라, GPS 등 브라우저가 제공하는 기능)
* 다양한 브라우저 기능이나 API를 선택적으로 활성화하거나 필요에 따라 비활성화할수 있다.
* 이 헤더를 활용해 혹시 **XSS가 발생한다해도 사용자에게 미칠 수 있는 악영향을 제한**할 수 있게 된다.
* 제어할 수 있는 기능 목록은 MDN 참고
* **https://www.permissionspolicy.com**에서 기능을 선택해 헤더를 만드는 것도 가능

```
# 모든 geolocation 사용을 막는다.
Permission-Policy: geolocation=()

# geolocation을 페이지 자신과 몇가지 페이지에 대해서만 허용한다.
Permission-Policy: geolocation=(self "https://..." "https://...")

# 카메라는 모든 곳에서 허용한다.
Permission-Policy:camera=*;

# pip 기능을 막고, geolocation은 자신과 특정 페이지만 허용하며, 카메라는 모든 곳에서 허용한다.
Permission-Policy: picture-in-picture=(), geolocation=(self https://...), camera=*;

```

* PiP(Picture-in-Picture): 화면 위에 아주 작은 '떠 있는 창'을 하나 더 띄우는 기능. 비디오 시청이나 영상 통화 중에 아주 유용하게 쓰이는 기능

<mark style="background-color:yellow;">**X-Content-Type-Options**</mark>

* MIME(Multipurpose Internet Mail Extensions)
  * **Content-type의 값**. jpg, CSS, JSON 등 다양하다.
    * 예를 들어 네이버는 www.naver.com을 `Content-Type: text/html; charset=UTF-8`로 반환해 브라우저가 이를 UTF-8로 인코딩된 text/html로 인식할 수 있게 도와주고 브라우저는 이 헤더를 참고해 해당 파일에 대해 HTML을 파싱하는 과정을 거친다.
  * 원래는 메일 전송할 때 사용하던 인코딩 방식.
* X-Content-Type-Options
  * Content-type 헤더에서 제공하는 **MIME유형이 브라우저에 의해 임의로 변경되지 않게 하는 헤더**.
  * 즉 웹서버가 브라우저에게 강제로 이 파일을 읽는 방식을 지정하는 헤더.
  * `Content-Type: text/css` 헤더가 없는 파일은 브라우저가 임의로 CSS로 사용할수 없다. \
    마찬가지로 `Content-Type: text/javascript` 나 `Content-Type: application/javascript` 헤더가 없는 파일은 자바스크립트로 해석할 수 없다.
  * **파일내용이 CSS인데 MIME이 text/css가 아닌 경우 차단된다.**
  * 어떤 공격자가 .jpg파일을 웹서버에 업로드 했는데 실제로 그림이 아닌 스크립트 정보를 담고 있다면 브라우저는 실제 파일 내용을 보고 스크립트로 읽고 해당 코드를 실행할수도 있다.
  * `X-Content-Type-Options: nosniff`

<mark style="background-color:yellow;">**Referrer-Policy**</mark>

* HTTP요청에는 Referer라는 헤더가 존재. 이 헤더는 **현재 요청을 보낸 페이지의 주소가 나타난다.**
  * 링크를 통해 들어왔다면 해당 링크를 포함하고 있는 페이지 주소
  * 다른 도메인에 요청을 보낸다면 해당 리소스를 사용하는 페이지 주소
* **사용자가 어디서 와서 방문 중인지 인식할 수 있는 헤더.** \
  **사용자 입장에서는 원치 않는 정보가 노출될 위험도 존재**
* Referrer-Policy 헤더: 이 **Referer헤더에서 사용할 수 있는 데이터**
* <mark style="background-color:yellow;">**origin**</mark><mark style="background-color:yellow;">:</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">**schema, hostname, port**</mark>의 조합
* https://naver.kr
  * schema: HTTPS 프로토콜
  * hostname: naver.kr
  * port: 443 포트
    * 브라우저가 프로토콜(HTTP/HTTPS)에 따른 기본 포트 번호를 알고 있기 때문에 생략해 주는 것
    * 전 세계적으로 HTTP는 80번, HTTPS는 443번 포트를 쓰기로 약속되어 있습니다.
    * 만약 서버가 443이 아닌 8080 같은 특수 포트를 쓴다면, 이때는 반드시 https://naver.kr:8080처럼 포트 번호를 써줘야만 접속이 됩니다.
  *   https://naver.kr 기반으로 same-origin인지 cross-origin인지 구분

      <table><thead><tr><th width="230">비교 대상 URL</th><th width="101" align="center">판정</th><th width="289">원인 분석</th></tr></thead><tbody><tr><td><code>https://naver.kr</code></td><td align="center"><strong>Same</strong></td><td>Protocol, Host, Port 모두 일치</td></tr><tr><td><code>http://naver.kr</code></td><td align="center"><strong>Cross</strong></td><td><strong>Protocol</strong> 불일치 (HTTPS vs HTTP)</td></tr><tr><td><code>https://blog.naver.kr</code></td><td align="center"><strong>Cross</strong></td><td><strong>Host</strong> 불일치 (서브도메인이 다름)</td></tr><tr><td><code>https://www.naver.kr</code></td><td align="center"><strong>Cross</strong></td><td><strong>Host</strong> 불일치 (서브도메인이 다름)</td></tr><tr><td><code>https://daum.net</code></td><td align="center"><strong>Cross</strong></td><td><strong>Host</strong> 불일치 (도메인이 완전히 다름)</td></tr><tr><td><code>https://naver.kr:8080</code></td><td align="center"><strong>Cross</strong></td><td><strong>Port</strong> 불일치 (443 vs 8080)</td></tr></tbody></table>

      * 보통 우리가 naver.com과 www.naver.com을 똑같다고 생각하는 이유는 네이버 설정상 둘 다 같은 페이지로 연결해주기 때문이지, 브라우저 보안 관점(SOP)에서는 엄연히 주소가 다른 'Cross-origin'입니다.
*   **Referrer-Policy 값에 따른 작동 방식**

    <table><thead><tr><th width="122.5999755859375">Referrer-Policy 값</th><th width="120.800048828125" align="center">No Data   (전송 안 함)</th><th width="139.20001220703125" align="center">Origin Only (도메인만)</th><th width="172.4000244140625" align="center">Full URL (전체 경로)</th><th align="center">브라우저 기본값 여부</th></tr></thead><tbody><tr><td><strong>no-referrer</strong></td><td align="center">✅</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td><strong>no-referrer-when-downgrade</strong></td><td align="center">(HTTPS→HTTP 시)</td><td align="center">-</td><td align="center">✅ <br>(보안 유지 시)</td><td align="center">과거 기본값</td></tr><tr><td><strong>origin</strong></td><td align="center">-</td><td align="center">✅</td><td align="center">-</td><td align="center">-</td></tr><tr><td><strong>origin-when-cross-origin</strong></td><td align="center">-</td><td align="center">✅ <br>(타 도메인 이동 시)</td><td align="center">✅ <br>(동일 도메인 이동 시)</td><td align="center">-</td></tr><tr><td><strong>same-origin</strong></td><td align="center">✅ <br>(타 도메인 이동 시)</td><td align="center">-</td><td align="center">✅ <br>(동일 도메인 이동 시)</td><td align="center">-</td></tr><tr><td><strong>strict-origin</strong></td><td align="center">(HTTPS→HTTP 시)</td><td align="center">✅ <br>(보안 유지 시)</td><td align="center">-</td><td align="center">-</td></tr><tr><td><strong>strict-origin-when-cross-origin</strong></td><td align="center">(HTTPS→HTTP 시)</td><td align="center">✅ <br>(타 도메인 이동 시)</td><td align="center">✅ <br>(동일 도메인 이동 시)</td><td align="center"><strong>현재 기본값</strong></td></tr><tr><td><strong>unsafe-url</strong></td><td align="center">-</td><td align="center">-</td><td align="center">✅</td><td align="center">위험<br>(권장 안 함)</td></tr></tbody></table>

    * Origin Only (`https://naver.kr`): 쿼리 스트링이나 상세 경로를 제외한 **프로토콜 + 도메인** 정보만 보냅니다.
    * Full URL (`https://naver.kr/news/123?q=abc`): 사용자가 보고 있던 **상세 페이지 주소와 파라미터**까지 전부 보냅니다.
    * Downgrade (HTTPS → HTTP): 보안 프로토콜에서 비보안 프로토콜로 이동할 때를 말하며, 대부분의 `strict` 정책은 이때 정보를 차단합니다.
    * 기본값 설정: 현재 크롬, 에지, 사파리 등 현대적인 브라우저는 **`strict-origin-when-cross-origin`**&#xC744; 기본으로 채택하여 보안과 통계 사이의 균형을 잡고 있습니다. 구글에서는 이용자의 개인정보 보호를 위해 strict-origin-when-cross-origin 혹은 그 이상을 명시적으로 선언할 것을 권고.
    * 값을 명시적으로 설정하지 않으면 브라우저의 기본값으로 작동하게 되어 웹사이트에 접근하는 환경별로 다른 결과를 만들수 있다.
* Referrer-Policy는 응답 헤더 뿐 아니라 페이지의 `<meta/>` 태그로도 다음과 같이 설정 할 수 있다. **`<meta name="referrer" content="origin"/>`**
* 페이지 이동 시나 이미지 요청, link 태그 등에도 다음과 같이 사용. \
  &#xNAN;**`<a href="http://naver.kr" referrerpolicy="origin">...</a>`**

<mark style="background-color:yellow;">**Content-Security-Policy(CSP)**</mark>

* **콘텐츠 보안 정책**
* XSS공격이나 데이터 삽입 공격 등 다양한 보안 위협을 막기 위해 설계
* 사용할 수 있는 지시문이 굉장히 많다. 웹 표준을 정의한 W3에서 확인 가능
* 대표적인 지시문
  *   \*-src

      * 다양한 src를 제어할 수 있는 지시문 (font-src, img-src, script-src 등 p895)
      * 브라우저가 모든 출처(Source)를 감시하고 제한

      ```
      // font의 src로 가져올 수 있는 소스를 제한할 수 있다.
      // 아래 선언된 폰트 소스만 가져올 수 있으며 이 외 모든 소스는 차단

      Content-Security-Policy: font-src <source>;
      Content-Security-Policy: font-src <source> <source>;
      ```

      * 만약 해당 -src가 선언돼 있지 않다면 default-src로 한번에 처리할수도 있다. \
        default-src는 다른 \_-src에 대한 폴백역할을 한다.&#x20;

      ```
      Content-Security-Policy: default-src <source>;
      Content-Security-Policy: default-src <source> <source>;
      ```
  *   form-action

      * **폼 양식으로 제출할 수 있는 URL을 제한**할 수 있다.
        * 웹사이트의 form 태그는 데이터를 보낼 목적지(action)를 정합니다.&#x20;
        * form-action은 이 목적지 주소가 안전한 곳인지 브라우저가 검사하게 만드는 규칙입니다.
      * form-action 자체를 모두 막아버리는 것도 가능.

      ```
      <meta http-equiv="Content-Security-Policy" content="form-action 'none'" />

      // http-equiv(HTTP Equivalent): HTML 문서 안에서 마치 서버의 HTTP 응답 헤더인 것처럼 동작하도록 정보를 설정할 때 사용하는 속성
      // 서버 설정을 직접 건드릴 수 없는 환경이거나 특정 HTML 파일에만 특별한 규칙을 적용하고 싶을 때 "이 메타 태그를 읽으면 마치 서버에서 보낸 헤더를 읽은 것처럼 취급해"라고 브라우저에게 요청하는 통로
      ```

<mark style="background-color:yellow;">**보안헤더 설정, 확인하기**</mark>

*   Next에서 보안 헤더 설정

    * Next.js에서는 HTTP 경로별 보안 헤더를 적용할수 있다.
      * 웹사이트의 모든 페이지에 똑같은 보안 규칙을 적용할 필요가 없다는 뜻입니다.
      * 특정 주소(Path)에만 더 강력한 보안을 걸거나, 반대로 특정 페이지에서만 보안을 살짝 풀어줄 수 있습니다.
    * **next.config.js 에서 설정할 수 있는 값**
      * X-DNS-Prefetch-Control
      * **위 헤더들 전부 가능**
      * CSP의 경우 선언할수 있는 지시어가 많아서 개별적으로 선언한 이후에 묶어주는 것이 편리

    ```js
    /** @type {import('next').NextConfig} */
    const nextConfig = {
      async headers() {
        return [
          {
            // 1. 모든 경로(root부터 하위 전체)에 적용할 기본 보안 헤더
            source: "/:path*",
            headers: [
              { key: "X-DNS-Prefetch-Control", value: "on" },
              { key: "X-Frame-Options", value: "DENY" },
              { key: "X-Content-Type-Options", value: "nosniff" },
              {
                key: "Referrer-Policy",
                value: "strict-origin-when-cross-origin",
              },
            ],
          },
          {
            // 2. 특정 경로(/admin)에만 더 강력한 CSP 적용
            source: "/admin/:path*",
            headers: [
              {
                key: "Content-Security-Policy",
                value:
                  "default-src 'self'; script-src 'self' https://trusted.com;",
              },
            ],
          },
        ];
      },
    };

    module.exports = nextConfig;
    ```

    ```js
    // 1. 지시어별로 깔끔하게 정리
    const cspSettings = {
      "default-src": ["'self'"],
      "script-src": ["'self'", "'unsafe-inline'", "https://analytics.google.com"],
      "style-src": ["'self'", "'unsafe-inline'"],
      "img-src": ["'self'", "data:", "https://images.unsplash.com"],
      "font-src": ["'self'", "https://fonts.gstatic.com"],
      "object-src": ["'none'"],
    };

    // 2. 문자열로 변환 ("default-src 'self'; script-src 'self' ...")
    const cspString = Object.entries(cspSettings)
      .map(([key, values]) => `${key} ${values.join(" ")}`)
      .join("; ");

    module.exports = {
      async headers() {
        return [
          {
            source: "/(.*)",
            headers: [
              {
                key: "Content-Security-Policy",
                value: cspString,
              },
            ],
          },
        ];
      },
    };
    ```
*   **NGINX에서 보안헤더 설정**

    * 정적인 파일을 제공하는 NGINX의 경우 경로별로 add\_header지시자를 사용해 원하는 응답 헤더 추가
    * nginx.conf 또는 sites-available의 설정 파일 내 server 블록이나 특정 location 블록에 추가합니다.

    ```nginx

    server {
      listen 80;
      server_name yoursite.com;

      # [전역 설정] 모든 응답에 공통으로 적용될 보안 헤더
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;

      # [경로별 설정] 정적 자산(이미지, JS, CSS) 경로
      location /static/ {
          alias /data/www/static/;
          # 정적 파일은 스크립트 실행이 필요 없으므로 더 엄격한 CSP 적용 가능
          add_header Content-Security-Policy "default-src 'self'; script-src 'none';" always;
      }

      # [경로별 설정] API 요청 경로
      location /api/ {
          proxy_pass http://backend_server;
          # API 응답에는 브라우저 렌더링 관련 헤더보다 데이터 보호 헤더 위주로 설정
          add_header X-XSS-Protection "1; mode=block" always;
      }
    }

    ```
* 현재 서비스 중인 웹사이트 보안 헤더 확인 https://securityheaders.com

### 취약점이 있는 패키지의 사용을 피하자

* npm 프로젝트 구동을 위해서는 수많은 패키지에 의존해야 한다.
* **의존해야하는 패키지 목록**은 기본적으로 package.json의 dependencies에 나열
* package-lock.json에는 이 **package.json에 의존하는 또 다른 패키지들**이 명시돼 있다.
* 이 패키지들은 버전에 따라 보안 취약점이 존재할수도 있다.
  * package-lock.json의 모든 의존성을 파악하는 것은 불가능하다. → 깃헙 Dependabot 이 발견한 취약점은 필요하다면 빠르게 업데이트 조치.
  * 업데이트로 인해 웹사이트 기능에 문제가 생기지 않도록 적절한 테스트 코드도 준비
* https://security.snyk.io/ 를 방문해 사용하는 **패키지 이름으로 검색해보면 현재 라이브러리 취약점**을 한눈에 파악할 수 있으므로 패키지 보안 이슈를 추적하는데 도음

### OWASP Top 10 (p900-902)

* Open Worldwide (Web) Application Security Project. 오픈 소스 웹 애플리케이션 보안 프로젝트
* 주로 웹에서 발생할 수 잇는 정보 노출, 악성 스크립트, 보안 취약점 등을 연구하며 주기적으로 10대 웹 애플리케이션 취약점을 공개.
* [2025 OWASP Top 10](https://owasp.org/Top10/2025/)

### 기타

* dangerouslySetInnerHTML: \
  **기본적으로 리액트는 XSS를 방어하기 위해 이스케이프 작업이 존재한다.** \
  즉, HTML에 직접 표시되는 textContent와 HTML속성 값에 대해서는 리액트가 기본적으로 이스케이프 작업을 해준다. **그러나 dangerouslySetInnerHTML 이나 props로 넘겨받는 값의 경우**, 개발자의 활용도에 따라 원본 값이 필요할 수 있기 때문에 **이런 작업이 수행되지 않는다.**
* Sanitize vs Escape
  * 목적은 비슷하지만 동작 방식과 결과물에서 큰 차이가 있습니다. Escape은 '포장' Sanitize는 '세척'
  * Escape
    * 데이터를 안전한 문자열로 치환하여, 브라우저가 이를 코드가 아닌 단순 텍스트로 인식하게 만드는 기법
    * 특수 기호(<>, &, ", ')를 HTML 엔티티(Entity)로 바꿉니다. 리액트는 기본적으로 중괄호{ } 안에 넣는 모든 데이터를 자동으로 Escape 처리해 줍니다.
  * Sanitize
    * 위험한 태그나 속성을 제거하거나 선별적으로 허용하여 HTML의 형식을 유지하면서 안전하게 만드는 기법입니다.
    * "화이트리스트(Allow list)"를 기반으로 작동합니다.
* URI vs URL
  * URI (**Uniform Resource Identifier**)
    * 통합 자원 식별자. 가장 넓은 개념으로, 인터넷상의 자원을 식별할 수 있는 모든 이름을 통칭합니다.
  * URL (**Uniform Resource Locator**)
    * **자원 위치 식별자**. URI의 가장 흔한 형태입니다. 자원을 식별하기 위해 그 자원이 어디에 있는지(위치)를 알려줍니다.
* 서브도메인
  * 메인 도메인 앞에 마침표(.)로 구분되어 붙는 이름입니다. 하나의 도메인을 목적에 따라 여러 구역으로 나누기 위해 사용합니다.
    * 메인 도메인(Root): naver.kr
    * 서브 도메인: www., blog., mail., news. 등
* a태그의 ping 속성
  * 사용자가 해당 링크를 클릭했을 때, 브라우저가 특정 URL로 짧은 알림(POST 요청)을 보내도록 만드는 기능
  * **사용자가 어디를 클릭했는지 추적(Tracking)하거나 분석하기 위한 용도**로 쓰입니다.
* Snyk(스니크)는 프로젝트에서 사용하는 오픈소스 라이브러리(패키지)들의 취약점을 자동으로 검사해 주는 도구
