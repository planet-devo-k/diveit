# Takeaways

<table><thead><tr><th width="117">구분</th><th width="266">도구</th><th>역할 설명</th></tr></thead><tbody><tr><td><strong>트랜스파일러</strong></td><td>Babel, SWC</td><td>최신 문법(ES6+), TypeScript, JSX를 브라우저가 해석 가능한 코드로 변환</td></tr><tr><td><strong>번들러</strong></td><td>Webpack, Vite(esbuild, rollup), Turbopack</td><td>분산된 수많은 파일(JS, CSS, Image 등)을 하나로 묶어 네트워크 요청을 최적화</td></tr></tbody></table>

* Babel, Webpack & CRA
  * CRA (Create React App): 웹팩과 바벨을 내부에 숨겨서 리액트 환경을 쉽게 구축해주던 도구입니다.
* Vite
  * 관계: 웹팩의 느린 속도를 해결하기 위해 등장한 차세대 번들러입니다.
  * 특징: 개발 모드에서 번들링 과정을 생략하고 브라우저의 Native ESM을 활용하여 즉각적인 실행 속도를 제공합니다.
* Turbopack
  * 관계: 웹팩 창시자가 Vercel에서 만든 **'웹팩의 Rust 버전'**
  * 특징: 고도의 캐싱 메커니즘과 Rust의 성능을 결합하여 대규모 프로젝트에서 Vite보다 더 빠른 속도를 목표로 합니다. 현재는 Next.js 환경에 최적화되어 있습니다.
* **SWC** (Speedy Web Compiler)
  * 관계: 기존의 Babel을 대체하기 위해 등장했습니다.
  * 특징: JavaScript가 아닌 Rust 언어로 작성되어 Babel보다 최대 70배 빠릅니다.
  * 현황: 현재 Next.js, Vite 등 최신 도구들이 기본 컴파일러로 채택하고 있습니다.
* 도구 진화
  * 과거: Webpack + Babel (표준, 하지만 느림)
  * 현재 (전환기): Webpack + SWC (기존 프로젝트의 성능 개선)
  * 현재 (대세): Vite + esbuild/Rollup (신규 프로젝트의 표준)
  * 미래: Turbopack / Vite (Rust 기반의 완전한 성능 최적화)
* esbuild와 Rollup: Vite의 두 엔진
  * Vite는 특이하게 상황에 따라 두 개의 다른 도구를 사용합니다. Vite는 개발할 때는 esbuild로 속도를 챙기고, 배포할 때는 Rollup으로 안정성을 챙기는 전략을 씁니다.
  * esbuild (개발 모드용)
    * 역할: 프로젝트를 시작할 때 수많은 외부 라이브러리(node\_modules)를 미리 처리(Pre-bundling)하는 역할을 합니다.
    * 특징: Go 언어로 작성되어 압도적으로 빠릅니다. 웹팩보다 100배 이상 빠르다고 평가받기도 합니다.
    * 단점: 코드 압축(Minification)이나 트리 쉐이킹(Tree Shaking) 같은 세밀한 최적화 기능이 Rollup에 비해 부족합니다.
  * Rollup (배포 빌드용)
    * 역할: 실제 서비스에 올릴 파일을 만들 때(Build) 사용합니다.
    * 특징: 코드를 아주 작고 효율적으로 만드는 데 특화되어 있습니다.
    * 현황: 결과물이 깔끔하고 성능이 좋아서 라이브러리 제작자들이 가장 선호하는 번들러입니다.
*   Vite vs Turbopack

    <table><thead><tr><th width="165.5999755859375">비교 항목</th><th>Vite</th><th>Turbopack</th></tr></thead><tbody><tr><td><strong>주도 기업</strong></td><td>Evan You (Vue 창시자)</td><td>Vercel (Next.js 제작사)</td></tr><tr><td><strong>핵심 엔진(번들러)</strong></td><td>esbuild + Rollup</td><td>Rust로 만든 터보팩 (자체 제작 엔진)</td></tr><tr><td><strong>작동 방식</strong></td><td><strong>Native ESM 기반</strong> (필요한 파일만 그때그때 브라우저에 전달)</td><td><strong>Incremental Computing</strong> (한 번 계산한 건 절대 다시 안 함)</td></tr><tr><td><strong>최적화 타겟</strong></td><td>범용 웹 프로젝트 (React, Vue, Svelte 등)</td><td>Next.js 프로젝트 (현재 기준 최적화 타겟)</td></tr></tbody></table>

    *   엔진 = 번들러 기능을 수행하는 핵심 본체

        <table><thead><tr><th width="155.39996337890625">구분</th><th>대상</th><th>특징</th></tr></thead><tbody><tr><td><strong>엔진이자 번들러</strong></td><td><strong>esbuild / Rollup / Turbopack</strong></td><td>스스로 파일을 분석하고 묶는 핵심 알고리즘(엔진)을 보유함.</td></tr><tr><td><strong>빌드 도구 (시스템)</strong></td><td><strong>Vite / CRA</strong></td><td>위 엔진들을 가져와서 개발자가 쓰기 편하게 <strong>환경을 만들어줌.</strong></td></tr></tbody></table>
    * Vite는 브라우저가 직접 JS 모듈을 불러올 수 있는 기능(Native ESM)을 활용합니다. 그래서 번들링 과정 자체를 거의 생략해버려 초기 구동이 빠릅니다.
    * Turbopack은 "모든 것을 Rust로 만들어 가장 빠른 번들러를 만들겠다"는 목표를 가집니다. 특히 규모가 매우 큰 프로젝트에서 수정된 부분만 기가 막히게 찾아내서 반영하는 능력이 뛰어납니다.

## app 디렉터리의 등장

* Next.js 13버전 이전까지(12까지) 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 \_document, \_app
* 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했다. → 각 페이지 별 서로 다른 레이아웃을 유지할 수 있는 여지 부족 → 13부터 app 레이아웃
  * \_document
    * `<html>` `<body>` 수정
    * 서버사이드 렌더링 시 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용
    * 오직 서버에서만 작동하므로 onClick같은 이벤트 핸들러를 붙이거나 클라이언트 로직을 붙이는 것 금지
  * \_app
    * 페이지를 초기화하기 위한 용도로 사용
    * 페이지 변경 시 유지하고 싶은 레이아웃
    * 페이지 변경 시 상태 유지
    * componentDidCatch를 활용한 에러 핸들링
    * 페이지간 추가적인 데이터 삽입
    * global CSS 주입

### 라우팅

#### 라우팅 정의

* 기본적으로 Next.js의 라우팅은 **파일시스템(디렉토리 구조)** 기반
* 라우팅 디렉터리 변경 pages/ → app/
* 파일명으로 라우팅 하는 것 불가능
  * app/ 내부 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.
  * **app/ 내부에서 가질 수 있는 파일명은 예약어로 제한**된다.

<table><thead><tr><th width="185.79998779296875">버전</th><th width="322.5999755859375">실제 파일 위치</th><th>주소 변환 및 특징</th></tr></thead><tbody><tr><td>v12 (File-based)</td><td><code>/pages/dashboard/profile.tsx</code></td><td>파일명 <code>profile</code>이 주소가 됨</td></tr><tr><td>v12 (Index-based)</td><td><code>/pages/dashboard/profile/index.tsx</code></td><td><code>index</code>는 생략되고 폴더명이 주소가 됨</td></tr><tr><td><strong>v13+ (Folder-based)</strong></td><td><code>/app/dashboard/profile/page.tsx</code></td><td>파일명은 무시되고 <strong>폴더명</strong>이 주소가 됨</td></tr><tr><td><strong>v13+ (Error Case)</strong></td><td><code>/app/dashboard/profile/about.tsx</code></td><td><code>page.tsx</code>가 아니므로 <strong>404 에러</strong> 발생</td></tr></tbody></table>

#### layout.js

* 루트 layout은 모든 페이지에 영향을 미치는 공통 레이아웃
  *   **CSS-in-JS 초기화도 여기서 적용**

      * App Router는 **모든 것이 서버 컴포넌트가 기본**이므로, CSS-in-JS를 쓰려면 스타일을 관리할 **스타일 Registry를 하나 만들어서 레이아웃에 감싸줘야 합니다.**
      * **useServerInsertedHTML**: useInsertionEffect를 기반으로 하는 훅으로, CSS-in-JS 라이브러리 같이 서버에서 추가해야할 HTML을 넣는 용도로 만들어짐
      * CSS-in-JS는 자바스크립트가 실행되어야 스타일이 생성됩니다. 하지만 서버 사이드 렌더링(SSR) 시에는 브라우저가 아니므로 자바스크립트가 미리 실행되지 않죠.
      * 그래서 "**서버에서 미리 스타일을 다 읽어서 HTML 파일의 안에 텍스트로 미리 넣어두기 위해**" 이런 초기화 작업이 필요한 것입니다.
      * 이렇게 안 하면 페이지 접속 시 스타일이 없는 생(生) HTML이 잠깐 보였다가 스타일이 뒤늦게 적용되는 '깜빡임 현상'이 발생합니다.

      ```tsx
      // lib/registry.tsx
      "use client"; 

      import React, { useState } from "react";
      import { useServerInsertedHTML } from "next/navigation";
      import { ServerStyleSheet, StyleSheetManager } from "styled-components";

      export default function StyledComponentsRegistry({
        children,
      }: {
        children: React.ReactNode;
      }) {
        const [styledComponentsStyleSheet] = useState(
          () => new ServerStyleSheet()
        );

        useServerInsertedHTML(() => {
          const styles = styledComponentsStyleSheet.getStyleElement();
          styledComponentsStyleSheet.instance.clearTag();
          return <>{styles}</>;
        });

        return (
          <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
            {children}
          </StyleSheetManager>
        );
      }
      ```

      ```tsx
      // app/layout.tsx
      // Root layout에 적용
      import StyledComponentsRegistry from "./lib/registry";

      export default function RootLayout({
        children,
      }: {
        children: React.ReactNode;
      }) {
        return (
          <html>
            <body>
              {/* 모든 페이지에 스타일 설정을 적용함 */}
              <StyledComponentsRegistry>{children}</StyledComponentsRegistry>
            </body>
          </html>
        );
      }
      ```
  * 과거에는 \_document 에서 CSS-in-JS의 스타일을 모두 모은 다음 서버 사이드 렌더링 시에 이를 함께 렌더링하는 방식으로 적용
  * 즉, \_document에서 추가하던 서버 사이드 스타일을 이제 루트의 layout에서 집어넣게끔 변경
* 해당 폴더의 레이아웃은 그 하위 폴더 및 주소에 모두 영향을 미친다.
* 많은 개발자들을 헷갈리게 만들었던 \_app, \_document를 layout으로 대체
  * 기존에는 애플리케이션의 , 에 무언가 스타일을 추가하는 등의 작업을 하려면 \_document를 사용하고 , `<Html>`,`<Body>`,`<Head>` 처럼 Next.js에서 제공하는 태그를 사용해야 했다.
  * 이제는 HTML에서 기본으로 제공하는 `<html>`등의 태그를 추가, 수정함으로써 별도로 import하는 번거로움이 사라짐
* 레이아웃 이외의 다른 목적으로는 사용 불가
* children을 props로 받아서 렌더링해야한다.
* **내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.**
* 내부에서도 API요청과 같은 비동기 작업을 수행할 수 있다.

#### page.js

* **page가 받는 props**
  * **params(optional)**: **\[...id]와 같은 동적 라우트 파라미터**를 사용할 경우, 해당 파라미터에 값이 들어온다.
  * **searchParams**
    * URL에서 ?a=1과 같은 **URLSearchParams**를 의미
    * ?a=1\&b=2로 접근할 경우 searchParams에는 {a:'1', b:'2'}라는 자바스크립트 객체 값이 오게 된다.
    * 이 값은 layout에서는 제공되지 않는다. layout은 페이지 탐색 중에는 리렌더링을 수행하지 않기 때문이다. 즉, 같은 페이지에서 searchParams만 다르게 라우팅을 시도하는 경우, layout을 리렌더링하는 것은 불필요하기 때문이다. \
      만약 searchParams에 의존적인 작업을 해야하면 반드시 page 내부에서 수행
  * 마찬가지로 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
  * **내부에 반드시 export default로 내보내는 컴포넌트가 있어야 한다.**

#### error.js

* 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트
* 라우팅별로 서로 다른 에러 UI를 렌더링
* error가 받는 props
  * error: Error 객체 (에러 정보를 담고 있다)
  * reset: ()=> void (에러 바운더리를 초기화)
* 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 **클라이언트 컴포넌트여야 한다.**
* error 컴포넌트는 같은 수준의 layout에서 에러가 발생할 경우 해당 error컴포넌트로 이동하지 않는다. → 상위 컴포넌트의 error를 사용 또는 app 루트 에러 처리를 담당하는 app/global-error.js 페이지 생성

#### not-found.js

* 404 페이지 렌더링
* 전체 404 app/not-found.js
* 서버 컴포넌트로 구성

#### loading.js

* Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용
* 'use client' 지시자를 사용해 클라이언트에서 렌더링 되게 할수도 있다.

#### route.js

* /pages/api → /app/api를 기준으로 디렉터리 라우팅 지원
* /api에 대해서도 파일명 라우팅이 사라지고 **디렉터리가 라우팅 주소를 담당**. **파일명은 route.js로 통일**
* **route.ts파일 내부에** REST API의 **get, post 같은 메서드명을 예약어로 선언**해 두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다. app/api 외에 다른 곳에서 선언해도 작동한다.
* 라우팅 명칭에 자유도가 생긴 대신 <mark style="background-color:yellow;">**route.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없다.**</mark>
  * Next.js의 라우팅은 **폴더 주소**가 기준입니다. 만약 `/app/dashboard` 폴더 안에 두 파일이 모두 있다면 사용자가 `site.com/dashboard`에 접속했을 때
    * Next.js의 고민: "리액트 컴포넌트로 화면을 그려줘야 하나? 아니면 GET 요청으로 API 응답을 줘야 하나?"
    *   이 충돌을 방지하기 위해 Next.js는 한 폴더에 두 파일을 동시에 두는 것을 금지합니다.

        <table><thead><tr><th width="115.4000244140625">구분</th><th>page.tsx</th><th>route.ts</th></tr></thead><tbody><tr><td><strong>반환값</strong></td><td><strong>HTML</strong> (사용자가 보는 화면)</td><td><strong>Data</strong> (JSON, Text 등 API 응답)</td></tr><tr><td><strong>응답 형식</strong></td><td><code>text/html</code></td><td><code>application/json</code> 등</td></tr><tr><td><strong>상호 충돌</strong></td><td>브라우저가 접속했을 때 화면을 보여줄지, 데이터를 줄지 결정 불가</td><td>동일 경로에서 두 파일이 있으면 라우팅 시스템이 혼란에 빠짐</td></tr></tbody></table>
* route의 함수들이 받는 파라미터
  *   `route.ts` 파일 내부에서 정의하는 **HTTP 메서드 이름의 함수들**을 말합니다. 이 함수명들은 예약어이며, **반드시 대문자**로 작성해야 합니다.

      <table><thead><tr><th width="117.20001220703125">메서드</th><th width="123.79998779296875">역할</th><th>코드 예시 (route.ts 내부)</th></tr></thead><tbody><tr><td><strong>GET</strong></td><td>데이터 조회</td><td><code>export async function GET(request) { ... }</code></td></tr><tr><td><strong>POST</strong></td><td>데이터 생성</td><td><code>export async function POST(request) { ... }</code></td></tr><tr><td><strong>PUT</strong></td><td>데이터 수정</td><td><code>export async function PUT(request) { ... }</code></td></tr><tr><td><strong>DELETE</strong></td><td>데이터 삭제</td><td><code>export async function DELETE(request) { ... }</code></td></tr></tbody></table>
* **request**: **NextRequest 객체**.
  * fetch의 Request를 확장한 Next.js만의 Request.
  * 이 객체에는 API요청과 관련된 cookie, headers 등 뿐만 아니라 nextUrl 같은 주소 객체도 확인할 수 있다.
* **context**: params만을 가지고 있는 객체
  * 동적 라우팅 파라미터 객체가 포함돼 있다.

## 리액트 서버 컴포넌트

* 서버사이드 렌더링과 완전히 다른 개념

### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

* 리액트의 모든 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드 처리가 이뤄진다.
  * 웹사이트 방문 → 리액트 실행에 필요한 코드 다운로드 → 리액트 컴포넌트 트리 생성 → DOM에 렌더링
  * SSR의 경우 미리 서버에서 DOM 생성 → 클라이언트에서는 이렇게 만들어진 DOM을 기준으로 하이드레이션 진행 → 이후 브라우저는 상태를 추적, 이벤트 핸들러를 DOM에 추가, 응답에 따라 렌더링 트리 변경
* **리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 한계점**
  * 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다
    * sanitize-html: 게시판 등 사용자가 작성한 HTML에 위험한 태그를 제거하기 위해 사용되는 npm 라이브러리
    * 클라이언트인 브라우저에서 해당 라이브러리를 다운로드, 실행
    * 어느 정도 규머 있는 웹 애플리케이션을 작성하다 보면 브라우저 환경에서 타사 라이브러리 이용은 피할 수 없다. 그리고 이는 그만큼 사용자 기기의 부담.
    * 만약 이 컴포넌트를 서버에서만 렌더링하고 클라이언트는 결과만 받는다면
      * sanitize-html은 서버만 가지고 있고 서버에서는 해당 라이브러리를 실행한 결과와 컴포넌트 렌더링 결과물만 클라이언트에 제공
      * 클라이언트는 무거운 sanitize-html 라이브러리를 다운로드해 실행하지 않고도 사용자에게 보여주고 싶은 컴포넌트를 렌더링할 수 있다.
  * **백엔드 리소스에 대한 직접적인 접근이 불가능하다**
    * 클라이언트에서 REST API로 백엔드 데이터에 접근: 백엔드에서 항상 클라이언트에서 데이터를 접근하기 위한 방법을 마련해야한다는 불편함이 있다.
    * 만약 클라이언트에서 직접 백엔드 데이터 베이스에 접근 또는 백엔드 파일 시스템에 접근하는 등 원하는 데이터를 가져올 수 있다면
      * 클라이언트에 데이터를 제공하기 위한 수고로움이 줄어든다.
      * 백엔드에 접근할 수 있는 단계가 하나 줄어든 셈이므로 성능 이점
  * **자동 코드 분할(code split)이 불가능하다.**
    * code split: 하나의 거대한 코드 번들 대신, 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩함으로서 앱을 초기화하는 속도를 높여주는 기법
      * 일일이 lazy로 감싸는 것을 기억해야한다.
      * 해당 컴포넌트가 호출되고 **if문**을 판단하기 전까지 어떤 지연 로딩한 컴포넌트를 불러올 지 결정할 수 없다. 이는 **지연로딩으로 인한 성능 이점을 상쇄**.
    * 만약 코드 분할을 서버에서 자동으로 수행해 준다면
      * 어떤 컴포넌트를 미리 불러와서 클라이언트에 내려줄지 서버에서 결정
  * **연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.**
    * 연쇄 요청(Waterfall): 하나의 데이터 요청이 끝나야만 그다음 데이터 요청이 시작될 수 있는 순차적 지연 현상
    * 하나의 요청으로 컴포넌트가 렌더링되고, 또 그 컴포넌트의 렌더링 결과로 또 다른 컴포넌트들을 렌더링하는 시나리오.
      * 최초 컴포넌트의 요청과 렌더링이 끝나기 전까지는 하위 컴포넌트의 요청과 렌더링이 끝나지 않는다는 큰 단점이 있다.
      * 또한 서버에 요청하는 횟수도 늘어난다.
      * 부모 컴포넌트의 요청과 렌더링이 결정되기 전까지 그 부모 컴포넌트의 결과물에 의존하는 하위 컴포넌트들의 서버 요청이 지연되고 아직 렌더링될 준비가 되지 않았음을 나타내는 불필요한 렌더링까지 발생한다.
    * 이러한 작업을 모두 서버에서 실행하면
      * 데이터를 불러오고 컴포넌트를 렌더링하는 것이 모두 서버에서 이뤄지므로 클라이언트에서 서버로 요청함으로써 발생하는 지연을 줄일 수 있다.
      * 클라이언트에서는 반복적으로 요청을 수행할 필요가 없다.
      * 서버에서는 필요에 따라 백엔드 데이터에 접근하거나 지속적으로 데이터를 불러옴으로써 클라이언트에서보다 더 효율적으로 컴포넌트를 렌더링할 수 있게 된다.
  * **추상화에 드는 비용이 증가한다.**
    * 템플릿 언어: HTML 에 특정 언어 문법을 집어넣어 사용할 수 있는 것. 템플릿 언어는 HTML에서 할 수 없는 for문이나 if문 등을 처리할 수 있지만 그 밖의 복잡한 추상화나 함수 사용은 어렵다.
    * 추상화가 복잡해 질수록 코드 양이 많아지고 런타임 시에는 오버헤드가 발생한다.
    * 복잡한 추상화에 따른 결과물을 연산하는 작업을 서버에서 수행하면
      * 서버에서 클라이언트로 전송되는 내용을 서버에서 미리 다 계산해서 내려주면 클라이언트에서는 복잡한 작업을 하지 않아도 되므로 속도가 빨라짐
      * 코드 추상화에 따른 비용은 서버에서만 지불
* **성능을 위해 클라이언트 역할을 일부 희생 vs 다양한 사용자 경험을 위해 일부 성능을 희생하더라도 클라이언트에서 다양한 작업 처리**
  * 서버사이드 렌더링, 클라이언트 사이드 렌더링은 이 문제를 해결하기에 조금씩 아쉬움이 각각 있다.
  * **SSR은 정적 콘텐츠를 빠르게 제공하고 서버에 있는 데이터에 손쉽게 접근. 반면 인터렉션에 따른 다양한 사용자 경험 제공 어려움**
    * 기존 SSR은 단순히 HTML만 미리 그려주는 서비스에 가깝다.
    * 번들 크기 문제: 기존 SSR은 서버에서 HTML을 그리더라도, 결국 브라우저에서 리액트가 다시 돌아가야 하므로(`Hydration`), 사용된 모든 라이브러리(예: `sanitize-html`)를 브라우저가 똑같이 다운로드해야 합니다. 즉, **번들 크기를 0으로 만들 수 없습니다.**
    * 연쇄 요청 문제: 기존 SSR은 페이지 단위로만 작동합니다. 페이지 안에서 컴포넌트가 렌더링되다가 데이터를 또 불러와야 하면, 결국 클라이언트에서 다시 서버로 API를 요청하는 '연쇄 요청(Waterfall)' 현상이 그대로 발생합니다.
  * CSR은 인터랙션에 따라 다양한 사용자 경험 제공 반면 서버에 비해 느리고 데이터를 가져오는게 어려움
  * 리액트 서버 컴포넌트: 두 구조의 장점을 모두 취하고자 하는 것
* 위 문제들을 해결하기 위해 서버에서 렌더링을 해야 하는 것이 맞다.
* 하지만 과거의 서버 사이드 렌더링(SSR) 방식은 'HTML 미리 보기' 정도만 해주는 반쪽짜리 해결책이었고, 그 한계를 완전히 극복하기 위해 <mark style="background-color:yellow;">**리액트 컴포넌트가 작동하는 방식 자체를 서버 중심으로 옮겼다.(RSC)**</mark>
* 글에서 "만약 이 작업을 서버에서 수행하면\~"이라고 말하는 해결책들은 **서버 컴포넌트(React Server Components)**.

<table><thead><tr><th width="117">구분</th><th width="294.20001220703125">기존 SSR</th><th>서버 컴포넌트 (RSC)</th></tr></thead><tbody><tr><td><strong>렌더링 주체</strong></td><td>서버에서 HTML 생성 후 전달</td><td><mark style="background-color:yellow;">서버에서 <strong>컴포넌트 단위</strong>로 실행</mark></td></tr><tr><td><strong>JS 번들 포함</strong></td><td><strong>모든 컴포넌트 코드가 브라우저로 전송됨</strong></td><td><mark style="background-color:yellow;">서버 전용 컴포넌트 코드는 <strong>전송 안 됨</strong></mark></td></tr><tr><td><strong>하이드레이션</strong></td><td>전체 페이지에 대해 수행 (무거움)</td><td><strong>필요한 부분만 선택적 수행</strong> (가벼움)</td></tr><tr><td><strong>데이터 접근</strong></td><td><code>getServerSideProps</code> 등에서만 가능</td><td><mark style="background-color:yellow;"><strong>모든 서버 컴포넌트</strong>에서 직접 DB 접근 가능</mark></td></tr></tbody></table>

<table><thead><tr><th width="166">문제점</th><th>서버 컴포넌트(RSC)의 해결 방식</th></tr></thead><tbody><tr><td><strong>라이브러리 번들 부담</strong></td><td><code>sanitize-html</code>을 서버에서만 돌리고 결과(텍스트)만 전송함. <br>브라우저는 라이브러리를 다운로드하지 않음.</td></tr><tr><td><strong>백엔드 접근 불가능</strong></td><td>서버 컴포넌트 내에서 <code>sql</code> 쿼리를 직접 작성해 DB에서 데이터를 가져옴.</td></tr><tr><td><strong>자동 코드 분할</strong></td><td>서버가 미리 어떤 컴포넌트가 필요한지 계산해서 필요한 코드만 골라 내려줌.</td></tr><tr><td><strong>연쇄 요청 지연</strong></td><td>서버 안에서 데이터 로딩과 렌더링을 한 번에 처리하므로 <br>클라이언트-서버 간의 왔다 갔다 하는 지연이 없음.</td></tr></tbody></table>

* **망의 속도**가 압도적으로 다르다.
  * **클라이언트-서버** 간 (인터넷): 사용자의 무선 인터넷이나 LTE 환경을 타고 데이터가 오갑니다. 한 번 요청하고 응답받는 데 100ms가 걸린다면, 3번 연쇄 요청 시 300ms가 소요됩니다.
  * **서버-DB** 간 (내부망): 서버 컴퓨터와 데이터베이스 컴퓨터는 보통 같은 데이터 센터 안에 \
    '광케이블'(Optical Fiber Cable)로 연결되어 있습니다. 한 번 요청에 1ms도 안 걸리는 경우가 많습니다. 3번 연쇄 요청을 해도 3ms 내외로 끝납니다.
* 렌더링을 한 번에 처리
  * 클라이언트 중심 리액트에서는 다음과 같은 비효율이 발생: \
    요청 → 대기 → 응답 → 렌더링(자식 발견) → 다시 요청 → 대기...
  * 반면 서버 컴포넌트는 서버 내부에서 이 작업을 수행하므로:
    * 서버가 코드를 읽다가 "어? 데이터가 필요하네?" 하면 바로 옆에 있는 DB에서 **빛의 속도로** 가져옵니다.
    * 그 데이터를 가지고 즉시 렌더링을 계속 진행합니다.
    * 이 모든 과정이 끝난 최종 결과물(HTML/결과 값)만 딱 한 번 클라이언트로 보냅니다.

### 서버 컴포넌트란?

#### 서버 컴포넌트

* 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 **서버와 클라이언트 모두에서** 컴포넌트를 렌더링할 수 있는 기법
  * 서버에서 할 수 있는 일은 서버가 처리하게 두고 서버가 할 수 없는 나머지 작업은 클라이언트(브라우저)가 수행. 즉, 일부 컴포넌트는 클라이언트에서, 일부 컴포넌트는 서버에서 렌더링.
  * 모든 컴포넌트는 서버 컴포넌트가 될수도 있고 클라이언트 컴포넌트가 될 수도 있다.
  * 컴포넌트 트리에는 클라이언트 컴포넌트와 서버 컴포넌트가 혼재 → ReactNode 사용해 이런 구조가 가능하게 되었다.
* 요청이 오면 그 순간 서버에서 딱 한번 실행될 뿐이므로 상태를 가질 수 없다.
  * 상태를 가질수 있는 훅을 사용할 수 없다. (useState, useReducer 등)
* 한번 렌더링되면 그걸로 끝이기 때문에 렌더링 생명주기도 사용할 수 없다.
  * **useEffect, useLayoutEffect 사용 불가**
* effect나 state에 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 사용 가능
* 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 **DOM API나 window, document 등에 접근 불가**
*   데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근할 수 있다. \
    컴포넌트 자체가 async한 것이 가능하다.

    * 서버 컴포넌트는 컴포넌트 함수 자체를 async로 만들 수 있습니다. 덕분에 별도의 상태 관리(useState)나 useEffect 없이 바로 데이터를 뿌릴 수 있습니다.
    * 클라이언트 컴포넌트는 함수 자체를 async로 선언하는 것이 불가능. \
      클라이언트에서도 데이터를 가져올 때 `async/await`을 쓰지만, 그 위치와 방식이 다릅니다.

    <table><thead><tr><th width="118">구분</th><th>클라이언트 컴포넌트 (Client)</th><th>서버 컴포넌트 (Server)</th></tr></thead><tbody><tr><td><strong>함수 선언</strong></td><td><code>function MyComp() { ... }</code> (일반 함수)</td><td><code>async function MyComp() { ... }</code> (<strong>비동기 함수</strong>)</td></tr><tr><td><strong>사용 위치</strong></td><td><strong>함수 내부의 특정 로직</strong> (useEffect 등)</td><td><strong>컴포넌트 함수 자체</strong></td></tr><tr><td><strong>기다리는 방식</strong></td><td><strong>일단 화면을 그리고(Render), 나중에 데이터를 채움</strong></td><td><mark style="background-color:yellow;"><strong>서버에서 데이터를 다 가져올 때까지 렌더링을 기다림</strong></mark></td></tr></tbody></table>

    ```tsx
    "use client";

    export default function ClientPage() {
      // 컴포넌트 자체는 일반 함수!
      const [data, setData] = useState(null);

      // 데이터 가져오기 로직은 async로 작성 가능
      const fetchData = async () => {
        const res = await fetch("/api/data"); // 여기서 async/await 사용
        const result = await res.json();
        setData(result);
      };

      return <div>{data ? data.title : "로딩 중..."}</div>;
    }
    ```

    ```tsx
    // app/page.tsx (서버 컴포넌트)

    // 컴포넌트 이름 앞에 async가 붙음!
    export default async function ServerPage() {
      // 컴포넌트 안에서 바로 await으로 데이터를 가져옴
      const res = await fetch(
        "[https://api.example.com/data](https://api.example.com/data)"
      );
      const data = await res.json();

      return <div>{data.title}</div>; // 로딩 중 처리가 필요 없음 (이미 다 가져옴)
    }
    ```
* **다른 서버 컴포넌트를 렌더링**하거나 div, span, p 같은 요소를 렌더링하거나, **클라이언트 컴포넌트를 렌더링**할 수 있다.
* Next.js의 App Router 구조에서 **모든 요청의 시작점(Root)은 항상 '서버 컴포넌트'여야만 합니다.**
  *   리액트(CSR) vs Next.js App Router(RSC) 시작점 비교

      <table><thead><tr><th width="128.4000244140625">구분</th><th>전통적 리액트 (CSR)</th><th>Next.js App Router (RSC)</th></tr></thead><tbody><tr><td><strong>시작점 (Root)</strong></td><td><strong>클라이언트 컴포넌트</strong> (<code>index.js</code>, <code>App.js</code>)</td><td><strong>서버 컴포넌트</strong> (<code>layout.tsx</code>, <code>page.tsx</code>)</td></tr><tr><td><strong>최초 전송물</strong></td><td>빈 뼈대 HTML + 거대한 JS 번들 파일</td><td>데이터가 채워진 <strong>완성된 HTML</strong></td></tr><tr><td><strong>실행 위치</strong></td><td>사용자의 브라우저</td><td>호스팅 서버 (Node.js 환경)</td></tr><tr><td><strong>데이터 접근</strong></td><td>브라우저에서 API 요청으로 가져옴</td><td>서버에서 DB에 직접 접근 가능</td></tr></tbody></table>
  * 원래 리액트(CSR)의 시작 방식
    * 일반적인 리액트 앱은 시작부터 끝까지 전부 클라이언트 컴포넌트
      1. 서버는 아주 단순한 HTML 파일(`id="root"`만 있는 파일)을 던져줍니다.
      2. 브라우저가 이 파일을 받고 나서, 연결된 자바스크립트(리액트 전체 코드)를 다운로드합니다.
      3. 브라우저 안에서 리액트가 `App.js`부터 실행합니다.
      4. 결과: 사용자는 자바스크립트를 다 받을 때까지 흰 화면을 보게 됩니다.
  * Next.js App Router
    * Next.js는 이 순서를 완전히 뒤집어서 **서버를 시작점**으로 만들었습니다.
      1. 사용자가 접속하면 서버에 있는 **서버 컴포넌트**가 즉시 실행됩니다.
      2. 서버에서 DB도 조회하고, 복잡한 계산도 다 해서 글자가 다 적힌 HTML을 만듭니다.
      3. 브라우저는 받자마자 화면을 보여줍니다. (자바스크립트 실행 전에도 화면이 보임)
      4. 결과: 사용자 체감 속도가 비약적으로 빨라지고, 검색 엔진(SEO) 최적화가 쉬워집니다.
  * 왜 리액트는 시작점을 서버로 옮겼을까?
    * **JS 번들 비대화:** 기능이 많아질수록 브라우저가 다운로드할 파일이 너무 커집니다.
    * **보안 취약:** DB 비밀번호나 민감한 로직이 브라우저 코드에 노출될 위험이 큽니다.
    * **연쇄(Waterfall) 요청:** 화면을 그리고 나서야 데이터를 가져오니 로딩 스피너를 오래 봐야 합니다.
* **서버 컴포넌트는 여러 제약 요소로 인해 번들러나 특정 프레임워크의 도움을 받는 것이 필수적**
* 장점
  * 복잡도 감소: 서버 컴포넌트는 useState, useEffect를 안 써도 되니 코드가 훨씬 단순해집니다.
  * 보안: 클라이언트의 async/await은 브라우저에 소스코드가 노출되지만, 서버 컴포넌트의 로직은 서버 안에서만 실행되므로 안전합니다.
  * 성능: 클라이언트는 화면을 한 번 그린 후 데이터를 또 요청하지만, 서버 컴포넌트는 데이터가 포함된 완성된 HTML을 바로 내려줍니다.

#### 클라이언트 컴포넌트

* **클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다.** **서버 전용 훅이나 유틸리티도 불러올 수 없다.**
  * 클라이언트 컴포넌트는 서버 컴포넌트를 실행할 방법이 없기 때문에(서버 환경이 브라우저에는 존재하지 않으므로)
* 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 **클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.**
  * **서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고**, 클라이언트 컴포넌트는 그걸 삽입해서 보여주기만 하기 때문
  * **`children` props**를 통해 **서버 컴포넌트를 클라이언트에 전달** 가능
  * 따라서 서버 컴포넌트와 클라이언트 컴포넌트를 중첩해서 갖는 구조가 가능

#### 공용 컴포넌트

* 클라이언트와 서버 모두에서 사용 가능
* 클라이언트 컴포넌트와 서버 컴포넌트의 모든 제약을 받는 컴포넌트.
* 리액트는 모든 것을 다 공용 컴포넌트로 판단한다.
  * 기본적으로 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류
  * 파일 맨 첫 줄에 "use client" 지시어 → 클라이언트 컴포넌트라는 것을 명시적으로 선언

### 서버 사이드 렌더링 vs 서버 컴포넌트

* 서버 사이드 렌더링과 서버 컴포넌트는 대체제가 아닌 **상호보완 개념**
  * 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받음
  * **클라이언트 컴포넌트는 서버 사이드 렌더링으로 초기 HTML을 빠르게 전달 받을수 있다.**
  * 이렇게 두가지 방법을 결합하면 클라이언트 및 서버 컴포넌트를 모두 빠르게 보여줄 수 있고, **클라이언트에서 내려받아야하는 자바스크립트 양도 줄어**들어 브라우저의 부담을 덜 수 있다.

#### 서버 사이드 렌더링

* 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다.
* 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등 작업 수행
* 초기에 인터랙션은 불가능하지만 정적인 HTML을 빠르게 내려주는데 초점
* 따라서 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고 파싱하고 실행하는 비용이 든다.

#### 리액트 19: SSR과 서버 컴포넌트(RSC)의 공존

* 리액트 18에서도 서버 사이드 렌더링(SSR)과 서버 컴포넌트(RSC)를 모두 사용하는 것이 가능했습니다. 단, 리액트 18에서는 이 기능들이 '실험적' 성격이 강했다면, 19는 이를 더 안정적이고 통일된 방식 발전.
* 이 두 기술을 따로 선택하는 것이 아니라, 함께 사용하여 최상의 성능을 냅니다.
  * **RSC만 쓰면:** 번들 크기는 줄지만, **브라우저가 데이터를 받아서 화면을 그릴 때까지 '흰 화면'**&#xC744; 봐야 할 수 있습니다.
    * RSC는 서버에서 실행되어 직렬화된 JSON 형태(RSC Payload)로 결과를 브라우저에 전달합니다. \
      만약 컴포넌트 내부에서 아주 무거운 DB 쿼리나 느린 외부 API 호출을 기다리고 있다면, 서버는 그 작업이 끝날 때까지 브라우저에 응답을 보내지 않습니다.
      * 기존 CSR: 일단 HTML/JS는 바로 뜨고, 화면 안에서 로딩 스피너가 돕니다.
      * 단순 RSC: 서버에서 데이터 처리가 완료될 때까지 브라우저는 응답을 기다려야 하므로, 네트워크가 펜딩(Pending)되는 동안 사용자는 아무것도 보지 못할 수 있습니다.
  * **SSR만 쓰면:** 화면은 빨리 보이지만, **하이드레이션을 위해 결국 모든 자바스크립트 코드를 브라우저가 다운**로드해야 해서 무겁습니다.
  * **둘 다 쓰면:** **화면도 빨리 뜨고(SSR), 브라우저가 실행할 코드 양도 적습니다(RSC).**

<table><thead><tr><th width="110.5999755859375">구분</th><th width="281.199951171875">서버 사이드 렌더링 (SSR)</th><th>서버 컴포넌트 (RSC)</th></tr></thead><tbody><tr><td><strong>핵심 역할</strong></td><td><strong>초기 로딩 속도 향상</strong> (빠른 화면 표시)</td><td><strong>번들 크기 감소</strong> (JS 전송량 줄이기)</td></tr><tr><td><strong>결과물</strong></td><td>HTML 문자열 생성</td><td>직렬화된 데이터 트리 (RSC Payload) 생성</td></tr><tr><td><strong>특징</strong></td><td>모든 컴포넌트를 일단 HTML로 바꿈</td><td><strong>서버 전용 컴포넌트는 클라이언트로 전송 안 함</strong></td></tr><tr><td><strong>상호작용</strong></td><td>하이드레이션(Hydration) 필요</td><td>하이드레이션 없이도 렌더링 가능</td></tr></tbody></table>

* 두 기술이 함께 작동하는 과정 (The Full Flow)
  * 리액트 19 환경(예: Next.js App Router)에서 사용자가 접속하면 다음과 같은 일이 **동시에** 일어납니다.
    1. **RSC 단계:** 서버가 서버 컴포넌트를 실행하여 DB 데이터를 가져오고, 클라이언트에 보낼 필요가 없는 코드(무거운 라이브러리 등)를 제거한 데이터 트리(**RSC Payload**)를 만듭니다.
    2. **SSR 단계:** 위에서 만든 트리를 바탕으로 서버에서 즉시 **초기 HTML**을 생성합니다.
    3. **전송:** 브라우저는 '**완성된 HTML**'과 '**RSC Payload**'를 동시에 받습니다.
    4. **결과:** 사용자는 HTML 덕분에 화면을 즉시 보고(SSR의 장점), 자바스크립트 번들이 줄어들어 브라우저가 가벼워집니다(RSC의 장점).

### 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다.

* 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트 컴포넌트는 항상 서버 컴포넌트다.

2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다.

* **서버에서 렌더링 할 수 있는 것은 직렬화해서 내보낸다**.
* 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 **플레이스홀더** 형식으로 비워두고 나타낸다.
* **브라우저**는 이후 이 결과물을 받아서 다시 **역직렬화**한 다음 렌더링을 수행한다.

3. 브라우저가 리액트 컴포넌트 트리를 구성한다.

* 브라우저가 서버로부터 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다.
* M1 같은 형태의 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링 진행
* 서버에서 만들어진 결과물을 받았다면 리액트 트리를 그대로 만들고 렌더링해 브라우저의 DOM에 커밋

#### 서버 컴포넌트 작동 방식의 특별한 점

* 서버에서 클라이언트로 <mark style="background-color:yellow;">**스트리밍**</mark> 형태로 정보를 보낸다. → 클라이언트가 줄 단위로 JSON을 읽고 컴포넌트를 렌더링할 수 있어 브라우저에서는 되도록 빨리 사용자에게 결과물을 보여줄 수 있다.
* 컴포넌트들이 하나의 번들러 작업에 포함돼 있지 않고 각 <mark style="background-color:yellow;">**컴포넌트별로 번들링이 별개**</mark>로 돼 있다. → 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등 가능
* 서버사이드 렌더링과 다르게 **결과물이** HTML이 아닌 <mark style="background-color:yellow;">**JSON형태**</mark>로 보내진다.
  * 클라이언트의 최종 목표는 리액트 컴포넌트 트리를 서버 컴포넌트와 클라이언트 컴포넌트 두 가지로 조화롭게 구성하는 것으로 이는 단순히 HTML을 그리는 작업 이상의 일을 필요로 한다.
  * 따라서 HTML 대신 단순한 리액트 컴포넌트 구조를 JSON으로 받아서 리액트 컴포넌트 트리의 구성을 빠르게 할 수 있도록 돕는다.
* 이러한 특징으로 인해 생기는 제약 사항은 **서버 컴포넌트에서 클라이언트 컴포넌트로 props를 넘길때&#x20;**<mark style="background-color:yellow;">**반드시 직렬화 가능한 데이터**</mark>**를 넘겨야 한다**는 것이다.
  * **서버에서 클라이언트로 데이터를 보내는 것은 JSON을 통해 이뤄지기 때문에** JSON으로 직렬화할 수 없는 데이터(**class, Date** 등)는 서버에서 클라이언트로 넘겨줄 방법이 없다. 이는 자바스크립트 고유 객체이기 때문이다.
  * (Next.js에서 getServerSideProps 가 JSON 직렬화 가능한 데이터를 반환해야만 했던 이유와 동일)

## Next.js에서의 리액트 서버 컴포넌트

* 서버 컴포넌트를 온전히 사용하기 위해서는 번들러와 프레임워크 도움이 필수
* 클라이언트 컴포넌트는 서버 컴포넌트를 불러올 수(import) 없다.
  * 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수(import) 있다.
* 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
* 각 페이지는 기본적으로 서버 컴포넌트로 작동한다.
  * Next.js의 루트 컴포넌트는 각 페이지에 존재하는 page.js다. \
    **루트 컴포넌트는 무조건 서버 컴포넌트**이므로 <mark style="background-color:yellow;">**page.js는 반드시 서버 컴포넌트여야 한다.**</mark>
  * <mark style="background-color:yellow;">**layout.js도 마찬가지로 반드시 서버 컴포넌트여야 한다.**</mark>

### Next.js에서 서버 컴포넌트를 도입하며 달라진 부분

#### 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

* 과거 Next.js의 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticsProps, getInitialProps 가 /app 내부에서는 삭제.
  * getServerSideProps는 서버 사이드 렌더링 만을 위한 것이었음.
  * 이제는 서버에서 데이터를 직접 불러올 수 있음
* 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.
* fetch API를 확장해 **같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록** 요청 중복을 방지했다.
  * SWR(Stale-While-Revalidate)과 React Query 비슷하게 해당 **fetch 요청**에 대한 내용을 **서버에서는 렌더링이 한 번 끝날 때까지 캐싱**
  * 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복 요청 방지
  * Next.js가 중복을 방지해주는 범위는 "**한 번의 렌더링 트리**(One Render Pass)".
    * 새로고침하거나(새로운 렌더링 사이클이 시작되므로 다시 가져옴)
    * 시간이 지난 후 다시 방문하면 다시 요청(별도의 데이터 캐싱 설정을 하지 않았다면)
  * **Next.js의 중복 요청 방지 vs 버튼 비활성화**
    * Next.js가 fetch를 확장해서 중복 요청을 막아주는 것은 **"성능과 네트워크 자원"을 위한 최적화**이지, **사용자의 "의도치 않은 중복 액션"을 막아주는 장치는 아닙니다.** 따라서 버튼 비활성화는 여전히 반드시 필요합니다.
    * Next.js의 '요청 중복 방지'가 해결해주지 못하는 것
      * POST 요청 (데이터 생성/수정): Next.js의 자동 캐싱은 주로 GET 요청(데이터 조회)에 집중되어 있습니다. 사용자가 '결제'나 '글쓰기' 버튼을 여러 번 클릭하면, 서버로 여러 번의 요청이 날아갈 수 있고 DB에 똑같은 데이터가 2\~3개 생길 수 있습니다.
      * 사용자 피드백: 버튼이 비활성화(Disabled)되지 않으면 사용자는 시스템이 내 요청을 처리 중인지 알 방법이 없습니다.
    * **Next.js의 '요청 중복 방지'가 해결해주는 것 (GET 요청)**
      * **컴포넌트 트리 내 중복 제거**: Layout 컴포넌트에서도 유저 정보를 fetch하고, 그 자식인 Sidebar에서도 똑같은 유저 정보를 fetch할 때, 인터넷 선을 타고 서버로 나가는 요청은 딱 1번만 발생하게 해줍니다. (이를 **Request Memoization**이라고 부릅니다.)
    * **서버 컴포넌트(RSC)에서 중복 호출할 경우**
      * 개발자 도구의 네트워크 탭에는 요청 자체가 나타나지 않습니다. 이 fetch는 브라우저가 아니라 서버(Node.js 환경) 내부에서 일어나기 때문.
      * 중복 방지 원리: 서버가 페이지를 렌더링하면서 "어? 아까 Layout에서 가져온 데이터랑 똑같은 URL이네?"라고 판단하여, **실제로 API 서버나 DB로 요청을 보내지 않고 메모리에 저장된 값을 재사용합니다.**
      * 결과: 인터넷 선을 타고 나가는 외부 요청은 딱 1번입니다.
    * 클라이언트 컴포넌트에서 중복 호출할 경우
      * 개발자 도구 네트워크 탭에서 실제로 1번만 찍히는 것을 확인할 수 있습니다. (단, Next.js의 확장된 fetch 기능을 사용할 때)
      * 브라우저의 로그: 첫 번째 요청은 200 OK로 나타나고, 이후 동일한 요청은 (from cache)라고 표시되거나 아예 요청 목록에 추가되지 않을 수 있습니다.
      * Next.js는 브라우저의 기본 fetch를 확장했기 때문에, 동일한 렌더링 사이클 안에서 발생하는 중복 요청을 클라이언트 측 메모리 캐시에서 가로챕니다.
* 비동기 컴포넌트 가능
  * 지금은 타입스크립트(TypeScript 5.1)에서 비동기 컴포넌트(async component)를 완벽하게 정식 지원

#### 정적 렌더링과 동적 렌더링

* 과거 getStaticProps
  * 과거 Next.js에는 getStaticProps를 활용해 서버에서 불러오는 데이터가 변경되지 않는 경우에 정적으로 페이지를 만들어 제공할 수 있는 기능이 있었다.
  * 해당 주소로 들어오는 경우 모든 결과물이 동일하기 때문에 CDN에 캐싱해 기존 서버 사이드 렌더링보다 더 빠르게 데이터를 제공할 수 있다는 장점이 있었다.
* Next.js 13
  * 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용 할수 있게 변경
    * 해당 주소를 정적으로 캐싱하지 않겠다는 선언을 fetch에 해두면 Next.js는 fetch요청 이후에 렌더링을 수행(해당 요청을 미리 빌드해 대기시켜 두지 않고)
  * 동적인 라우팅에 대해서는 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경
    * 함수 내부에서 Next.js가 제공하는 next/headers나 next/cookie 같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하면 해당 함수는 동적인 연산을 바탕으로 결과를 반환하는 것으로 인식 → 정적 렌더링 대상에서 제외
  * 만약 동적인 주소이지만 특정 주소에 대해 캐싱하고 싶은 경우 새로운 함수인 generateStaticParams를 사용
* fetch 옵션에 따른 작동 방식
  * fetch(URL, {cache: 'force-cache' }): 기본값으로 불러온 데이터를 캐싱해 해당 데이터로만 관리
  * fetch(URL, {cache: 'no-store' }).fetch(URL, {next: {revalidate: 0\}}): 캐싱하지 않고 매번 새로운 데이터를 불러온다.
  * fetch(URL, {next: {revalidate: 10} }): 정해진 유효시간 동안에는 캐싱하고 이 유효시간이 지나면 캐시를 파기한다.

#### 캐시와 mutating, 그리고 revalidating

*   Next.js는 fetch의 기본 작동을 재정의해 fetch 내부에 옵션으로 {next: {revalidate?: number | false\}} 를 제공

    * Next.js는 브라우저에 내장된 표준 fetch 함수를 확장(Extend)했습니다. 그래서 일반적인 자바스크립트 fetch에는 없는 next라는 특수한 옵션을 사용할 수 있게 된 것
    * 해당 <mark style="background-color:yellow;">**데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링**</mark>

    ```ts
    // 표준 fetch: fetch(url, { method, headers, body... })
    // Next.js fetch: 위 옵션에 'next'라는 항목이 추가됨

    const res = await fetch("https://api.example.com/data", {
      // 1. 일반적인 fetch 옵션
      method: "GET",
      headers: { "Content-Type": "application/json" },

      // 2. Next.js 전용 확장 옵션
      next: {
        revalidate: 60, // 60초마다 갱신
        tags: ["posts"], // 나중에 수동으로 갱신할 때 쓰는 이름표
      },
    });
    ```
*   <mark style="background-color:yellow;">**페이지에 revalidate라는 변수를 선언해서 페이지 레벨로 정의하는 것도 가능**</mark>

    * **라우트 세그먼트 설정(Route Segment Config)**: Next.js App Router에서는 파일 최상단에 특정한 이름의 변수를 선언하기만 하면, Next.js가 빌드 시점에 이 변수를 찾아내어 해당 페이지 전체의 캐싱 규칙을 결정합니다.
    * 루트에 revalidate 선언해두면 하위에 있는 모든 라우팅에서는 페이지를 60초 간격으로 갱신해 새로 렌더링한다.

    ```ts
    // app/blog/[id]/page.tsx

    export const revalidate = 60; // 60초마다 이 페이지를 새로고침(재검증)하겠다는 뜻

    export default function Page() {
      return <div>...</div>;
    }
    ```
* 캐시와 갱신이 이뤄지는 과정
  * 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
  * 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
  * 만약 해당 시간이 지나면 일단은 캐시된 데이터를 보여주면서 백그라운드에서 다시 데이터를 불러온다.
  * 새 데이터를 성공적으로 불러오면 캐시된 데이터를 갱신하고, 그렇지 않다면 과거 데이터를 보여준다.
* 캐시를 전체적으로 무효화하고 싶다면 router에 추가된 refresh 메서드로 **router.refresh();** 사용
  * 이는 브라우저를 새로고침하는 등 브라우저 히스토리에 영향을 미치지 않고 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신한다. 이 작업은 브라우저나 리액트의 state에는 영향을 미치지 않는다.

#### 스트리밍을 활용한 점진적인 페이지 불러오기

* 과거 서버 사이드 렌더링
  * 요청 받은 페이지를 모두 렌더링해서 내려줄 때 까지 사용자에게 아무것도 보여줄 수 없음
  * 페이지를 다 받아도 사용자가 인터랙션할 수 없는 정적인 페이지
  * 리액트에서 하이드레이션 과정을 거쳐야만 비로소 인터랙션 가능
  * 이 모든 작업이 순차적으로 완료되어야만 페이지를 온전하게 볼 수 있었다.
* 스트리밍: HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 방법
  * **서버와 브라우저 사이의 응답 통로(HTTP Stream)를 계속 열어두고 데이터를 쪼개 보내는 것**
  * 스트리밍을 활용해 서버 사이드 렌더링 후 리액트는 **로딩이 끝난 컴포넌트 순서대로 하이드레이션을 수행**해 사용자에게 빠르게 **상호작용이 가능한 페이지를 제공**할 수 있다.
  * 모든 데이터가 로드될 때까지 기다리지 않고 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여줄 수 있다.
  * 이는 일부라도 사용자가 페이지와 인터랙션할 수 있다는 것을 의미
  * 핵심 웹 지표인 최초 바이트까지 시간(TTFB)과 최초 콘텐츠풀 페인팅(FCP)를 개선
  * 기다리는 지루함을 덜 수 있어 UX개선
  * 페이지가 로딩 중이라는 인식을 더 명확하게 심어줄 수 있다.
  * Next.js App Router에서는 SSR뿐만 아니라 서버 컴포넌트의 데이터(RSC Payload) 자체를 스트리밍으로 보냅니다. HTML뿐만 아니라 '컴포넌트 설계도' 자체를 조각내서 보내는 거죠.
* 스트리밍을 활용할 수 있는 방법 두가지
  * 경로에 loading.tsx 배치
    * 예약어로 존재하는 컴포넌트
    * 렌더링이 완료되기 전에 보여줄 수 있는 컴포넌트를 배치할 수 있는 파일
    * loading이 suspense를 기반으로 만들어 졌기 때문에 loading파일을 배치하면 자동으로 suspense가 배치
  * Suspense배치
    * 좀 더 세분화된 제어 가능

## 웹팩의 대항마, 터보팩의 등장

* 터보팩은 러스트 기반으로 작성되어 웹팩 대비 최대 700배, Vite대비 최대 10배 빠르다.
* 2026년 1월 현재 기준으로, 터보팩(Turbopack)은 더 이상 개발 모드에만 갇혀 있지 않으며, 안정화 단계(Stability)를 넘어 프로덕션(Production) 빌드에서도 정식으로 지원되고 있다.
*   Turbopack 지원 상태 (Next.js v15+ 기준)

    <table><thead><tr><th width="193.5999755859375">구분</th><th width="164">상태</th><th>주요 특징</th></tr></thead><tbody><tr><td><strong>개발 모드 (<code>next dev</code>)</strong></td><td><strong>안정화 (Stable)</strong></td><td><code>next dev --turbo</code>를 통해 초고속 HMR(Hot Module Replacement) 제공</td></tr><tr><td><strong>빌드 모드 (<code>next build</code>)</strong></td><td><strong>정식 지원 (Stable)</strong></td><td>대규모 프로젝트에서 Webpack보다 최대 5~10배 빠른 빌드 속도</td></tr><tr><td><strong>기본 번들러</strong></td><td><strong>기본 적용 (Default)</strong></td><td>신규 Next.js 프로젝트 생성 시 터보팩이 기본 번들러로 설정됨</td></tr></tbody></table>
* 빌드 명령어

```
터보팩을 사용하여 프로덕션 빌드 (권장)
next build --turbo

터보팩 없이 기존 웹팩(Webpack)으로 빌드
next build

개발 모드에서 터보팩 사용
next dev --turbo
```

* 터보팩 장점
  * 압도적인 빌드 속도: Rust 기반의 네이티브 컴파일러를 사용하기 때문에, 특히 소스 코드가 수천 개 이상인 대규모 프로젝트에서 웹팩보다 훨씬 빠르게 빌드를 완료합니다.
  * **효율적인 캐싱**: 터보팩은 한 번 빌드한 결과물을 아주 영리하게 기억(Caching)합니다. **바뀐 파일만 골라서 다시 처리**하기 때문에 두 번째 빌드부터는 속도가 더 빨라집니다.
  * 메모리 최적화: 웹팩이 빌드 중에 메모리를 많이 잡아먹어 CI/CD 환경에서 서버가 뻗는 경우가 종종 있었는데, 터보팩은 이를 훨씬 안정적으로 관리합니다.

## 서버 액션

* <mark style="background-color:yellow;">**API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행**</mark>할 수 있는 기능
*   서버 컴포넌트와 다르게 **특정 함수 실행** 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.

    * **서버 컴포넌트 혼자서는 버튼 클릭 같은 사용자 상호작용을 서버에서 즉시 처리할 방법이 없었습니다.**
    * 과거에는 클라이언트(브라우저)에서 DB를 바꾸고 싶으면 무조건 다음과 같은 복잡한 과정을 거쳐야 했습니다.
      1. 서버에 통로 만들기: /api/update-user 같은 API 파일을 따로 만듭니다. (URL 생성)
      2. 데이터 포장: 브라우저에서 fetch를 쓰고, 데이터를 JSON으로 직렬화해서 보냅니다.
      3. 서버에서 받기: API 파일에서 요청(Request)을 받고, JSON을 다시 풀어(역직렬화)서 확인합니다.
      4. 실행: 그제야 DB를 수정합니다.
    * 서버 액션은 이 과정을 '함수 하나'로 끝냅니다.

    ```ts
    // 이게 서버 액션입니다!
    async function updateName(formData: FormData) {
      "use server"; // 이 한 줄로 이 함수는 서버에서만 실행됩니다.

      const name = formData.get("name");
      await db.user.update({ name }); // 바로 DB에 접근
    }

    export default function ProfilePage() {
      return (
        <form action={updateName}>
          {/* 함수를 버튼이나 폼에 바로 연결! */}
          <input name="name" />
          <button type="submit">이름 수정</button>
        </form>
      );
    }


    formData
    - 브라우저 표준 객체
    - HTML <form> 안에 있는 <input>들의 데이터를 key: value 형태로 모아놓은 보따리
    - formData.get("name")은 <input name="name" />에 입력된 값을 꺼내오는 작업
    - 브라우저가 보낸 데이터를 Next.js 서버가 다시 FormData 객체로 복원해서 함수에 넣어주는 것
    - 서버에는 브라우저 전용 객체인 window나 document가 없습니다. 하지만 FormData는 규격이 아주 단순해서, 서버 환경(Node.js 등)에서도 똑같은 모양으로 흉내 내서 만들기가 매우 쉽습니다.

    db.user.update
    - 이건 보통 Prisma나 Drizzle 같은 ORM(DB 관리 도구) 라이브러리에서 가져온 객체
    - 서버 전용: 이 객체는 DB 비밀번호 등을 포함하므로 원래 브라우저에서는 절대로 실행할 수 없습니다.
    - 연결: 하지만 서버 액션은 진짜 서버에서 실행되므로, 이 함수 안에서 바로 DB를 수정하는 코드를 쓸 수 있는 것입니다.

    ```

    *   서버 액션 실행 단계

        <table><thead><tr><th width="196.39996337890625">단계</th><th width="143.79998779296875">주체</th><th>동작 및 기술적 상세</th></tr></thead><tbody><tr><td><strong>1. 제출 (Submit)</strong></td><td><strong>브라우저</strong></td><td>사용자가 <code>submit</code> 버튼 클릭. <br><strong><code>action</code>에 연결된 함수 호출</strong>을 시도함.</td></tr><tr><td><strong>2. 가로채기 (Intercept)</strong></td><td><strong>Next.js 런타임</strong></td><td>기본 폼 제출(새로고침)을 막고, <br>해당 함수가 서버 액션(ID 기반)임을 확인.</td></tr><tr><td><strong>3. 직렬화 (Serialize)</strong></td><td><strong>브라우저</strong></td><td>입력된 값들을 <code>FormData</code> 객체로 담고, 네트워크 전송용(Multipart/form-data)으로 변환.</td></tr><tr><td><strong>4. 요청 (POST)</strong></td><td><strong>네트워크</strong></td><td><code>POST</code> 메서드를 통해 서버의 액션 엔드포인트로 데이터를 비동기 전송.</td></tr><tr><td><strong>5. 복원 (Restore)</strong></td><td><strong>서버</strong></td><td>전송받은 로우(Raw) 데이터를 서버 환경의 <code>FormData</code> 객체로 다시 조립.</td></tr><tr><td><strong>6. 실행 (Execute)</strong></td><td><strong>서버</strong></td><td><code>'use server'</code> 함수를 실행. 내부의 ORM(Prisma 등)을 통해 DB 수정 수행.</td></tr><tr><td><strong>7. 갱신 (Update)</strong></td><td><strong>서버 → 브라우저</strong></td><td><code>revalidatePath</code> 등이 있다면 최신 데이터를 담아 브라우저 화면을 부분 업데이트.</td></tr></tbody></table>

        *   Next.js의 서버 액션(action 속성)을 사용하면 e.preventDefault()를 직접 작성하지 않아도 Next.js가 자동으로 새로고침을 막아줍니다. 이는 **Next.js가 내부적으로 브라우저의 기본 폼 제출 동작을 가로채서(Intercept) 비동기 처리**를 하기 때문입니다.

            <table data-header-hidden><thead><tr><th width="117"></th><th></th><th></th></tr></thead><tbody><tr><td>구분</td><td>일반 HTML</td><td>Next.js 서버 액션</td></tr><tr><td><strong>제출 방식</strong></td><td>동기 방식 (새로고침 발생)</td><td><strong>비동기 방식 (새로고침 없음)</strong></td></tr><tr><td><strong>동작 원리</strong></td><td>지정된 URL(action)로 페이지 이동</td><td>JS가 가로채서 배경에서 Fetch 요청 전송</td></tr><tr><td><strong>사용자 경험</strong></td><td>화면이 깜빡이며 상태 초기화</td><td>화면 변화 없이 데이터만 전송/수정</td></tr><tr><td><strong>코드 처리</strong></td><td><code>e.preventDefault()</code> 수동 추가 필요</td><td><strong>자동으로 처리됨 (생략 가능)</strong></td></tr><tr><td><strong>JS 비활성 시</strong></td><td>정상 작동 (새로고침 폼)</td><td>정상 작동 (Progressive Enhancement 지원)</td></tr></tbody></table>

            * 점진적 향상 (Progressive Enhancement): 만약 사용자의 브라우저에서 자바스크립트가 꺼져 있으면, Next.js의 서버 액션은 일반 폼처럼 새로고침을 발생시키며 서버로 데이터를 보냅니다.
            * SPA 방식의 장점: 자바스크립트가 켜져 있는 일반적인 상황에서는 새로고침 없이(SPA 방식) 데이터만 주고받아 훨씬 부드러운 사용자 경험을 제공합니다.
    * 이게 왜 엄청난 장점인가요?
      * **① API 통로(Endpoint)를 관리할 필요가 없습니다.** \
        기존에는 기능이 100개면 API 주소도 100개를 만들고 관리해야 했습니다. **서버 액션은 그냥 함수만 만들면 Next.js가 내부적으로 알아서 통신을 처리**해주므로 개발자가 API 주소를 고민할 필요가 없습니다.
      * **② 타입 안정성 (Type Safety)** \
        서버와 클라이언트가 같은 프로젝트(함수) 안에서 대화하기 때문에, 타입을 따로 정의할 필요가 없습니다. 서버 함수가 숫자를 받기로 했으면, 클라이언트에서 문자를 보낼 때 바로 에러를 띄워줍니다.
      * **③ 서버 컴포넌트와의 시너지** \
        **서버 컴포넌트는 "화면을 그리는 일"을 서버에서 하는 것이라면,** \
        **서버 액션은 "데이터를 바꾸는 일(수정, 삭제, 생성)"을 함수 단위로 서버에서 처리합니다.**
* 서버 컴포넌트(RSC) vs 서버 액션(Server Actions)

<table><thead><tr><th width="108.20001220703125">구분</th><th width="267">서버 컴포넌트 (RSC)</th><th width="303.20001220703125">서버 액션 (Server Actions)</th></tr></thead><tbody><tr><td><strong>핵심 역할</strong></td><td><strong>UI 렌더링</strong> (화면 그리기)</td><td><strong>로직 실행</strong> (데이터 처리)</td></tr><tr><td><strong>주요 작업</strong></td><td>데이터 조회 (Read/Fetch)</td><td>데이터 생성, 수정, 삭제 (CUD)</td></tr><tr><td><strong>실행 단위</strong></td><td>컴포넌트 단위 (HTML 조각)</td><td>함수 단위 (Function)</td></tr><tr><td><strong>호출 주체</strong></td><td>서버 (페이지 로드 시 자동 실행)</td><td><strong>클라이언트 (버튼 클릭 등 사용자 액션)</strong></td></tr><tr><td><strong>상태 유지</strong></td><td>상태 없음 (Stateless)</td><td>실행 후 클라이언트 상태 업데이트 가능</td></tr><tr><td><strong>파일 지시어</strong></td><td>기본값 (또는 생략)</td><td><strong><code>'use server'</code></strong></td></tr></tbody></table>

* 2026년 1월 기준으로 서버 액션(Server Actions)은 이제 더 이상 실험 기능(Alpha/Beta)이 아닙니다! 정식 기능(Stable)으로 완전히 자리 잡았기 때문에, 이제 config.js에서 별도의 설정을 하지 않아도 바로 사용할 수 있습니다.
* 2026년 1월 현재 next dev --turbo 환경에서도 서버 액션(Server Actions)은 아무 문제 없이 완벽하게 작동합니다. 터보팩이 서버 액션 지원.
* 서버 액션을 만들려면 "use server" 지시자 선언, **함수는 반드시 async**여야 한다.

### form의 action

```ts
export default function Page() {
  async function handleSubmit() {
    "use server";

    console.log(
      // 서버 터미널
      "해당 작업은 서버에서 수행합니다. 따라서 CORS 이슈가 없습니다."
    );

    const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "post",
      body: JSON.stringify({
        title: "foo",
        body: "bar",
        userId: 1,
      }),
      headers: {
        "Content-type": "application/json; charset=UTF-8",
      },
    });

    const result = await response.json();
    console.log(result); // 서버 터미널
  }
  return (
    <form action={handleSubmit}>
      <button type="submit">form 요청 보내보기</button>
    </form>
  );
}
```

* HTML 폼의 `action` 속성을 Next.js가 확장하여 **함수를 직접 받도록 설계함**.
* 개발자는 함수를 넘기지만, **Next.js는 내부적으로** <mark style="background-color:yellow;">**이 함수에 대응하는 고유한 URI(ID)**</mark>를 생성해 통신함.
  * 같은 말: "action prop을 추가해서 이 양식 데이터를 처리할 URI&#xB97C;**(handleSubmit이란 서버 액션)** 넘겨줄 수 있다."
  * 개발자 도구 네트워크 탭에서 해당 form버튼을 클릭하면 /server-action/form으로 요청이 수행되고 페이로드에는 앞서 코드에서 보낸 post요청이 아닌 **ACTION\_ID**라는 액션 구분자만 있다.
  * 이를 처리하는 서버에서는 해당 페이지에서 수행하는 서버 액션을 모아둔다. p753-754
  * 즉, 서버 액션을 실행하면 클라이언트에서는 **현재 라우트 주소**와 **ACTION\_ID**만 보내고 그 외에는 아무것도 실행하지 않는다.
* 서버에서는 요청받은 라우트 주소와 ACTION\_ID를 바탕으로 실행해야 할 내용을 찾고 이를 서버에서 직접 실행한다.
* 이를 위해 'use server'로 선언돼 있는 내용을 빌드 시점에 미리 클라이언트에서 분리시키고 서버로 옮김으로써 클라이언트 번들링 결과물에는 포함되지 않고 서버에서만 실행되는 서버 액션을 만든 것을 확인할 수 있다.
* 이 handleSubmit 이벤트를 발생시키는 것은 클라이언트지만 **실제로 함수 자체가 수행되는 것은 서버**다.
* 폼과 실제 노출하는 데이터가 연동돼 있을 때 더욱 효과적으로 서버액션을 사용할 수 있다.
* 서버 액션의 실행이 완료되면 data객체를 revalidatePath로 갱신해 업데이트된 최신 데이터를 불러올 수 있다.
  * revalidatePath는 인수로 넘겨받은 경로의 캐시를 초기화해서 해당 URL에서 즉시 새로운 데이터를 불러오는 역할을 한다.
  * Next.js에서는 이를 server mutation(서버에서의 데이터 수정)이라고 한다.
  * <mark style="background-color:yellow;">**server mutation**</mark>으로 실행 할 수 있는 함수
    * **redirect**: import {redirect} from 'next/navigation' 특정 주소로 리다이렉트할 수 있다.
    * **revalidatePath**: import {revalidatePath} from 'next/cache' 해당 주소의 캐시를 즉시 업데이트
    * **revalidateTag**: import {revalidateTag} from 'next/cache' 캐시 태그는 fetch 요청 시에 다음과 같이 추가할 수 있다.
      * `fetch('https://localhost:8080/api/something', {next: {tags: ['']}})`
      * 이렇게 태그를 추가해두면 여러 다양한 fetch 요청을 특정 태그값으로 구분할 수 있으며 revalidateTag를 사용할 경우 이 특정 태그가 추가된 fetch 요청을 모두 초기화한다.
* PHP같은 전통적인 서버 기반 웹 애플리케이션과 서버액션의 가장 큰 차이는 이 모든 과정이 <mark style="background-color:yellow;">**페이지 새로 고침 없이 수행**</mark>된다는 것이다.
  * 최초에 페이지를 서버에서 렌더링한 이후에 폼에서 handleSubmit으로 서버에 데이터 수정을 요청하는것, 그리고 수정된 결과를 다시 조회해서 새로운 결과로 렌더링 하는 일련의 과정이 **모두 페이지 새로고침 없이 데이터 스트리밍으로 이뤄진다.**
  * 따라서 개발자들은 서버에 데이터 수정을 요청하는 한편, 클라이언트에서는 업데이트를 완료한 후 새로운 결과를 받을 때까지 사용자에게 로딩 중이라는 것을 알 수 있는 인터랙션을 구성할 수도 있다.
* **form을 서버 액션과 함께 사용하면 form을 기반으로 한 데이터 추가, 수정 요청을 더 자연스럽게 수행할 수 있다.** 또한 Next.js에서 관리하는 캐시를 효과적으로 초기화 할 수 있다.

### input의 submit과 image의 formAction

* form.action과 마찬가지로 input type="submit" 또는 **input type="image"** 의 **formAction** prop으로도 서버 액션을 추가할 수 있다.

### startTransition과의 연동

* 서버 액션은 **form.action, formAction** 뿐 아니라 useTransition이 반환하는 배열의 두번째 요소인 **startTransition을 사용해 서버 액션을 실행할수도 있다.**
  * startTransition을 사용하면 **form 태그 없이도 일반 버튼 클릭이나 특정 이벤트 발생 시 서버 액션을 실행할 수 있습니다.**
  * 특히 이 방식은 "**낙관적 업데이트(Optimistic Updates)**"나 "**로딩 상태 처리**"를 구현할 때 필수적입니다.
* useTransition을 사용하면 이전과 동일한 로직을 구현하면서도 page단위의 loading.jsx를 사용하지 않아도 된다.
  * **isPending**을 활용해 startTransition으로 서버 액션이 실행됐을 때 해당 버튼을 숨기고 로딩 버튼을 노출함으로써 **페이지 단위가 아닌 좀 더 컴포넌트 단위의 로딩 처리**도 가능.
* 이와 동시에 revalidatePath같은 server mutation도 마찬가지로 처리할 수 있다.

```tsx
"use client";

import { useTransition } from "react";
import { updateLikeCount } from "./actions"; // 서버 액션 함수

export default function LikeButton({ postId }: { postId: string }) {
  // 1. useTransition 훅 사용
  const [isPending, startTransition] = useTransition();

  const handleLike = () => {
    // 2. startTransition으로 서버 액션 감싸기
    startTransition(async () => {
      await updateLikeCount(postId); // 서버 액션 실행

      // 실행이 완료되면 페이지의 서버 컴포넌트 데이터가 자동으로 갱신(Revalidate)됩니다.
      // 서버 액션 함수 마지막에 보통 revalidatePath('/')나 revalidateTag('posts')를 적습니다.
      // 서버에게 이 주소의 데이터가 바뀌었으니 저장해둔(캐시된) HTML/데이터를 버리라고 명령하는 것
      console.log("서버 작업 완료!");
    });
  };

  return (
    <button
      onClick={handleLike}
      disabled={isPending} // 3. 로딩 중에는 버튼 비활성화
    >
      {" "}
    </button>
  );
}
```

* form action: 폼 데이터를 서버로 보낼 때 쓰는 표준 방식.
* <mark style="background-color:yellow;">**startTransition: 버튼 클릭처럼 폼이 없는 곳에서 서버 액션을 실행**</mark>

### server mutation이 없는 작업

* **server mutation이 필요하다면 반드시 서버 액션을 useTransition과 함께 사용**해야 하지만 별도의 server mutation을 실행하지 않는다면 바로 이벤트 핸들러에 넣어도 된다.
* server mutation = 반드시 useTransition 이라는 공식은 **form을 사용하지 않는 경우에만 해당**되는 말입니다.

form의 action 속성에 서버 액션을 넣는 순간, 리액트가 내부적으로 이미 Transition 처리를 다 해준다.

### 서버 액션 사용 시 주의할 점

* **서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.**
* 클라이언트 컴포넌트에서 서버 액션을 쓰고 싶을 때는 앞의 startTransition 예제처럼 **'use server'로 서버 액션만 모여 잇는 파일을 별도로 import해야 한다.**
  * 서버 컴포넌트가 클라이언트 컴포넌트를 불러올 수 있는 것과 동일한 원리. 즉, 서버에서만 실행될 수 있는 자원은 반드시 파일 단위로 분리해야 한다.
  * 서버 컴포넌트에서 클라이언트 컴포넌트를 불러올 때
    * 서버 컴포넌트(부모): "나는 서버에서만 돌아가지만, 이 부분은 브라우저에서 실행해줘"라며 클라이언트 컴포넌트를 import합니다.
    * 작동 방식: 이때 서버 컴포넌트의 모든 코드가 브라우저로 가는 게 아니라, 클라이언트 컴포넌트 부분만 잘라서 브라우저용 번들에 담깁니다.
  * 서버 액션도 똑같습니다.
    * 클라이언트 컴포넌트: "나는 브라우저에서 돌아가지만, 이 함수만은 서버에서 실행해줘"라며 서버 액션을 import합니다.
    * 작동 방식: **이때 서버 액션 파일(actions.ts)에 적힌 복잡한 DB 로직이나 비밀번호가 브라우저로 넘어가는 게 아니라, "서버의 A번 함수를 실행해라"라는 아주 짧은 연결 고리(Proxy)만 넘어갑니다.**
* **클라이언트 컴포넌트에서 서버 액션 파일을 import 하는 것은 가능**
* **서버 액션을 props형태로 클라이언트 컴포넌트에게 넘기는 것 또한 가능.**

## 그 밖의 변화

* 프로젝트 전체 라우트에서 쓸 수 있는 미들웨어 강화
* SEO를 쉽게 작성할 수 있는 기능 추가
* 정적으로 내부 링크를 분석할 수 있는 기능 추가

## Next.js 13 코드 맛보기

### getServerSideProps와 비슷한 서버 사이드 렌더링 구현해보기

* 서버 컴포넌트에서 fetch를 수행하고 이 fetch에 별다른 cache옵션을 제공하지 않는다면 기존의 getServerSideProps와 유사하게 작동
* 과거 getServerSideProps를 사용하는 애플리케이션에서는 `<script id="__NEXT_DATA__" type="application/json">`라고 하는 특별한 태그가 추가돼 있었고 이 서버에서 미리 만들어진 정보를 바탕으로 클라이언트에서 하이드레이션을 수행했었다.
* 리액트 18에서는 서버 컴포넌트에서 렌더링한 결과를 직렬화 가능한(JSON.stringify가 가능한) 데이터로 클라이언트에 제공하고 클라이언트는 이를 바탕으로 하이드레이션을 진행하게 된다.
* 각 스크립트는 하나의 서버 컴포넌트 단위를 의미하며 예제 코드의 마지막 스크립트에서 이 마지막 서버 컴포넌트의 흔적을 발견할 수 있다.
* 과거 getServerSideProps를 사용하던 당시에는 \[id].json형태로 요청을 보내서 새로운 getServerSideProps의 실행 결과를 JSON 형태로 받았다.
* 리액트 18부터는 마찬가지로 서버 컴포넌트의 렌더링 결과를 컴포넌트별로 직렬화된 데이터로 받아 이 데이터를 바탕으로 클라이언트에서 하이드레이션하는데 사용

### getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기

* 과거 정적 페이지 생성을 위해 getStaticProps나 getStaticPaths를 이용해 사전에 미리 생성 가능한 경로를(path) 모아둔 다음 이 경로에 대해 내려줄 props를 미리 빌드하는 형식 → 이런 방법은 헤드리스 CMS같이 사용자 요청에 앞서 미리 빌드해둘 수 있는 페이지를 생성하는데 매우 효과적
* app 디렉터리가 생기면서 getStaticProps와 getStaticPaths는 사라졌지만 이와 유사한 방식을 fetch의 cache를 이용해 구현할 수 있다.
  * Next.js에서 사용하는 fetch에서 줄 수 있는 cache 옵션
    * force-cache(기본값): 캐시가 존재하면 해당 캐시 값을 반환하고 캐시가 존재하지 않으면 서버에서 데이터를 불러와 가져온다.
    * no-store: 캐시를 절대 사용하지 않고 매 요청마다 새롭게 값을 불러온다.
  * 또는 fetch(https://..., {next: {revalidate: false | 0| number\}}) 를 사용해 캐시를 초 단위로 줄 수도 있다.
* 빌드 결과물을 확인할 수 있는 .next/server/app 아래에 generateStaticParams로 선언한 모든 경우의 수에 대해 미리 페이지를 생성해둔다.
* Incremental Static Regeneration
  * 정적으로 생성된 페이지를 점진적으로 갱신
  * 정적으로 미리 빌드해 두는 것 뿐만 아니라 캐시를 활용
  * 일정 기간동안은 캐시를 통해 가져와 빠르게 렌더링하고 시간이 지나면 새롭게 데이터를 불러오는 방식으로 페이지 구성
  * 캐시 유효시간이 지난 이후에 다시 페이지를 방문해 보면 서버에서 페이지를 다시 생성하면서 마지막 렌더링 시간이 갱신
  * 캐시된 페이지는 서버 액션을 통해 캐시를 강제로 갱신하는 것 또한 가능
    * server mutation 중 하나인 revalidatePath를 사용하면 해당 페이지가 revalidate로 정의한 캐시 초(second) 이내에도 이전까지의 캐시를 무효화하고 새로운 페이지를 빌드하게 된다.

### 로딩, 스트리밍, 서스펜스

* Next.js 13, 리액트 18은 **서버 컴포넌트 렌더링과 이를 클라이언트에 제공하기 위해 스트리밍을 사용.**
* **서스펜스로 감싸진 컴포넌트는 스트리밍으로 응답을 점진적으로 받으면서 렌더링한다.**
* 스트리밍
  * 페이지 렌더링에 소요된 시간 만큼 네트워크 요청도 발생
  * HTML이 점진적으로 렌더링
  * 스트리밍을 통해 내려오는 데이터 단위: chunk
  * 최초 데이터는 서버에서 fetch 등의 작업을 기다릴 필요가 없는 suspense내부의 로딩 데이터가, \
    이후부터 fetch가 끝나면서 렌더링이 완료된 컴포넌트의 데이터를 하나씩 내려준다.

### 기타

* 추상화: **복잡한 내부 로직을 숨기고, 사용하기 쉬운 인터페이스(도구)만 밖으로 드러내는 것**
* 광케이블(Optical Fiber Cable): 전기로 신호를 보내는 구리선과 달리, 빛(Light)을 이용해 데이터를 주고받는 통신 케이블. 현재 우리가 사용하는 초고속 인터넷, 해저 케이블, 데이터 센터 내부 망의 핵심 기술
  *   빛을 이용한 데이터 전송 원리 (광통신)

      <table><thead><tr><th width="125.79998779296875">단계</th><th width="186.39996337890625">장치</th><th>역할</th><th>비유</th></tr></thead><tbody><tr><td><strong>1. 전기 → 빛</strong></td><td><strong>광송신업체 (LD/LED)</strong></td><td>전기 신호(0, 1)를 빛의 깜빡임으로 변환</td><td>손전등을 껐다 켰다 하기</td></tr><tr><td><strong>2. 전송</strong></td><td><strong>광케이블 (Fiber)</strong></td><td>빛 신호를 먼 곳까지 손실 없이 전달</td><td>거울이 깔린 긴 터널 통과</td></tr><tr><td><strong>3. 빛 → 전기</strong></td><td><strong>광수신업체 (PD)</strong></td><td>들어온 빛을 다시 전기 신호로 변환</td><td>빛을 보고 메모지에 0, 1 적기</td></tr></tbody></table>
  * 컴퓨터의 데이터는 결국 `0`과 `1`의 조합입니다. 이를 빛의 상태로 약속합니다.
    * 빛이 켜짐 (ON): 데이터 1
    * 빛이 꺼짐 (OFF): 데이터 0 이 깜빡임이 1초에 수십억 번(Gbps) 일어나기 때문에 우리가 눈으로 볼 수는 없지만, 기계는 이 미세한 차이를 읽어내어 방대한 데이터를 실어 나릅니다.
  * 빛은 원래 직진하는 성질이 있는데, 굽어 있는 케이블 속을 어떻게 통과할까요? \
    바로 **전반사(Total Internal Reflection)** 원리 덕분입니다.
    * 광케이블 내부는 유리(코어)와 이를 감싸는 또 다른 유리(클래딩)로 되어 있습니다.
    * 빛이 밖으로 새어 나가지 못하도록 안쪽 벽면이 **거울처럼 빛을 계속 튕겨냅니다.**
    * 이 덕분에 케이블이 휘어져 있어도 빛은 안에서 계속 반사되며 끝까지 도달합니다.
  * 빛은 파장(색깔)에 따라 서로 간섭하지 않고 섞일 수 있는 성질이 있습니다. 이를 이용해 하나의 광케이블 안에 여러 종류의 데이터를 동시에 실어 보내는 기술을 광파장 분할 다중화(WDM: Wavelength Division Multiplexing)라고 합니다. 쉽게 말해, 1차선 도로를 80차선 고속도로처럼 사용하는 마법과 같습니다.
    * 빛에는 빨강, 주황, 노랑 등 다양한 파장(색깔)이 있습니다.
    1. **송신부:** 1번 데이터는 '빨간색 빛'으로, 2번 데이터는 '파란색 빛'으로 변환합니다.
    2. **합치기(Mux):** 이 여러 색깔의 빛을 하나의 광케이블에 합쳐서 쏩니다. (흰색 빛처럼 보임)
    3. **전송:** 빛은 서로 다른 색끼리 섞여도 정보가 깨지지 않고 끝까지 함께 달려갑니다.
    4. **분리하기(DeMux):** 도착 지점에서 프리즘 같은 장치를 통해 다시 빨강, 파랑 빛으로 쪼개어 각각의 데이터를 읽어냅니다.

<table><thead><tr><th width="108.20001220703125">특징</th><th width="271.79998779296875">구리선 (전기)</th><th>광케이블 (빛)</th></tr></thead><tbody><tr><td><strong>속도</strong></td><td>전자의 이동 속도 (상대적 느림)</td><td>빛의 속도 (지구 7바퀴 반/초)</td></tr><tr><td><strong>대역폭</strong></td><td>한 선에 흐를 수 있는 전기량 한계</td><td>여러 파장(색깔)의 빛을 동시에 쏴서 대량 전송 가능</td></tr><tr><td><strong>신호 약화</strong></td><td>저항 때문에 열이 나고 신호가 약해짐</td><td>멀리 가도 신호가 거의 약해지지 않음</td></tr></tbody></table>

<table><thead><tr><th width="119.39996337890625">장점</th><th>효과</th><th>결과</th></tr></thead><tbody><tr><td><strong>케이블 절약</strong></td><td>광케이블을 한 개만 깔아도 됨</td><td>인프라 구축 비용 압도적 절감</td></tr><tr><td><strong>독립적 전송</strong></td><td>빨간 빛이 고장 나도 파란 빛은 잘 감</td><td>통신의 안정성 확보</td></tr><tr><td><strong>용량 확장</strong></td><td>장비만 바꾸면 10G망을 800G망으로 업그레이드 가능</td><td>데이터 폭증에 유연하게 대처</td></tr></tbody></table>

* 🚥 광케이블 vs 비동기/병렬 처리의 관계 우리가 비동기와 병렬을 적극적으로 쓰게 된 배경에는 광케이블의 기여가 결정적

1. **전송량 폭발:** 광케이블 덕분에 "데이터가 너무 커서 한 번에 못 보내"라는 걱정이 사라짐.
2. **지연 시간 단축:** 빛의 속도로 데이터를 주고받으니 비동기 요청의 응답이 즉각적으로 옴.
3. **인프라 혁명:** 광케이블로 전 세계 데이터 센터가 연결되면서, 우리가 쓰는 API나 클라우드 서비스가 실시간으로 작동할 수 있게 됨.

<table><thead><tr><th width="101.79998779296875">구분</th><th>광케이블 (하드웨어)</th><th>비동기/병렬 처리 (소프트웨어/기술)</th></tr></thead><tbody><tr><td><strong>역할</strong></td><td>데이터를 나르는 <strong>'통로'</strong></td><td>데이터를 다루는 <strong>'방식'</strong></td></tr><tr><td><strong>핵심 기여</strong></td><td>압도적인 데이터 전송 속도와 대역폭 제공</td><td>기다림 없이 효율적으로 업무를 처리함</td></tr><tr><td><strong>비유</strong></td><td>100차선 고속도로가 뚫림</td><td>여러 대의 차가 동시에 출발하고(병렬), 짐을 내리는 동안 다음 차를 보냄(비동기)</td></tr></tbody></table>

* **비동기(Asynchronous)**: "기다리기 싫어서" 광케이블이 아무리 빨라도 물리적인 거리가 있으면 데이터가 도착할 때까지 시간이 걸립니다.
  * **동기(Sync):** 서버에 데이터를 요청하고 올 때까지 프로그램을 멈추고 기다림 (비효율적)
  * **비동기(Async):** 서버에 요청을 던져놓고, 데이터가 오는 동안 화면의 **다른 부분**(애니메이션, 다른 버튼 등)**을 먼저 처리**함. 데이터가 도착하면 그때 화면에 그림.
  * **광케이블의 역할:** 데이터가 오는 시간을 '최소화'해주어 비동기 처리가 더 매끄럽게 느껴지게 함.
* **병렬(Parallel)**: "**한꺼번에** 많이 하려고" 광케이블의 '여러 파장(색깔)을 쏘는 기술'은 병렬 처리의 하드웨어적 버전입니다.
  * **병렬 처리:** 한 번에 하나의 데이터만 받는 게 아니라, 여러 데이터를 동시에 요청해서 받음.
  * **광케이블과의 관계:** 광케이블이 한 번에 엄청난 양의 데이터(대역폭)를 수용할 수 있게 되면서, 소프트웨어가 마음껏 "데이터 10개를 동시에 보내줘!"라고 요청할 수 있게 된 것입니다. (구리선이었다면 병목 현상이 생겨서 불가능했을 일)
*   리액트 패러다임의 변화: "클라이언트에서 서버로"

    <table><thead><tr><th width="105.5999755859375">구분</th><th width="266.20001220703125">과거의 리액트 (UI 라이브러리)</th><th>현재의 리액트 (풀스택 프레임워크 지향)</th></tr></thead><tbody><tr><td><strong>철학</strong></td><td>브라우저 내에서의 렌더링 최적화</td><td>서버와 클라이언트를 아우르는 통합 렌더링</td></tr><tr><td><strong>시작점</strong></td><td>무조건 브라우저 (Client)</td><td>서버가 먼저 시작하고 클라이언트가 이어받음</td></tr><tr><td><strong>핵심 기술</strong></td><td>Virtual DOM, Client Hooks</td><td><strong>React Server Components (RSC)</strong></td></tr></tbody></table>
* **Next.js를 쓴다면:** 시작점은 서버 컴포넌트입니다. 리액트 팀은 이제 Next.js 같은 프레임워크를 통해 리액트를 사용하는 것을 공식적으로 권장하고 있습니다.
* **Vite를 쓴다면:** 여전히 시작점은 클라이언트입니다. 하지만 이 방식은 점차 '특수한 경우(대시보드 등)'에만 쓰이는 추세입니다.
* **예전 리액트:** "브라우저에서 화면을 예쁘고 빠르게 바꿔주는 도구야."
* **지금 리액트:** "서버에서 데이터를 가져와 뼈대를 만들고, 브라우저에서 숨을 불어넣는 **전체 시스템**"
* 왜 리액트 팀은 시작점을 서버로 옮기려 할까?
  * 리액트 팀은 브라우저에서만 돌아가는 리액트의 한계를 깨닫고, 리액트가 서버에서도 컴포넌트를 실행할 수 있게 리액트 엔진 자체를 업그레이드했습니다.
    1. **데이터 가까이 가기:** 서버 컴포넌트는 데이터베이스 바로 옆(서버)에서 실행되므로 데이터 로딩이 빠릅니다.
    2. **클라이언트 부담 덜어주기:** 브라우저가 해야 할 복잡한 계산과 무거운 라이브러리 실행을 서버가 대신 처리합니다.
    3. **컴포넌트 단위의 서버 실행:** 기존 SSR은 페이지 전체를 그려주는 방식이었지만, 이제는 **컴포넌트 하나하나**를 서버에서 실행할지 클라이언트에서 실행할지 결정할 수 있습니다.
*   <mark style="background-color:yellow;">**PostgreSQL**</mark>: 오픈 소스 관계형 데이터베이스 관리 시스템(RDBMS)

    1. **데이터 무결성 (안정성):** ACID(원자성, 일관성, 격리성, 지속성)를 엄격하게 준수하여 금융 시스템처럼 데이터가 절대 깨지면 안 되는 곳에 적합합니다.
    2. **복잡한 쿼리 처리:** 아주 복잡한 조인(Join)이나 대용량 데이터를 분석하는 능력이 뛰어납니다.
    3. **확장성 (Extensibility):** 개발자가 자신만의 데이터 타입, 함수, 인덱스 유형을 직접 만들어 추가할 수 있습니다.
    4. **다양한 데이터 지원:** 일반적인 텍스트/숫자뿐만 아니라 JSON(비정형 데이터), 지리 정보(GIS), 배열 등도 아주 잘 처리합니다.

    * MySQL vs PostgreSQL

    <table><thead><tr><th width="110.4000244140625">비교 항목</th><th width="222.4000244140625">MySQL</th><th width="321.599853515625">PostgreSQL</th></tr></thead><tbody><tr><td><strong>주요 강점</strong></td><td>단순함, 읽기 속도 빠름</td><td>복잡한 기능, 쓰기/분석 기능 강력</td></tr><tr><td><strong>표준 준수</strong></td><td>일부 독자적인 방식 사용</td><td>SQL 표준을 가장 엄격하게 준수</td></tr><tr><td><strong>JSON 처리</strong></td><td>기본적인 수준 지원</td><td>JSONB 형식을 통해 매우 강력하게 지원</td></tr><tr><td><strong>사용 사례</strong></td><td>일반적인 웹사이트, 블로그</td><td>복잡한 엔터프라이즈 앱, 금융, GIS 시스템</td></tr></tbody></table>

    * Next.js/React 개발 관련 내용
      * 요즘 Next.js App Router로 개발할 때, 서버 컴포넌트(RSC)에서 직접 DB에 접근하는 경우가 많은데, 이때 가장 많이 조합되는 DB가 바로 PostgreSQL입니다.
      * 특히 Supabase나 Vercel Postgres 같은 서비스들이 내부적으로 PostgreSQL을 사용하고 있어, 현대적인 웹 개발 스택의 표준이 되었습니다.
    * 데이터베이스에서 조인(Join)이란 서로 다른 두 개 이상의 테이블을 특정 조건(주로 공통된 열)을 기준으로 하나로 합쳐서 데이터를 조회하는 기술
* 직렬화(serialize)
  * '물건'을 멀리 있는 곳(서버나 다른 컴퓨터)으로 보내기 위해 '택배 박스에 넣고 포장하는 과정'
  * JSON 직렬화: 메모리 속에 복잡하게 얽혀 있는 자바스크립트 객체를 단순한 문자열(String)로 바꾸는 것
  * 서버와 클라이언트가 서로 다른 언어(Java, Python, JS 등)를 쓰더라도 데이터를 공통된 규격으로 주고받을 수 있습니다.
  * **서버 컴포넌트에서 클라이언트 컴포넌트로 데이터를 넘길 때, 반드시 "직렬화가 가능한 데이터"여야 한다**는 규칙이 있습니다.
    * **직렬화 가능:** 숫자, 문자열, 배열, 순수한 객체 (JSON으로 변환 가능)
    * **직렬화 불가능:** **함수(Function)**, 클래스의 인스턴스, 이벤트 핸들러
      * **이유:** **"함수"는 '동작'이기 때문에 텍스트(JSON)로 박스 포장을 해서 보낼 수가 없기 때문**입니다.
* 직렬화 vs 와이어 포맷 두 용어는 거의 세트로 쓰이지만 미세한 차이가 있습니다.
  * **직렬화(Serialization):** 메모리 속의 복잡한 데이터를 전송 가능한 상태로 **바꾸는 '과정'** 그 자체입니다.
  * **와이어 포맷(Wire Format):** 그 결과물로 나온 '데이터의 모양(규격)'입니다.
    * 예: "데이터를 JSON(와이어 포맷)으로 직렬화(과정)한다."
* 와이어 포맷
  * M: M으로 시작하는 줄은 클라이언트 컴포넌트
    * 클라이언트 번들에서 해당 함수를 렌더링하기 위해 필요한 정보가 어디(chunk)에 담겨 있는지 참조를 전달
  * S: Suspense
  * J: 서버에서 렌더링된 서버 컴포넌트
    * J0은 App.server.js
    * @N (@1,@2)
      * 이 정보는 나중에 렌더링이 완료됐을 때 들어가야 할 컴포넌트
      * @1은 M1이 렌더링되면 저 @1자리에 @M1이 들어가야 한다는 것
* SWR(Stale-While-Revalidate): Next.js를 만든 Vercel 팀에서 제작한 데이터 페칭(Data Fetching)용 리액트 훅(Hook) 라이브러리
  * HTTP 캐시 전략인 Stale-While-Revalidate의 약자
    * Stale: 우선 캐시에 있는 '낡은' 데이터를 먼저 보여주고,
    * Revalidate: 백엔드에 가서 새로운 데이터를 가져와서,
    * Update: 화면을 최신 상태로 갱신합니다.
  * 핵심 기능: 캐싱, 중복 요청 제거, 포커스 시 재검증(화면을 다시 볼 때 데이터 업데이트) 등을 자동으로 해줍니다.
* CDN(Content Delivery Network, 콘텐츠 전송 네트워크)
  *   물리적으로 멀리 떨어져 있는 사용자에게 콘텐츠(이미지, 영상, JS 파일 등)를 더 빠르게 전달하기 위해 전 세계 곳곳에 흩어놓은 서버들의 네트워크입니다.

      <table><thead><tr><th width="175.5999755859375">개념</th><th width="116.4000244140625">비유</th><th>설명</th></tr></thead><tbody><tr><td><strong>원본 서버 (Origin)</strong></td><td>본사 공장</td><td>데이터의 원본이 저장된 메인 서버 (미국 등)</td></tr><tr><td><strong>엣지 서버 (Edge)</strong></td><td>동네 편의점</td><td>사용자와 가까운 곳에 위치한 거점 서버 (서울 등)</td></tr><tr><td><strong>캐싱 (Caching)</strong></td><td>재고 쌓기</td><td>본사에서 물건을 가져와 미리 보관해두는 과정</td></tr></tbody></table>

      * 멀티 리전(Multi-Region): '본사(Origin)가 여러 개'라는 뜻
        * 엣지가 여러 개인 것은 CDN의 기본적인 속성이기 때문에 따로 '멀티 리전'이라고 부르지 않고, 본사(데이터센터) 자체를 전 세계 여러 거점에 복제로 두었을 때 멀티 리전이라고 함
      * 엣지(Edge): 사용자(기기)와 가장 가까운 지점
  * 왜 CDN을 쓰나요? (속도의 차이)
    * 전 세계 모든 사용자가 미국에 있는 서버에 접속한다고 가정해 봅시다.
      1. **CDN 미사용:** 한국 사용자가 데이터를 요청하면 빛의 속도라 해도 물리적 거리 때문에 지연(Latency)이 발생합니다. 수만 킬로미터의 광케이블을 거쳐야 하죠.
      2. **CDN 사용:** 한국 사용자가 접속하면 CDN 서비스가 자동으로 '서울에 있는 엣지 서버'로 연결해 줍니다. 집 앞 편의점에 가는 것만큼 빨라집니다.
  * CDN은 어떻게 동작하나요?
    1. **첫 번째 방문자:** 서울 사용자가 접속했는데 서울 엣지 서버에 데이터가 없다면, 엣지 서버가 미국 본사 서버에 가서 데이터를 가져옵니다. (이때는 조금 느림)
    2. **데이터 복사:** 엣지 서버는 가져온 데이터를 자기 메모리에 복사(캐싱)해 둡니다.
    3. **다음 방문자들:** 이제부터 접속하는 모든 한국 사용자는 미국까지 갈 필요 없이 **서울 엣지 서버에서 즉시** 데이터를 받습니다.
  * 요약
    * **목적:** 지연 시간(Latency) 감소, 서버 부하 분산.
    * **대상:** 주로 변하지 않는 정적 파일 (이미지, CSS, JS, 비디오).
    * **장점:** 미국 서버에 장애가 나도, 서울 CDN 서버가 살아있다면 한국 사용자는 서비스를 이용할 수 있습니다.
  *   개발자의 CDN 이미지 사용 프로세스

      <table><thead><tr><th width="106.79998779296875">단계</th><th width="264.800048828125">작업 내용</th><th>사용하는 도구 (예시)</th></tr></thead><tbody><tr><td><strong>1. 업로드</strong></td><td>이미지를 CDN 저장소에 올립니다.</td><td>AWS S3, Cloudinary, Supabase Storage</td></tr><tr><td><strong>2. 주소 획득</strong></td><td>이미지가 저장된(보통 본사 서버에 저장) 고유 URL을 얻습니다.</td><td><code>https://cdn.example.com/logo.png</code></td></tr><tr><td><strong>3. 코드 적용</strong></td><td>리액트나 HTML 코드의 <code>src</code> 속성에 넣습니다.</td><td><code>&#x3C;img src="..." /></code> 또는 <code>Next/Image</code></td></tr></tbody></table>

      * 서울에 있는 AWS S3 버킷에 이미지를 올림
      * 밴쿠버에 있는 친구가 해당 이미지 URL을 클릭합니다.
      * 밴쿠버 엣지 서버를 먼저 확인합니다. ➔ "데이터 없음!"
      * 밴쿠버 엣지는 서울에 있는 원본 서버에 "이미지 좀 보내줘"라고 요청합니다.
      * 서울 원본 서버가 밴쿠버 엣지로 이미지를 쏴줍니다.
      * 이미지를 받은 밴쿠버 엣지는 사용자에게 전달함과 동시에 자기 자신의 저장소(캐시)에 복사본을 저장합니다.
      * 밴쿠버에 있는 또 다른 사람이 접속하면, 이제 서울까지 안 오고 밴쿠버 엣지가 가진 복사본을 바로 줍니다.
  * 왜 내 프로젝트 폴더에 안 넣고 CDN을 쓰나요?
    1. **빌드 속도와 용량:** 프로젝트 폴더에 이미지가 많아지면 코드를 빌드할 때 시간이 엄청나게 오래 걸리고 파일 덩어리가 커집니다.
    2. **로딩 속도:** 전 세계에 흩어진 CDN 서버가 사용자와 가장 가까운 곳에서 이미지를 보내주므로 훨씬 빠르게 뜹니다.
    3. **캐싱 제어:** 이미지는 잘 안 바뀌는 데이터이므로, CDN을 통해 브라우저에 "이건 한 달 동안 다시 다운로드하지 마"라고 강하게 명령(Cache-Control)할 수 있습니다.
*   Alpha vs Beta: 실험 기능의 단계 둘 다 '개발 중'이라는 점은 같지만, 완성도와 안정성에서 차이가 납니다.

    <table><thead><tr><th width="101.5999755859375">구분</th><th>알파 (Alpha)</th><th>베타 (Beta)</th><th>정식 (Stable/GA)</th></tr></thead><tbody><tr><td><strong>개발 단계</strong></td><td>초기 내부 테스트 단계</td><td>출시 직전 공개 테스트 단계</td><td>개발 완료 및 공식 지원</td></tr><tr><td><strong>주요 목적</strong></td><td>핵심 기능 구현 및 큰 버그 수정</td><td>실사용 환경 피드백 및 안정성 검증</td><td>실제 서비스 운영 (Production)</td></tr><tr><td><strong>안정성</strong></td><td><strong>매우 낮음</strong> (예상치 못한 에러 빈번)</td><td><strong>보통</strong> (대부분의 기능 작동)</td><td><strong>높음</strong> (신뢰할 수 있음)</td></tr><tr><td><strong>설계 변경</strong></td><td>기능이나 API가 통째로 바뀔 수 있음</td><td>큰 틀은 유지하며 세부 버그 수정</td><td>하위 호환성을 지키며 업데이트</td></tr><tr><td><strong>사용 권장</strong></td><td>개인적인 실험 프로젝트</td><td>초기 도입을 검토 중인 프로젝트</td><td><strong>실제 상용 서비스</strong></td></tr></tbody></table>
* **ORM(Object-Relational Mapping)**: 데이터베이스(SQL)를 자바스크립트 객체처럼 다루게 해주는 도구
* Redis(Remote Dictionary Server)
  * 메모리(RAM) 위에서 돌아가는 초고속 데이터 저장소.
  * 일반적인 데이터베이스(MySQL, MongoDB 등)가 딱딱한 하드디스크(SSD)에 데이터를 저장한다면, Redis는 컴퓨터의 전원이 켜져 있는 동안만 유지되는 **휘발성 메모리(RAM)**&#xB97C; 사용합니다.
  * 서버 액션 안에서 복잡한 계산을 한 번 한 뒤 그 결과를 Redis에 딱 넣어두면, 다음번에 똑같은 요청이 왔을 때 DB까지 안 가고 Redis에서 바로 꺼내줄 수 있어 속도가 비약적으로 상승합니다.
* headless CMS: "어떻게 보여줄지(디자인)"는 신경 쓰지 않고, "어떤 내용인지(데이터)"에만 집중하는 방식
  * Head(머리):사용자가 실제로 보게 되는 화면(UI/프론트엔드)
  * Headless CMS: '화면(머리)'이 없고 '데이터(몸통)'만 있는 콘텐츠 관리 시스템
