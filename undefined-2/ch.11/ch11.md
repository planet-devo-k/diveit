# Chapter 11

## 1. app 디렉터리의 등장

13버전 이전까지 모든 페이지는 각각의 물리적으로 구별된 파일로 독립되 있었음. 페이지 공통으로 무언가를 집어넣을 수 있는 곳은 \_document와 \_app이 유일했음.

* \_document: 페이지에서 쓰이는 과 태그를 수정하거나 SSR시 Styled-components 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용됨.
* \_app: 페이지를 초기화하기 위한 용도로 사용됨.

이전의 12버전까지는 페이지 공통 레이아웃을 유지할 수 있는 방법은 \_app이 유일했음. 그러나 이 방식은 \_app에서 밖에 할 수 밖에 없어 제한적이고, 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족함. 이를 극복하기 위해 나온 것이 app 레이아웃

### 1. 라우팅

#### 라우팅을 정의하는 법

* Next.js 12이하 : /pages/a/b.tsx와 /pages/a/b/index.tsx 는 모두 동일한 주소로 변환됨
* Next.js 13 app: /app/a/b는 /a/b로 변환되며, 파일명은 무시된다. 폴더명까지만 주소로 변환된다.

#### layout.js

13부터 app디렉터리 내부의 폴더명이 라우팅이 되며, 이 포러뎅 포함될 수 있는 파일명은 몇가지로 제한되어 있음. 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미침.

#### page.js

이전까지 Next.js에서 일반적으로 다뤘던 페이지를 의미한다. 이 페이지가 받는 props는 다음과 같음

* params: 옵셔널 값으로 앞서 설명한 \[…id]와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어옴
* searchParams: URL에서 ?a=1과 같은 URLSearchParams를 의미. 예를 들어 ?a=1\&b=2로 접근할 경우 searchParams에는 { a: ‘1’, b: ‘2’ }라는 자바스크립트 객체 값이 오게됨. 이 값은 layout에서 제공되지 않음.

규칙

* page도 역시 app 디렉터리의 예약어이다. 무조건 page.{js|jsx|ts|tsx} 로 사용해야 하며, 레이아웃 이외의 다른 목적으로 사용할 수없음
* page도 역시 내부에서 반드시 export default로 내보내는 컴포넌트가 있어야 함.

### error.js

error.js는 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트. 이 error.js를 사용하면 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능

#### not-found.js

특정 라우팅 하위의 주소를 찾을 수 업슨 404페이지를 렌더링할 때 사용

#### loading.js

리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있음

#### route.js

app 디렉터리가 정식으로 출시되면서 이전까지 지원하지 못했던 /page/api에 대한 app 디렉터리 내부의 지원도 추가됨. /api에 대한 파일명 라우팅이 없어짐.

## 2. 리액트 서버 컴포넌트

### 1. 기존 리액트 컴포넌트와 서버사이드 렌더링의 한계

리액트의 컴포넌트 : 클라이언트에서 작동. 브라우저에서 JS코드 처리가 이뤄짐.

* 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없음
* 백엔드 리소스에 대한 직접적인 접근이 불가능
* 자동 코드 분할이 불가능 리액트에서는 lazy를 이용해 구현해왔지만. 일일이 lazy로 감싸야 하며, 컴포넌트가 호출되고 if 문을 판단하기 전까지 어떤 지연로딩한 컴포넌트를 불러올 지 알 수 없음.
* 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움. 부모 컴포넌트의 요청과 렌더링이 결정되기 전까지 부모 컴포넌트의 결과물에 의존하는 하위 컴포넌트들의 서버 요청이 지연되고 아직 렌더링될 준비가 되지 않았음을 나타내는 불필요한 렌더링까지 발생.
* 추상화에 드는 비용이 증가함 리액트는 템플릿 언어로 설계되지 않음. 리액트는 자바스크립트를 기반으로 함수나 클래스를 사용해 다양한 작업을 수행할 수 있게끔 제공한다. 이는 개발자에게 자유를 주지만 문제는 추상화가 복잡해질수록 코드의 양은 많아지고 런타임시 오버헤드가 발생할 수 있음. 템플릿 언어: HTML에 특정 언어의 문법을 집어넣어 사용할 수 있는 것을 의미함.

### 2. 서버 컴포넌트란?

하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 \*\*`서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법`\*\*을 의미. 명심해야 할것은 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다는 것임.

![React Server Components.png](attachment:15082e4d-d57a-42a2-b363-19f58563955a:React_Server_Components.png)

이러한 구조가 가능한 것은 children으로 자주 사용되는 ReactNode에 달려있음.

```jsx
// ClientComponent.jsx
'use client'
// ❌ 이렇게 클아이언트 컴포넌트에서 서버 컴포넌트를 불러오는 건 불가능
import ServerComponent from './ServerComponent.server'
export default function ClientComponent () {
	return (
		<div>
			<ServerComponent/>
		</div>
	)
}
'use client'
// ClientComponent.jsx
export default function ClientComponent({ children }) {
	return (
		<div>
			<h1>클라이언트 컴포넌트</h1>
			{children}
		</div>
	)
}

// ServerComponent.jsx
export default function ServerComponent() {
	return <div>서버 컴포넌트</div>
}

// ParentServerComponent.jsx
// 이 컴포넌트는 서버 컴포넌트 or 클라이언트 컴포넌트일 수 있음
// 따라서 두군데 모두에서 사용가능
import ClientComponent from './ClientComponent'
import ServerComponent from './ServerComponent'
export default function ParentServerComponent () {
	return (
		<ClientComponent>
			<ServerComponent/>
		</ClientComponent>
	)
}
```

여기서 한가지 눈에 띄는 것은 서버 컴포넌트와 클라이언트 컴포넌트가 있으며, 두군데 모두 사용할 수 있는 공용 컴포넌트가 있다는 것임.

* 서버 컴포넌트
  * 요청이 오면 서버에서 딱 한번 실행됨. ⇒ 상태를 가질 수 없음(훅 사용불가)
  * 렌더링 생명 주기도 사용 불가.
  * effect나 state에 의존하는 사용자 정의 훅 또한 사용할 수 없음.
  * 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API, window, document에 접근 불가
  * DB, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/await으로 접근 가능. 컴포넌트 자체가 async한 것이 가능
  * 다른 서버 컴포넌트를 렌더링, div,p,span 같은 요소를 렌더링, 클라이언트 컴포넌트를 렌더링 할 수있음
* 클라이언트 컴포넌트
  * 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나 실행할 수 없음
  * 그러나 앞의 구조처럼 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 것은 가능.
  * 이 두 가지 예외사항을 제외하면 일반적으로 우리가 알고 있는 리액트 컴포넌트와 같음. state, effect, 브라우저 API 사용 가능.
* 공용 컴포넌트
  * 서버와 클라이언트 모두에서 사용 가능. 공통으로 사용할 수 있는 만큼 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 됨.

리액트가 컴포넌트 구별하는 법

모든것을 공용 컴포넌트로 판단하며, 클라이언트 컴포넌트는 ‘use client’로 명시적으로 선언 가능.

### 3. 서버 사이드 렌더링과 서버 컴포넌트의 차이

서버 컴포넌트는 SSR과는 전혀 다른 개념으로 볼 수 있음.

SSR: 응답받은 페이지 전체를 HTML로 렌더링 하는 과정을 서버에서 수행한 후, 그 결과를 클라이언트에 내려준다. 이후 클라이언트에서 하이드레이션을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행. SSR의 목적은 **`정적인 HTML을 빠르게 내려주는 데`** 초점을 두고있음. 하지만 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고, 파싱하고 실행하는데 비용이 듦

따라서 이후에는 SSR과 서버컴포넌트를 모두 채택하는 것도 가능해질 것. 서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해 제공받은 후 클라이언트 컴포넌트는 SSR로 초기 HTML로 빠르게 전달 받을 수 있음. 이 두가지 방법을 결합하면 클라이언트 및 서버 컴포넌트를 빠르게 보여줄 수 있고, 클라이언트에서 내려 받아야 하는 자바스크립트의 양도 줄어들 수 있음.

결론적으로 둘은 대체재가 아닌 상호보완하는 개념

> [RSC, 처음부터 실수였던 것은 아닐까](https://www.reddit.com/r/reactjs/comments/1pg6s6c/react_server_component_maybe_a_mistake_from_the/)

### 4. 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작됨. 루트에 있는 컴포넌트 ⇒ 서버 컴포넌트
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화 함. 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타냄. 브라우저는 이후에 이 결과물을 받아 역직렬화한 다음 렌더링을 수행
3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나감. 그리고 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋함.

## 3. Next.js에서의 리액트 서버 컴포넌트

기본적인 서버 컴포넌트의 제약은 동일함. Next.js의 루트 컴포넌트는 pages.js. layout.js 도 마찬가지로 서버 컴포넌트로 작동함.

### 1. 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

/app 디렉터리 내부에서는 삭제되었으며, 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄짐.

### 2. 정적 렌더링과 동적 렌더링

Next.js 13에서는 이제 정적인 라우팅에 대해서는 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀고, 동적인 라우팅에 대해서는 서버에 매번 요청이 들어올 때마다 컴포넌트를 렌더링하도록 변경

### 3. 캐시와 mutating, 그리고 revaildating

Next.js는 fetch의 기본 작동을 재정의해 { next: {revalidate?: number | false\}}를 제공. 이를 바탕으로 데이터의 유효한 시간을 정해두고 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링하는 것이 가능.

1. 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여줌
2. 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지
3. 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여줌
4. Next.js는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러옴
5. 4번의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고 그렇지 않다면 과거 데이터를 보여줌

이러한 캐시를 전체적으로 무효화 하고 싶다면 router.refresh() 사용. 이 작업은 브라우저나 리액트의 state에 영향을 끼치지 않음.

### 4. 스트리밍을 활용한 점진적인 페이지 불러오기

스트리밍을 활용하면 모든 데이터가 로드될 때까지 기다리지 않아도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여주는 방법이 가능.

* 경로에 loading.tsx 배치
* Suspense 배치

## 4. 웹팩의 대항마, 터보팩의 등장

`next build --turbo` 명령어를 통해 터보팩을 이용해 빌드 가능

## 5. 서버 액션

API를 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능

서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있음

서버 액션을 만들려면 먼저 함수 내부 또는 파일 상단에 ‘use server’ 지시자를 선언해야 함

### 1. form의 action

```jsx
export default function Page() {
  async function handleSubmit() {
    "use server";

    console.log("해당 작업은 서버에서 수행합니다. 따라서 CORS 이슈가 없습니다.");

    const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
      method: "POST",
      body: JSON.stringify({
        title: "foo",
        body: "bar",
        userId: 1,
      }),
      headers: {
        "Content-Type": "application/json; charset=UTF-8",
      },
    });

    const result = await response.json();
    console.log(result);
  }
  return (
    <form action={handleSubmit}>
      <button type="submit">form 요청 보내기</button>
    </form>
  );
}
```

개발자 도구의 네트워크 탭에서 확인해보면 /server-action/form으로 요청이 수행되고, 페이로드에는 앞서 보낸 poset 요청이 아닌 ACTION\_ID라는 액션 구분자만 있는 것을 확인할 수 있음. 그리고 이를 처리하는 서버에서는 다음과 같은 내용이 미리 빌드됨

```jsx
// .next/server/app/server-action/form/page.js

// 해당 페이지에서 수행하는 서버 액션을 모아둠.
const actions = {
	// 앞서 페이로드에서 본 액션 아이디를 확인할 수 있음.
	d0b122c...: () =>
		Promise.resolve(/*import(_) eager*/)
			.then(__webpack_require__.bind(__webpack_require__, 5948))
			.then((mod)=> mod['$$ACTION_0'])
}

// ...

// 해당 페이지
function Page () {
	async function handleSubmit() {
		return $$ACTION_0(handleSubmit.$$bound)
	}
	// ...
}

//...

async funciton $$ACTION_0(closure) {
	console.log('이 작업은 서버에서 수행합니다. 따라서 CORS이슈가 없습니다.')
	const response = await fetch('https://jsonplaceholder.typicode.com/posts',{
		method: 'POST',
			body: JSON.stringify({
				title: 'foo',
				body: 'bar',
				userId: 1,
			}),
			headers: {
				'Content-Type': 'application/json; charset=UTF-8',
			},
		})

		const result = await response.json()
		console.log(result)
	}
```

위 코드를 실행하면 클라이언트에서는 현재 라우트 주소와 ACTION\_ID만 보내고 그 외에는 아무것도 실행하지 않는 것을 볼 수 있음. 그리고 서버에서는 요청받은 라우트 주소와 ACTION\_ID를 바탕으로 실행해야 할 내용을 찾고, 이를 서버에서 직접 실행함. ⇒ 클라이언트 번들링 결과에는 포함되지 않고 서버에서만 실행되는 서버액션을 만들수 있음.

또 form을 서버액션과 함께 사용하면 form을 기반으로 한 데이터 추가 및 수정 요청을 좀 더 자연스럽게 수행할 수 있다. 그리고 Next.js에서 관리하는 캐시를 효과적으로 초기화할 수 있으므로 사용자에게 더욱 자연스러운 사용자 경험을 안겨줄 수 있음.

### 2. input의 submit과 image의 formAction

form.action과 마찬가지로 input type=’submit’ 또는 input type=’image’에 formAction prop으로도 서버액션을 추가할 수 있음.

### 3. startTransition과의 연동

useTransition에서 제공하는 startTransition에서도 서버액션을 활용할 수 있음.

### 4. server mutation이 없는 작업

```jsx
export default funciton Page() {
	async function handleClick() {
		'use server'

		// server mutation이 필요없는 작업
	}

	return <button onClick={handleClick}>form 요청 보내기</button>
}
```

### 5. 서버 액션 사용 시 주의할 점

* 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없음
* 서버 액션을 import 하는 것 뿐만 아니라 props 형태로 서버액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능

## 6. 그 밖의 변화

* 프로젝트 전체 라우트에서 사용할 수 있는 미들웨어가 강화, SEO를 쉽게 작성할 수 있는 기능 추가, 정적으로 내부 링크를 분석할 수 있는 기능 등…
