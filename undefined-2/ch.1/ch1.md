# Chapter 1

### 1. 동등 비교

* 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나: props의 동등 비교에 따른 결과
  * 프롭스의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄짐
* 가상 DOM, 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등의 모든 작업은 동등 비교를 기반으로 함.

#### 1. 데이터 타입

* 원시타입
  * boolean: 참과 거짓만을 가질 수 있는 데이터 타입. truthy, falsy한 값이 존재
  * null: 아직 값이 없거나 비어있는 값
  * undefined : 선언후 값을 할당하지 않은 변수, 인수에 자동으로 할당되는 값
  * number
  * string: 텍스트 타입의 데이터를 저장하기 위해 사용. ’, “, \`(백틱) 으로 표현 가능
    * 템플릿 리터럴 : 백틱을 사용해 표현한 문자열. 줄바꿈 가능, 문자열 내부에 표현식 쓸 수 있음
    * 특징 : 변경 불가능한 원시타입. ⇒ 변경할 수 없음
  * symbol : ES6에서 새롭게 추가된 타입. 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어짐.
  * bigint: 기존 숫자형이 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 ES2020에서 새로 나온 타입.
* 객체타입
  * object( 원시타입 이외에 모든 것)
    * 참조를 전달한다고 해서 참조 타입으로 불림.

#### 2. 값을 저장 하는 방식의 차이

* 값을 저장하는 방식의 차이가 동등 비교시 차이를 만드는 원인이 됨

#### 3. 다른 비교공식 Object.is

* \== vs [Object.is](http://object.is) : == 비교는 양쪽 타입이 다르면 강제 형변환 후 비교. Object.is는 강제형변환 하지 않음.
* \=== vs [Object.is](http://object.is) : Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교
* 주의할 점: Object.is를 사용해도 객체 비교에는 별 차이가 없음.

#### 4. 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교는 [Object.is](http://object.is). 이것은 ES6에서 제공하는 기능이기 때문에 폴리필을 함께 사용

* 폴리필이란?

리액트에서는 이 [Object.is](http://object.is) 를 기반으로 동등비교를 하는 shallowEqual 함수를 만들어 사용.

이 함수는 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 사용됨

* 비교하는 순서
  * Object.is로 비교 수행 ⇒ 객체 간 얕은 비교 한번 더 수행

### 2. 함수

#### 1. 함수란?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸 실행단위로 만들어 놓은 것

리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따름.

#### 2. 함수를 정의하는 4가지 방법

* 함수 선언문
  * 표현식이 아닌 일반 문(statement)
  * 코드의 문맥에 따라 자바스크립트 엔진이 동일한 함수를 표현식으로 해석하는 경우가 있음.
* 함수 표현식
  * 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
  * 자바스크립트에서 함수는 일급 객체 ⇒ 매개변수, 반환값이 될수 있고, 할당 가능하기 때문
* 함수 표현식과 선언식의 차이
  * 호이스팅 여부
    * 함수 선언문이 코드 맨 앞단에 작성된 것처럼 작동하는 것. 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다. 함수 표현식은 호이스팅 되는 시점에서 var의 경우 undefined로 초기화한다는 차이가 있음
* 어떤 것이 좋을까?
  * 함수를 자유롭게 선언, 명시적으로 함수를 구별하고 싶다 ⇒ 함수 선언문
* Function 생성자
  * 매개 변수, 함수의 몸통을 모두 문자열로 작성해야 함
* 화살표 함수
  * 타이핑할 글자 수가 줄어들어 많이 사용됨
  * 화살표 함수에서는 constructor를 사용할 수 없음
  * arguments가 존재하지 않는다 ⇒ ? 호출할때 잘 argument 넣어서 사용하지 않았나..?
  * this 바인딩의 차이: 함수 자체의 바인딩을 갖지 않아서 함수 내부에서 this 참조 시 상위 스코프의 this를 그대로 따르게 됨.

#### 3. 다양한 함수 살펴보기

* 즉시 실행 함수 : 한번만 실행되고 다시 호출할 수 없는 함수
* 고차 함수 : 함수를 인수로 받거나 결과로 새로운 함수를 반환시키는(일급객체의 특징을 활용한) 함수. 이러한 특징을 활용해 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수(고차 컴포넌트)를 만들 수 있음. ⇒ 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있음

#### 4. 주의사항

* 함수의 부수효과 최대한 억제하기
* 가능한 한 함수를 작게 만들기
* 누구나 이해할 수 있는 이름을 붙이기

### 3. 클래스

#### 1. 클래스란?

* 특정한 개체를 만들기 위한 일종의 템플릿과 같은 개념
* 클래스를 활용하면 객체를 만드는데 필요한 데이터나 이를 조작하는 코드를 추상화해 객체 생성을 편리하게 할 수 있음
* constructor : 생성자, 객체를 생성하는데 사용하는 특수한 메서드. 단 하나만 존재할 수 있으며 생성자에서 수행할 별다른 작업이 없다면 생략 가능
* 프로퍼티: 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
  * 타입스크립트에서 private, protected, public을 사용할 수 있지만 기본적으로 모든 프로퍼티는 public
* getter와 setter : 클래스에서 값을 가져올 때 사용
  * getter 사용 ⇒ get \~\~(getter이름 선언)
  * setter 사용 ⇒ set \~\~(setter 이름 선언)
* 인스턴스 메서드 : 클래스 내부에서 선언한 메서드. 프로토타입 메서드로 불리기도 함
* 프로토타입 확인하기
  * Object.getPrototypeOf
  * `__proto__` : 가급적 사용하면 안됨. 호환성을 지키기 위해서만 존재하는 기능이기 때문
  * 프로토타입 체이닝 : 객체에서 직접 선언하지 않아도 프로토타입에 있는 메서드를 찾아 실행을 도와주는 것. 자기자신 ⇒ Object(최상위객체) 까지 훑음. 비슷한 원리로 동작하는 메서드로 toString이 있음.
* 정적 메서드 : 클래스의 이름으로 호출할 수 있는 메서드
  * 정적 내부의 this : 사용 불가 ⇒ static getDerivedStateFromProps(props, state) 에서도 접근할 수 없음.
* 상속
  * extends: 기존 클래스를 상속받아 자식 클래스에서 상속받은 클래스를 기반으로 확장하는 개념

#### 2. 클래스와 함수의 관계

* 클래스 작동을 생성자 함수로 유사하게 재현할 수 있음.
* 클래스는 문법적 설탕의 역할을 함.
* 클래스는 프로토
* 타입을 기반으로 작동

### 4. 클로저

#### 1. 정의

* 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합 변수가 코드 내부에서 어디서 선언됐는지를 말하는것

#### 2. 스코프

* 전역 스코프 : 전역 레벨에 선언하는것
  * 브라우저 환경에서 전역객체는 window, node.js환경에서는 global 객체에 바인딩
* 함수 스코프
  * 기본적으로 함수 레벨 스코프를 따름. {} 블록이 스코프를 결정하지 않음

#### 3. 클로저의 활용

* 전역 스코프 : 어디서든 원하는 값을 꺼내올 수 있음 ⇒ 누구나 망가뜨릴 수 있음
* 내부 상태값을 리액트가 별도로 관리하는 클로저 내부에서만 접근 가능
* 리액트에서의 클로저
  * useState
    * useState 내부의 최신값을 setState가 확인 할 수 있는 이유는 클로저가 useState내부에서 활용되었기 때문

#### 4. 주의할 점

* 기본 개념을 주의깊게 살펴봐야 클로저를 제대로 활용할 수 있음
* 클로저를 사용하는데는 비용이 듦

### 5. 이벤트 루프와 비동기 통신의 이해

* 자바스크립트는 싱글스레드에서 동기방식으로 작동하지만 많은 양의 비동기 작업이 이뤄짐.

#### 1. 싱글 스레드

* 프로세스: 프로그램을 구도앻 프로그램의 상태가 메모리 상에서 실행되는 작업 단위
* 스레드 : 프로세스보다 더 작은 실행단위
* 자바스크립트의 모든 코드는 동기식으로 한번에 하나씩 순차적으로 처리됨

#### 2. 이벤트 루프

* 이벤트루프: 자바스크립트 런타임 외부에서 자바스크립트 비동기 실행을 돕기 위해 만들어진 장치
* 호출 스택과 이벤트 루프
  * 호출 스택: 자바스크립트에서 수행해야할 코드나 함수를 순차적으로 담아두는 스택
  * 이벤트 루프: 호출 스택이 비어있는지 여부를 확인하고, 태스크 큐에 대기중인 함수가 있는지 반복해서 확인하는 역할을 함.
  * 태스크 큐 : 실행해야할 태스크의 집합
  * 비동기 함수는 누가 수행하는가 ⇒ 태스크 큐가 할당되는 별도의 스레드에서 수행

#### 3. 태스크 큐와 마이크로 태스크 큐

* 이벤트 루프는 하나의 마이크로 태스크 큐를 가지며, 기존의 태스크 큐와는 다른 태스크를 처리함.
* 렌더링은 마이크로 태스크큐를 실행한 뒤에 일어남.

### 6. 리액트에서 자주 사용하는 자바스크립트 문법

#### 1. 구조분해할당

* 배열 구조 분해 할당
  * ,의 위치에 따라 값이 결정됨.
  * … 을 사용하면 나머지 모든 값을 해당 변수에 배열로 넣게 됨
* 객체 구조 분해 할당 : 객체에서 값을 꺼내온뒤 할당 하는 것
  * 배열 구조 분해 할당과 달리 객체는 객체 내부 이름으로 꺼내옴

#### 2. 전개구문

* 구조 분해 할당과는 다르게 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 전개해 간결하게 사용할 수 있는 구문
* 배열의 전개 구문
* 객체의 전개 구문

#### 3. 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식

#### 4. Array 프로토타입의 메서드(map, filter, reduce, forEach)

* Array.prototype.map
  * 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드
* Array.prototype.filter
  * 콜백함수를 인수로 받으며, 이 콜백함수에서 truty 조건을 만족하는 경우에만 해당 원소를 반환
* Array.prototype.reduce
  * 콜백함수와 함께 초킷값을 추가로 인수를 받아 이 초깃값에 따라 배열, 객체 또는 그 외의 다른 무언가를 반환할 수 있는 메서드.
* Array.prototype.forEach
  * 콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백함수를 실행하기만 하는 메서드. 아무런 반환값이 없으며, 에러를 던지거나 프로세스를 종료하지 않는 이상 멈출수 없음.

#### 5. 삼항 조건 연산자

자바스크립트에서 유일하게 3개의 피연산자를 취할 수 있는 문법. 리액트에서 자주 쓰이며. 특히 JSX내부에서 조건부로 렌더링 하기 위해 가장 널리 쓰이는 방법. 하지만 가급적 중첩해서 쓰지 않는 편이 좋음

### 7. 타입스크립트

### 1. 타입스크립트란?

자바스크립트의 한계를 벗어나 타입 체크를 정적으로 런타임이 아닌 빌드 타임에 수행할 수 있게 해주는 슈퍼셋. 하지만 자바스크립트에서 불가능한 일은 타입스크립트에서도 불가능함.

***

### 2. 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

#### any 대신 unknown 사용하기

예외적인 경우에만 사용하는 것이 좋음 대신 불가피하게 타입을 단정할 수 없는 경우에는 unknown을 사용하는 것이 좋음. unknown은 모든 값을 할당할 수 있는 top type 으로 어떤 값도 할당할 수 있다. 하지만 any와는 다르게 바로 사용하는 것은 불가능. bottom type으로는 never가 존재.

#### 타입 가드 적극적으로 활용하기

타입을 사용하는 쪽에서는 타입을 최대한 좁히는 것이 좋음. ⇒ 조건문과 함꼐 타입 가드 사용하기

1. instanceof, typeof
2. in

#### 제네릭

* 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구. 제네릭을 사용하면 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성 가능
* 리액트에서 제네릭 사용하는 대표적인 예제
  * useState: useState에 제네릭으로 타입을 선언하면 state 사용과 기본값 선언을 좀 더 명확하게 할 수 있다. ⇒ 기본값을 명확힉 하지 않을 경우 undefined로 추론하는 문제를 해결할 수 있음
* 제네릭은 하나 이상 사용할 수도 있으며, 적절히 네이밍 하는것이 좋음

#### 인덱스 시그니쳐

* 객체의 키를 정의하는 방식. 인덱스 시그니처를 사용하면 키에 원하는 타입을 부여할 수 있음. 동적인 객체를 정의할 떄 유용하지만 존재하지 않는 키로 접근하면 undefined를 반환할 수 있음. 따라서 객체의 키는 동적으로 선언되는 경우를 최대한 지양해야 하고, 객체의 타입도 필요에 따라 좁혀야 함.
  1. Record\<key,value> 사용하기
     1. 하지만 키과 값을 추출하여 사용할 경우 문제가 발생할 수 있음. ⇒ Object.keys는 string\[]을 반환하며, 이는 인덱스 키로 접근할 수 없기 떄문
  2. 가져온 키를 단언하기
* Object.keys 가 string\[]으로 강제되어있는 이유
  * 자바스크립트의 특징과, 이것을 구현하기 위한 타입스크립트의 구조적 타이핑의 특징 때문 ⇒ 자바스크립트는 다른 언어에 비해 객체가 열려있는 구조로 만들어져 있어 덕타이핑으로 객체를 비교해야 하는 특징 때문.
  * 타입스크립트는 모든 키가 들어올 수 있는 가능성이 열려있는 객체의 키에 포괄적으로 대응하기 위해 string\[]으로 타입을 제공하는 것.
  * 덕 타이핑 : 객체의 타입이 클래스 상속, 인터페이스 구현등으로 결정되는 것이 아닌 어떤 객체가 필요한 변수와 메서드만 지니고 있다면 해당 타입에 속하도록 인정해주는 것을 의미

### 3. 타입스크립트 전환 가이드

#### tsconfig.json 먼저 작성하기

#### JSDOC과 [ts-check를 활용해 점진적으로 전환하기](https://www.notion.so/ts-check-28bf98624f9980f3b915e93225c29f5a?pvs=21)

#### 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기

#### 파일단위로 조금씩 정리하기
