# Chapter 7

크롬 개발자 도구(Chrome DevTools)는 **자바스크립트** 메모리, 네트워크 통신, 실제 **HTML/CSS** 등 웹 애플리케이션의 환경 전반을 디버깅하고 분석하는 데 사용되는 핵심 도구입니다.

> 💡 **시크릿 모드 권장:** 브라우저 확장 프로그램이 웹페이지의 전역 변수나 HTML 요소에 불필요한 정보를 추가하여 디버깅을 방해할 수 있습니다. 이를 방지하기 위해 **시크릿 모드** 또는 **개인정보 보호 모드**에서 개발자 도구를 실행하는 것이 좋습니다.

***

## 1. Elements 탭 (요소 탭)

웹페이지를 구성하는 \*\*HTML(DOM)\*\*과 **CSS** 정보를 확인하고 실시간으로 수정할 수 있습니다. 개발자 도구에서 DOM/CSS를 수정하면 Hot Reload를 기다릴 필요 없이 즉석에서 변화를 확인할 수 있습니다.

### 주요 디버깅 기능

* **DOM 중단점 (Breakpoints):** 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면, 해당 요소를 선택하고 우클릭하여 **중단 위치**를 설정할 수 있습니다.
  * 중단점과 관련된 작업이 발생하면 브라우저 렌더링을 멈추고 해당 변경을 일으킨 소스 코드를 보여줍니다.
* **이벤트 리스너:** 현재 요소에 부착된 이벤트 리스너를 확인합니다.
  * 상위 요소의 리스너를 체크 해제하면 해당 요소에 명확하게 부착된 이벤트만 볼 수 있습니다. (이벤트 버블링으로 발생한 이벤트는 확인 불가)
* **속성:** 자바스크립트에서 접근 가능한 해당 요소의 **모든 속성값**을 보여줍니다.
* **접근성:** 스크린리더기 등이 활용하는 접근성 관련 값을 확인합니다.

***

## 2. Sources 탭 (소스 탭)

웹 애플리케이션을 불러오기 위해 실행되거나 참조된 모든 파일(JS, CSS, HTML, 폰트 등)을 확인하고 자바스크립트 디버깅을 수행합니다.

### 자바스크립트 디버깅 (중단점)

* **소스 중단점 (Line Breakpoint):** 디버깅하고 싶은 코드 줄의 **줄 번호**를 클릭하여 중단점을 설정합니다.
  * 이는 코드에 `debugger;`를 선언하는 것과 동일한 역할을 하지만 소스 코드를 오염시키지 않아 더 유용합니다.
  * 중단된 시점에서 이전 할당된 **변수의 값**을 육안으로 확인 가능합니다.
* **감시 (Watch):** **감시하고 싶은 변수**를 선언하고, 현재 값이 무엇인지 **실시간**으로 해당 변수의 정보를 확인합니다. `console.log`보다 빠르고 효율적으로 정보를 확인할 수 있습니다.
* **범위 (Scope):** 현재 중단점에서의 **스코프**를 보여주며, 접근 가능한 값(클로저, 전역 스코프 등)을 확인합니다.
* **호출 스택 (Call Stack):** 현재 중단점까지 오게 된 **함수 호출 순서**를 확인합니다.
* **XHR/가져오기 중단점 (API Request Breakpoints):** 특정 URL이나 조건을 설정해두면 해당 URL로 **API 요청이 발생하는 순간** 실행을 중단시킵니다.
* **CSP 위반 중단점 (CSP Violation Breakpoints):** **콘텐츠 보안 정책(CSP)** 위반 오류가 발생하는 순간 실행을 멈춰서 악성 스크립트나 허용되지 않은 리소스 로드 시도를 추적할 수 있습니다.

***

## 3. Network 탭 (네트워크 탭)

HTTP 요청, 웹 소켓 등 웹페이지가 외부 데이터와 통신하는 모든 정보를 기록합니다.

### 집중 확인 항목

* **불필요하거나 중복된 요청**이 없는지 확인합니다. (리액트에서 동일 주소 요청이 2번 실행되는 경우는 잘못된 `useEffect` 사용이 원인일 수 있습니다.)
* **리소스 크기**가 너무 크지 않은지 확인합니다. (압축: **gzip/brotli**, 이미지 최적화 필요)
* **리소스 로딩 속도**가 적절한지, 또는 속도가 오래 걸리는 리소스가 있는지 확인합니다.
* **우선순위:** 노출 영역이 큰 중요한 콘텐츠가 우선적으로 다운로드되어 페이지를 자연스럽게 구성하는지 확인합니다.
* 하단에서 **총 요청 건수**와 **총 리소스 크기**를 확인 가능하며, 모바일 사용자의 네트워크 비용 및 속도에 직접적인 영향을 미치므로 최적화가 필수입니다.

***

## 4. Memory 탭 (메모리 탭)

메모리 누수, 속도 저하, 웹페이지 프리징 현상을 진단합니다. 다른 탭과 달리 **프로파일링 작업**을 거쳐야 정보를 볼 수 있습니다.

### 자바스크립트 VM 인스턴스

* **자바스크립트 VM 인스턴스:** 자바스크립트 실행 엔진이 만든 실행 환경(힙 + 스택)의 실체입니다. 브라우저는 웹사이트 실행 시 여러 개의 독립된 VM 인스턴스(웹 워커, `iframe`, 확장 프로그램 등)를 만들 수 있습니다.
* **힙 크기:** 해당 인스턴스가 점유하고 있는 자바스크립트 힙 크기를 실시간으로 보여주며, 이 크기가 불필요하게 늘어나지 않는지 확인해야 합니다.

### 메모리 프로파일 유형

| 유형              | 기능                                | 활용 목적                                                   |
| --------------- | --------------------------------- | ------------------------------------------------------- |
| **힙 스냅샷**       | 현재 메모리 상황을 **사진 찍듯이 촬영**.         | **메모리 누수 진단**의 핵심. 두 개 이상의 스냅샷을 촬영하여 **차이점**을 비교 분석합니다. |
| **타임라인의 할당 계측** | **시간의 흐름**에 따른 메모리 변화를 확인.        | 페이지 로딩이나 특정 상호작용 전후의 메모리 변화 과정 추적.                      |
| **할당 샘플링**      | 시간의 흐름에 따른 메모리 점유를 **함수 단위**로 분석. | 장시간 디버깅 또는 메모리 누수 발생 지점을 **실행 스택별로** 확인.                |

### 힙 스냅샷 분석 (메모리 누수 찾기)

1. **두 시점 비교:** 누수가 의심되는 인터랙션 전후로 스냅샷 2개를 촬영합니다.
2. **차이 비교:** `스냅샷1에서 스냅샷2 사이에 할당된 객체`를 선택하고 \*\*얕은 크기(Shallow Size)\*\*를 기준으로 정렬합니다.
3. **누수 객체 식별:** **얕은 크기**는 작으나 \*\*유지된 크기(Retained Size)\*\*가 큰 객체(해당 객체가 참조하는 모든 자식 객체 크기를 합한 값)를 찾습니다. 이는 복잡한 참조 관계를 가지며 메모리를 점유하고 있는 누수 지점일 가능성이 높습니다.

***

## 5. Next.js 환경 디버깅 (SSR/서버 환경)

클라이언트 환경과 달리, SSR을 수행하는 **서버 환경**의 메모리 누수는 모든 사용자에게 영향을 미치는 심각한 서버 부하를 초래합니다.

### 서버 디버그 환경 설정

1. **디버그 모드 실행:** Next.js 프로젝트를 실행할 때 `NODE_OPTIONS='--inspect' next dev` 와 같이 `NODE_OPTIONS='--inspect'` 인수를 추가하여 디버그 모드로 실행합니다.
2. **크롬 연결:** 크롬 주소창에 `chrome://inspect`로 이동하여 **Node.js 인스턴스**에 연결하고 개발자 도구를 엽니다.

### 트래픽 유입 시뮬레이션

서버 환경의 메모리 누수는 사용자가 유입되면서 발생하는 경우가 많습니다.

*   **`ab` (Apache Bench):** HTTP 서버의 성능을 검사하는 오픈소스 도구입니다. 이를 사용하여 서버에 트래픽을 발생시켜 메모리 누수를 시뮬레이션합니다.

    ```bash
    ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
    # 10000회 요청, 동시 요청 50개 시뮬레이션
    ```

### Next.js 메모리 누수 지점

* `getServerSideProps`와 같이 **요청이 있을 때마다 실행되는 함수**가 외부 스코프의 변수(Global Variable)에 의존하는 작업을 수행할 경우, 메모리 누수가 발생할 수 있으므로 최대한 **순수 함수**로 만들어야 합니다.
