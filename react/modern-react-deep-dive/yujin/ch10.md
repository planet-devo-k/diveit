# 🚀 React Evolution Deep Dive: v17, v18, v19

## React 17: 점진적 업그레이드와 기초 다지기 (2020)

리액트 17은 새로운 기능 추가보다 **"호환성"**과 **"이벤트 시스템 개편"**에 집중하여 대규모 애플리케이션의 유지보수성을 높였습니다.

### 1. 점진적인 업그레이드(Gradual Upgrades) 지원

과거에는 리액트의 새 버전이 나오면 전체 애플리케이션을 한꺼번에 업데이트해야 했습니다. 17부터는 한 애플리케이션 내에 **서로 다른 버전의 리액트가 공존**할 수 있습니다.

* **부분적 버전 관리:** 메인 트리는 v17이지만, 특정 복잡한 컴포넌트나 라이브러리 의존성이 강한 트리는 v18을 선택적으로 적용할 수 있습니다.
* **Lazy 로딩:** v17 내부에서 v16을 `lazy`로 불러오고, 별도의 루트 요소를 만들어 렌더링함으로써 버전 불일치 에러 없이 단계적으로 전환할 수 있습니다.

### 2. 이벤트 위임(Event Delegation) 방식의 변경

리액트는 성능을 위해 이벤트를 각 DOM 요소가 아닌 상위 요소에 위임하여 처리합니다. 이 부착 지점이 `document`에서 **루트 컨테이너**로 이동했습니다.

* **이유:** 여러 버전의 리액트가 섞여 있을 때, 모든 이벤트가 `document`에 달려 있으면 `stopPropagation()`을 호출해도 다른 버전의 리액트 트리로 전파되는 것을 막을 수 없었기 때문입니다.
* **격리성:** 이제 각 리액트 트리는 자신만의 루트 요소에서 이벤트를 관리하므로, 이벤트 버블링으로 인한 혼선을 방지합니다.

### 3. 새로운 JSX Transform (Import React 생략)

과거에는 JSX를 사용하기 위해 반드시 `import React from 'react'`가 필요했습니다.

* **변경:** 바벨(Babel)과 협력하여 컴파일 시점에 `react/jsx-runtime`을 자동으로 불러옵니다.
* **효과:** 불필요한 import 구문이 사라져 번들 크기가 미세하게 감소하고, 내부 로직이 간결해졌습니다. `npx react-codemod update-react-imports` 명령어로 기존 코드를 쉽게 정리할 수 있습니다.

### 4. 이벤트 풀링(Event Pooling) 제거

`SyntheticEvent` 객체를 재사용하던 시스템이 완전히 삭제되었습니다.

* **과거:** 이벤트가 발생하면 풀에서 객체를 가져오고, 핸들러가 끝나면 모든 필드를 `null`로 초기화했습니다. 이 때문에 비동기 코드 안에서 `e.target` 등에 접근하려면 `e.persist()`가 필수였습니다.
* **현재:** 메모리 할당 방식의 성능 향상으로 인해 풀링이 불필요해졌습니다. 이제 비동기/동기 상관없이 일관된 코딩이 가능합니다.

### 5. useEffect 클린업 함수의 비동기 실행

`useEffect`의 클린업 함수는 16까지 동기적으로 처리되었습니다.

* **변경:** 17부터는 화면이 완전히 업데이트(Commit)된 이후에 **비동기적으로 실행**됩니다.
* **효과:** 클린업 함수가 브라우저의 화면 그리기(Paint)를 방해하지 않아, 리렌더링 후 화면이 업데이트되는 시간(`commitTime`)이 더 빨라졌습니다.

---

## React 18: 동시성(Concurrency) 엔진의 도입 (2022)

리액트 18은 렌더링 과정을 조절하여 **"사용자 인터랙션에 더 민감하게 반응하는 UI"**를 목표로 합니다.

### 1. 동시성 렌더링(Concurrent Rendering)과 Fiber

리액트 렌더링 엔진인 **Fiber**가 작업을 쪼개고, 멈추고, 다시 시작할 수 있는 능력을 갖추게 되었습니다.

* **작업 분할:** 렌더링 중에 더 급한 작업(타이핑 등)이 들어오면 현재 렌더링을 중단하고 우선순위가 높은 작업을 먼저 처리합니다.
* **더블 버퍼링:** `current` 트리와 `workInProgress` 트리를 유지하여, 렌더링이 완전히 준비된 시점에만 화면을 교체해 깜빡임을 방지합니다.

### 2. 우선순위 제어 Hooks: useTransition & useDeferredValue

* **`useTransition`:** 상태 업데이트를 '낮은 우선순위'로 설정합니다. 무거운 리스트 렌더링 중에도 사용자가 다른 탭을 누르면 즉시 응답할 수 있게 합니다. (`isPending`을 통해 로딩 UI 표시 가능)
* **`useDeferredValue`:** 상태 값 자체를 지연시켜 처리합니다. `props`로 받은 값이나 계산이 오래 걸리는 값을 잠시 미루어 렌더링함으로써 브라우저 멈춤 현상을 해결합니다.

### 3. 외부 상태 동기화: useSyncExternalStore

리액트 외부의 데이터 소스(Redux, window 객체, DOM 등)를 안전하게 읽기 위한 훅입니다.

* **테어링(Tearing) 방지:** 동시성 모드에서 렌더링 도중 외부 데이터가 변해 화면 곳곳에 서로 다른 값이 표시되는 현상을 방지하고 리액트 렌더링과 동기화합니다.
* **구독(Subscribe) 구조:** 외부 스토어의 변경 사항을 감지하고 리렌더링을 트리거하는 표준화된 방식을 제공합니다.

### 4. 자동 배치(Automatic Batching) 강화

* **변경:** 과거에는 이벤트 핸들러 내부에서만 배치가 작동했지만, 이제는 `Promise`, `setTimeout`, 네이티브 이벤트 내부의 업데이트도 모두 하나로 묶어 처리합니다.
* **효과:** 불필요한 리렌더링 횟수를 획기적으로 줄여 성능을 최적화합니다.

### 5. 향상된 엄격 모드(Strict Mode)와 Suspense

* **엄격 모드:** 향후 도입될 "상태 유지" 기능을 대비해, 개발 모드에서 **마운트 → 언마운트 → 재마운트**를 강제 실행하여 컴포넌트의 순수성을 검사합니다.
* **Suspense 개선:** 컴포넌트가 화면에 실제로 나타날 때만 `useEffect`가 실행되도록 타이밍을 정교화했고, 서버 사이드 렌더링에서도 `Suspense`를 정식 지원합니다.

---

## React 19: 비동기 액션과 DX의 정점 (2024)

리액트 19는 비동기 작업, 폼 처리, 서버 컴포넌트를 핵심 렌더링 모델 안으로 완전히 편입시켰습니다.

### 1. Actions 시스템과 비동기 처리

리액트가 비동기 함수를 1급 개념으로 이해하기 시작했습니다.

* **`useActionState`:** 비동기 액션의 진행 상태(`isPending`), 에러 처리, 반환된 데이터를 한꺼번에 관리하는 표준 훅입니다.
* **`useOptimistic`:** "낙관적 업데이트"를 지원합니다. 서버 응답이 오기 전이라도 화면을 먼저 업데이트하고, 실패 시 자동으로 이전 상태로 롤백합니다.

### 2. 폼(Form) 처리의 패러다임 변화

* **`<form action={fn}>`:** 폼 제출 시 비동기 함수(Action)를 직접 연결할 수 있습니다. 리액트가 대기 상태를 자동 관리하며 제출 성공 후 비제어 폼을 자동으로 리셋합니다.
* **`useFormStatus`:** 폼 내부의 하위 컴포넌트에서 부모 폼이 현재 제출 중인지, 어떤 데이터를 보내고 있는지 Context 없이 확인할 수 있습니다.

### 3. 리소스 읽기를 위한 `use` API

* **Promise & Context 소비:** 렌더링 도중 `use(promise)`를 사용하여 데이터를 직접 읽을 수 있습니다. 데이터가 준비되지 않았다면 자동으로 `Suspense`가 작동합니다.
* **조건부 호출:** 기존 `useContext`와 달리 `use`는 `if`문이나 루프 안에서도 호출할 수 있어 유연성이 매우 높습니다.

### 4. 서버 컴포넌트(Server Components) 안정화

* **RSC:** 서버에서만 실행되는 컴포넌트를 통해 클라이언트 번들 크기를 줄이고 데이터 접근 속도를 높입니다.
* **Server Actions:** 클라이언트 컴포넌트에서 서버 함수를 직접 호출하는 패턴이 안정화되어 요청-응답-UI 반영 흐름이 매우 간결해졌습니다.

### 5. 메타데이터 및 리소스 호이스팅

* **Metadata 지원:** 컴포넌트 내부 어디서든 `<title>`, `<meta>`, `<link>`를 선언하면 리액트가 자동으로 HTML의 `<head>` 영역으로 이동시켜 관리합니다. 라이브러리(react-helmet 등) 의존성을 대폭 줄여줍니다.
* **Ref & Provider 개선:** `forwardRef` 없이도 `ref`를 일반 props로 전달할 수 있으며, `<Context.Provider>` 대신 `<Context>`만으로도 공급자 역할을 할 수 있습니다.

---

### 💡 요약 및 비교

| 구분 | React 17 | React 18 | React 19 |
| --- | --- | --- | --- |
| **핵심 철학** | 점진적 변화 & 시스템 안정화 | 동시성을 통한 사용자 반응성 | 비동기 액션 & 서버 통합 |
| **주요 엔진** | 동기적 Fiber (구조 개편) | 동시성 지원 Fiber | 비동기 특화 최적화 |
| **데이터 처리** | useEffect 중심 | Suspense 기반 렌더링 제어 | Actions & use() API |
| **DX 개선** | JSX Transform | 자동 배치, 신규 훅 | Ref prop, Metadata 호이스팅 |