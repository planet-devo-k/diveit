# Chapter 2

### 1. JSX (JavaScript XML)

| 구분         | 내용                                                                                                         |
| ---------- | ---------------------------------------------------------------------------------------------------------- |
| **정의**     | XML과 유사한 내장형 구문으로, 리액트에서 UI 구조를 표현하는 데 사용됩니다. ECMAScript 표준은 아니며, 트랜스파일러 (Babel)에 의해 자바스크립트로 변환됩니다.        |
| **핵심 요소**  | `JSXElement` (`<tag>...</tag>`, `<tag/>`, `<>...</>`), `JSXAttributes` (속성), `JSXChildren` (자식 요소)로 구성됩니다. |
| **변환**     | `@babel/plugin-transform-react-jsx` 플러그인에 의해 자바스크립트가 이해하는 형태 (예: `React.createElement(...)` 호출)로 변환됩니다.    |
| **자바스크립트** | 속성 값이나 자식 요소 내에서 **중괄호 (`{}`)** 를 사용하여 자바스크립트 표현식을 포함할 수 있습니다.                                             |

### 2. 가상 DOM과 리액트 파이버

#### 가상 DOM (Virtual DOM, VDOM)

* 탄생 배경: SPA 환경에서 빈번한 DOM 변경 작업의 성능 부담을 줄이기 위해 등장.
* 작동: 웹페이지가 표시해야 할 DOM을 메모리에 저장하고, 실제 변경이 필요한 시점에만 **react-dom**을 통해 브라우저의 실제 DOM에 반영함.
* 특징: 무조건 실제 DOM 관리보다 빠르다는 의미는 아니며, 대부분의 상황에서 충분히 빠르다는 것을 의미함.

#### 리액트 파이버 (React Fiber)

* 정의: 리액트에서 관리하는 평범한 자바스크립트 객체이자, 가상 DOM 비교 및 변경사항 수집을 담당하는 새로운 아키텍처.
* 목표: 애니메이션, 레이아웃, 사용자 인터랙션 등에 올바른 반응성을 제공하기 위해 작업 단위를 비동기적으로 분할하고 우선순위를 매김.
* 작업 단계:
  *
    1. 렌더 단계 (Render Phase): 사용자에게 노출되지 않는 비동기 작업. 변경사항을 수집하고 파이버 작업을 수행 (중단, 재사용, 폐기 가능).
  *
    2. 커밋 단계 (Commit Phase): DOM에 실제 변경사항을 반영하는 동기식 작업 (commitWork()) (중단 불가).
* 파이버 트리: current (현재 화면 상태)와 workInProgress (작업 중인 상태) 두 개의 트리가 존재하며, 작업 완료 후 포인터를 바꿔치기하는 더블 버퍼링 기법 사용.
* 파이버 vs 가상 DOM: 가상 DOM은 웹 환경 개념이지만, 파이버는 React Native 등 브라우저 환경이 아닌 곳에서도 사용 가능한 조정(Reconcilation) 엔진 아키텍처임.

### 3. 클래스 컴포넌트와 함수 컴포넌트

| 구분        | 클래스 컴포넌트                                                                   | 함수 컴포넌트                                                     |
| --------- | -------------------------------------------------------------------------- | ----------------------------------------------------------- |
| **선언**    | `React.Component` 또는 `React.PureComponent`를 `extends`하여 클래스로 선언.           | 단순 자바스크립트 함수로 선언.                                           |
| **this**  | `this` 키워드를 사용해 `props`, `state`, 메서드에 접근하며, `this` 바인딩이 필요함.              | `this` 없이 `props`와 `state`에 직접 접근 가능.                       |
| **상태/로직** | `this.state`를 객체로 관리하고 `setState()`로 업데이트.                                 | `useState`, `useEffect` 등 **Hook**을 사용해 상태와 로직 관리.          |
| **생명주기**  | 생명주기 메서드 (`render()`, `componentDidMount()`, `componentDidUpdate()` 등) 보유. | 생명주기 메서드가 없으며, `useEffect` 훅으로 유사 기능 구현 (동작 메커니즘은 다름).      |
| **특징**    | 구조가 복잡하고 데이터 흐름 추적 및 로직 재사용이 어려움.                                          | 코드가 간결하고 `this` 바인딩이 불필요하며, 렌더링 시 값이 고정되는 특성(불변 캡처된 값)을 가짐. |

* 클래스 컴포넌트의 한계: 데이터 흐름 추적 어려움, 로직 재사용 어려움, 컴포넌트 크기 증가, 상대적 복잡성, 핫 리로딩에 불리.

### 4. 렌더링

#### 정의 및 발생

* 렌더링: 컴포넌트들이 현재 props와 state를 기반으로 UI를 구성하고 브라우저에 제공할 DOM 결과를 계산하는 과정.
* 발생 시나리오:
  * 최초 렌더링 (앱 진입 시).
  * 리렌더링 (이후 모든 렌더링).
* 리렌더링 조건:
  * 클래스 컴포넌트의 setState 또는 forceUpdate 실행.
  * 함수 컴포넌트의 useState 또는 useReducer의 setter/dispatch 실행.
  * key props 변경 또는 부모 컴포넌트가 렌더링될 경우 (자식도 무조건 리렌더링).

#### 렌더링 프로세스

1. **시작**: 루트에서부터 아래로 내려가며 업데이트가 필요한 컴포넌트를 탐색.
2. **수집**: 컴포넌트 함수(또는 render() 메서드)를 호출해 렌더링 결과물을 수집.
3. **재조정 (Reconciliation)**: 수집된 결과물과 이전 가상 DOM을 비교하여 변경 사항 (type, props, key)을 체크.
4. **DOM 적용**: 모든 변경사항을 동기 시퀀스로 실제 DOM에 적용 (커밋 단계).

**비동기 렌더링 (동시성 렌더링)**:\
리액트 18부터 도입. 렌더 단계가 비동기로 작동하여 우선순위가 낮은 렌더링을 중단·재시작·포기함으로써\
매끄러운 사용자 경험을 제공한다.

### 5. 메모이제이션 (Memoization)

#### 정의

* 목적: 컴포넌트의 무거운 연산이나 리렌더링 비용을 줄이기 위해 이전의 계산 결과나 컴포넌트 자체를 기억해두는 기법.
* Hook: useMemo (값 메모이제이션), useCallback (함수 메모이제이션), React.memo (컴포넌트 메모이제이션).

#### 고려 사항

| 항목          | 내용                                                                                                                                                                                                                                                   |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **주장 1**    | 필요한 곳에만 메모이제이션 사용 (`memo`, `useMemo`, `useCallback` 등).                                                                                                                                                                                              |
| **주장 2**    | 렌더링 비용이 비싸니 일단 전부 메모이제이션 적용하자.                                                                                                                                                                                                                       |
| **논거**      | 메모이제이션 자체에도 값 비교, 캐시 저장/조회 비용이 발생한다. 이 비용이 리렌더링 비용보다 크면 오히려 성능 저하가 발생할 수 있다. 따라서 섣부른 최적화는 피해야 한다. 애플리케이션 규모가 커지면(컴포넌트 수·프롭스 복잡성 증가) 주장 1을 일관되게 지키기 어려워지고, 잘못된 `memo` 사용은 추가 비용을 초래한다. 반면 `memo`를 안 쓰면 복잡한 로직의 재실행과 자식 컴포넌트의 불필요한 리렌더링으로 비용이 커질 수 있다. |
| **결론 / 권장** | 신중하게 적용하되, 성능 개선 효과가 명확할 때만 메모이제이션을 사용하라. 다만 규모가 큰 실무 프로젝트에서는 트레이드오프로 “일단 `memo` 적용”하여 렌더링 비용을 먼저 막는 방식을 선호할 수 있다. (즉, 상황에 따라 판단 — 측정(`profiling`) 후 적용 권장)                                                                                          |

* useMemo와 useCallback의 필요성: 리렌더링 시 객체와 함수는 재생성되므로 참조가 달라짐. 이 달라진 참조가 useEffect 등의 의존성 배열에 사용되면 불필요한 부수 효과를 유발할 수 있어 메모이제이션이 필요할 수 있음.
