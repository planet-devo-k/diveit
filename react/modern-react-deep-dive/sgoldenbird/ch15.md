# Takeaways

## 리액트 프로젝트를 시작할 때 고려해야 할 사항

### 유지 보수 중인 서비스라면 리액트 버전을 최소 18.3.1 (16.8.6)으로 올려두자.

* 16.8 : 훅, 함수 컴포넌트 개념 정립

### IE11은 공식적으로 종료되었습니다

### 서버사이드 렌더링 애플리케이션을 우선적으로 고려한다.

* 기본 HTML에 온전히 자바스크립트로 렌더링과 라우팅을 수행하는 SPA는 대부분의 경우 성능 측정에서 좋은 결과를 얻기 어렵다.
  * **검색 엔진 최적화(SEO) 불리**
  * **기기 성능의 불균형**: 모바일 기기의 성능은 사용자별로 천차만별이기 때문에 자바스크립트 코드 실행 속도에 의존적일수록 평균적인 사용자 경험을 제공하기 어렵다.
* 관리자와 같이 제한적인 사용자에게 빠르게 웹페이지를 제공하는 경우, \
  이벤트 페이지 같이 콘텐츠와 인터랙션이 매우 제한적인 소규모 웹페이지의 경우, \
  서버를 준비할 상황이 여의치 않는 경우에만 SPA를 만들것을 추천

### 상태 관리 라이브러리는 꼭 필요할 때만 사용한다.

* 애플리케이션에서 관리해야할 상태가 많고, 여러 상태를 합성해서 또 새로운 상태를 파생하는 등 상태에 대한 여러 필요성이 많은 애플리케이션이라면 상태 관리 사용.
* 관리해야할 상태가 적은 애플리케이션에 상태 관리 라이브러리를 추가하는 것은 되려 부자연스러운 프로젝트 구조를 야기할 수 있으며 쓸데없이 번들링 크기만 키우는 꼴이 될수 있다.

### 리액트 의존성 라이브러리 설치를 조심한다.

* 리액트에 의존적인 라이브러리
  * 리액트라는 프레임워크(또는 라이브러리)가 없으면 단독으로 아무런 기능을 할 수 없는 라이브러리
  * 대부분 react-\*\* 같은 이름을 가지고 있다.
  * 버전 종속성: 리액트가 18에서 19로 업데이트될 때, react-something 라이브러리가 업데이트를 안 해주면 내 프로젝트 전체의 버전을 올릴 수 없게 됩니다. (발목을 잡히는 현상)

## 언젠가 사라질수도 있는 리액트

### 리액트를 반대하는 의견

* 클래스 컴포넌트에서 함수 컴포넌트로 넘어오면서 느껴지는 혼란
* <mark style="color:$primary;">왜 일반 변수가 아닌 useState로 만든 변수를 사용해 배열에 넣어야하는가?</mark> \ <mark style="color:$primary;">단순히 const fruits = \[]에 fruits.push()를 사용하면 안되는 이유는 무엇인가?</mark>
  * 리액트는 변수의 값이 변했다고 해서 화면을 다시 그리지 않습니다.
  * 일반 변수에 push를 하면 메모리 상의 값은 바뀌지만, 리액트는 그 변화를 감지하지 못해 화면에 이전 데이터만 보여줍니다.
  * useState의 세터 함수(setFruits)를 호출해야만 리액트에게 "데이터가 바뀌었으니 화면을 다시 그려(Re-render)!"라고 신호를 보낼 수 있습니다.
*   <mark style="color:$primary;">useEffect에 async를 바로 사용하지 않는 이유는 무엇인가?</mark> \ <mark style="color:$primary;">왜 즉시 실행 함수로 async를 감싸서 실행하는가?</mark>

    * 리액트의 설계 원칙상 useEffect는 **동기적(Synchronous)으로 실행되어야 합니다.**&#x20;
    * 리액트는 UI를 일관성 있게 유지하기 위해 "렌더링 -> 커밋 -> 이펙트 실행"이라는 엄격한 스케줄을 관리합니다. Effect 내부에서 수행하는 작업(API 호출 등)은 외부 세계에 영향을 주는 '부수 효과(Side Effect)'이지만, 그 효과를 일으키는 **useEffect 과정 자체는 리액트의 스케줄 내에서 예측 가능해야(순수해야) 합니다. async를 써버리면** 함수 내부의 로직이 마이크로태스크 큐로 넘어가 버려 **리액트의 통제를 벗어납니다.** 이는 상태 업데이트가 꼬이거나, 이미 사라진 컴포넌트의 상태를 변경하려는 시도(Memory Leak)로 이어질 수 있습니다.
      * effect가 async로 돼 있다면 다음 effect의 호출을 부자연스럽게 막는다.
        * 리액트는 컴포넌트가 화면에 그려진 직후(Commit 단계) Effect들을 순차적으로 실행합니다.
        * 정상적인 경우 (동기): 리액트가 Effect 1을 실행하고, 이게 끝나면 바로 Effect 2를 실행합니다. \
          이 과정이 매우 빨라서 브라우저의 다음 작업(이벤트 처리 등)을 방해하지 않습니다.
        * 부자연스러운 상황 (비동기): 만약 useEffect 자체가 async라면, 리액트 입장에선 이 함수가 언제 끝날지 모르는 상태가 됩니다. \
          리액트는 내부적으로 Effect들의 실행과 정리를 스케줄링하는데, 비동기 함수는 이 흐름을 제어권 밖으로 밀어내 버립니다.
    * **useEffect는 반환값으로 반드시 함수(Cleanup 함수)나 undefined를 반환해야 합니다.**
    * async 함수는 호출되는 즉시 Promise 객체를 반환합니다. 리액트는 useEffect가 반환한 이 Promise를 보고 "왜 Promise가 왔지?"라며 당황해서 에러를 발생시킵니다.
    * 내부에서 async 함수를 따로 정의하고 즉시 실행(IIFE)시키면, useEffect 자체는 아무것도 반환하지 않으면서(undefined) 내부의 비동기 로직만 안전하게 돌릴 수 있습니다.

    ```js
    useEffect(async () => {
      const data = await fetchData(); // 에러! useEffect는 Promise를 반환하면 안 됨
    }, []);
    ```

    ```js
    useEffect(() => {
      (async () => {
        const data = await fetchData();
        setData(data);
      })(); // 함수를 만들자마자 ()로 바로 실행
    }, []);
    ```

    ```js
    // 내부 변수 선언 방식
    useEffect(() => {
      const getItems = async () => {
        try {
          const data = await fetchData();
          setItems(data);
        } catch (error) {
          console.error(error);
        }
      };

      getItems();
    }, []);

    // 데이터 페칭 라이브러리 사용
    // 사실 실무에서는 useEffect 안에서 직접 fetch를 하는 것 자체가 관리하기 힘들기 때문에, TanStack Query (React Query) 같은 라이브러리를 많이 사용

    const { data, isLoading } = useQuery({
      queryKey: ["items"],
      queryFn: fetchData,
    });
    ```
* <mark style="color:$primary;">어차피 무한하게 push해야하는데 왜 clearInterval을 return문에서 호출하는가?</mark> \ <mark style="color:$primary;">clearInterval을 호출하지 않으면 어떤 일이 벌어지나?</mark>
  * 컴포넌트는 화면에서 사라질 때(Unmount) 자원을 정리해야 합니다.
  * 안 하면 벌어지는 일: 컴포넌트가 사라져도 타이머는 메모리 어딘가에서 영원히 돌아갑니다(Memory Leak). 만약 페이지를 여러 번 왔다 갔다 하면 타이머가 중첩되어 수십 개의 타이머가 동시에 실행되는 대참사가 벌어집니다.
* <mark style="color:blue;">왜 push대신 콜백함수 내부에서 이전 배열을 받아서 매번 새로 배열을 만드나?</mark> \ <mark style="color:blue;">근데 그게 왜 함수여야하는가? 이것은 비효율적이지 않은가?</mark>
  * 리액트는 이전 배열과 다음 배열의 '주소값'이 달라져야 데이터가 바뀌었다고 인식합니다. push는 원래 배열의 주소는 그대로 둔 채 내용물만 바꾸기 때문에 리액트가 "안 바뀌었네?"라고 착각할 수 있습니다.
  * <mark style="color:$primary;">왜 함수형 업데이트인가?</mark> prev => \[...prev, new] 처럼 함수를 쓰면, 가장 **최신의 상태값을 보장**받을 수 있습니다. 비동기 상황이나 여러 번 업데이트가 일어날 때 데이터가 꼬이는 것을 방지합니다.
  * 매번 새로 만드는 게 비효율적으로 보일 수 있지만, 현대 자바스크립트 엔진은 매우 빠르며 주소값만 비교하는 방식이 리액트 전체의 성능(렌더링 최적화) 측면에서 훨씬 유리합니다.
* <mark style="color:$primary;">useEffect는 무엇이고 두번째 빈 배열의 의미는 무엇인가.</mark>
  * 컴포넌트가 렌더링된후 특정 작업(API 호출, 타이머 등 외부효과)을 수행하게 해주는 훅입니다.
  * 빈배열: "이 효과는 컴포넌트가 처음 나타날 때(Mount) 딱 한 번만 실행해줘!"라는 뜻입니다.
  * 배열이 없으면: 렌더링될 때마다 실행됩니다.
* 너무 방대한 자유가 주는 혼란
  * 스타일, 상태관리 등 다양한 옵션

### 오픈소스 생태계의 명과 암

* 페이스북 라이선스 이슈
  * **MIT 라이선스**
    * 오픈 소스 라이선스 가운데 가장 널리 쓰인다.
    * 오픈 소스 소프트웨어를 상업적으로 이용하거나 배포하거나 개인적으로 이용하는 등에 대한 어떠한 제약 없이 소프트웨어를 취급할 수 있는 매우 자유로운 라이선스
  * 페이스북은 자사의 오픈 소스이니 React, Immutable, Jest 등에 BSD+Patents 라이선스 사용했었다.
    * 이 라이선스를 적용한 소프트웨어에 대해 특정한 사건이 발생한다면 라이선스가 통지 없이 종료될수 있다는 조항이 문제 → 개발자들이 오픈소스로 만든 자신의 소프트웨어에 대한 권리를 한순간에 잃어버릴수도 있다 → 페이스 북 해당 특허권 삭제하고 MIT 라이선스 사용
* 오픈소스는 무료로 계속 제공될 수 있는가? color.js, faker.js, 그리고 바벨

### 웹 개발자로서 가져야 할 유연한 자세

* WebAssembly(줄여서 Wasm)
  * 웹 브라우저에서 자바스크립트와 함께 실행될 수 있는 새로운 유형의 코드. 자바스크립트가 웹 세계의 '범용 언어(영어)'라면, 웹어셈블리는 특정 고성능 작업(그래픽 처리, 물리 엔진 등)을 위해 투입되는 고도로 훈련된 전문가
  * 느린 자바스크립트를 대신할 방안으로 떠오르고 있다. 웹 어셈블리는 자바스크립트를 대체하는 것이 아닌 자바스크립트와 함께 상호 보완적으로 실행되는 도구라고 보는 것이 적절하다. \
    성능이 필요한 작업은 웹어셈블리로, 그 밖의 일반적인 작업은 자바스크립트로.
  * 자바스크립트 보다 훨씬 빠른 언어로 작성돼 있다.
  * C, C++, 러스트 같은 시스템 프로그래밍 언어로 작성된 프로그램을 웹에서 사용할 수 있게 해준다.
* SWC, 터보팩 모두 러스트로 작성되어 자바스크립트로 실행되는 바벨과 웹팩을 속도 측면에서 개선
* ESLint보다 빠른 **러스트로 작성한 Biome**
  * Rome의 핵심 개발자들이 코드를 포크해서 만든 Biome
  * **Lint(코드 검사)와 Format(코드 정렬)을 하나의 도구로 해결**합니다.
* **웹에서 작동하는 코드를 작성하기 위한 인프라는 자바스크립트에서 러스트로 점차 넘어가고 있는 추세지만 결국 웹에서 실행되는 코드는 자바스크립트라는 점에서는 변함이 없다.**
* 모든 웹 개발은 HTML, CSS, JS 토대 위에 세워졌다.

## 기타

* Svelte: UI를 구축하기 위해 브라우저에서 작업하는 대신 앱을 빌드할 때 컴파일 단계에서 작업하는 새로운 개념을 도입한 프레임워크
  * 리액트: "데이터가 바뀌었네? 가상 DOM 전체를 다시 그려서 이전 거랑 비교해볼게. 아, 여기가 바뀌었구나! 그럼 여기만 고칠게." (이 과정이 브라우저의 에너지를 씀)
  * 스벨트: (빌드할 때 이미) "데이터 A가 바뀌면 무조건 p 태그의 텍스트를 수정해." 라는 코드를 생성. 브라우저에서는 비교 과정 없이 즉시 실행.
* 쿼크 모드(Quirks Mode): 브라우저가 아주 오래된 웹 페이지들을 정상적으로 보여주기 위해, 표준 규격을 따르지 않고 과거의 방식(비표준 방식)으로 렌더링하는 동작 모드
* **웹어셈블리(WebAssembly)**
  * 브라우저가 읽고 실행하기 위한 '저수준 바이트코드(Bytecode) 형식'. \
    기계가 빠르게 읽을 수 있도록 설계된 **이진수(Binary) 데이터**
  * 좁은 의미에서는 언어라고 부르기도 하지만, 실제로는 **파일 형식에 가깝습니다**. (.wasm 확장자)
  * 메모장에서 웹어셈블리를 직접 타이핑하는 경우는 거의 없습니다. 대신 C, C++, Rust, Go 같은 고성능 언어로 코드를 짠 뒤, 이를 웹어셈블리 형식으로 '변환(컴파일)'해서 사용합니다.
  * 사람이 읽을 수 있는 버전: **WAT (WebAssembly Text Format)**
    * 컴퓨터가 읽는 이진수(0101...)만 있으면 사람이 수정하기 너무 힘들겠죠? 그래서 웹어셈블리는 사람이 읽고 쓸 수 있는 텍스트 형식인 WAT( .wat)도 함께 제공합니다.
* 프로그래밍에서 말하는 어셈블리는 기계어와 사람이 쓰는 언어 사이의 다리 역할을 하는 저수준 언어를 뜻합니다.
  * 기계어 (Machine Code): 컴퓨터가 직접 이해하는 0과 1의 이진수 뭉치입니다. 사람은 읽기 거의 불가능합니다. `10110000 01100001`
  * **어셈블리어 (Assembly Language)**: 0101 같은 기계어를 사람이 알아볼 수 있는 짧은 단어(명령어, Mnemonic)로 1:1 대응시킨 언어입니다. `MOV AL, 61h`(데이터를 옮기라는 'Move'의 약자)
  *   주요 어셈블리어 **니모닉(Mnemonics)**

      <table><thead><tr><th width="142">니모닉 (Mnemonic)</th><th width="196.60003662109375">본래 단어 (Full Name)</th><th>역할 (Description)</th></tr></thead><tbody><tr><td><strong>MOV</strong></td><td>Move</td><td>데이터를 한 곳에서 다른 곳으로 이동</td></tr><tr><td><strong>ADD</strong></td><td>Add</td><td>두 값을 더함</td></tr><tr><td><strong>SUB</strong></td><td>Subtract</td><td>값을 뺌</td></tr><tr><td><strong>JMP</strong></td><td>Jump</td><td>특정 코드 위치로 건너뜀 (분기문)</td></tr></tbody></table>
