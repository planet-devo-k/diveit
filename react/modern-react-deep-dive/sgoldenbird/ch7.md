# Takeaways

## 크롬 개발자 도구

- **자바스크립트 이슈**는 리액트 개발자 도구에서 확인할 수 **없다**.
- 자바스크립트 메모리, 네트워크, 소스, 실제 HTML, CSS 등 일반적인 웹 애플리케이션 환경 디버깅
- 각종 브라우저 확장 프로그램은 웹페이지 방문 시 확장 프로그램을 실행하기 위해 전역 변수나 HTML요소에 실제 웹 애플리케이션이 제공하지 않는 다른 정보를 추가할 수 있다. 이러한 정보는 디버깅에 방해될 수 있으므로 시크릿 모드에서 개발자도구 실행. (시크릿모드에서는 확장이 실행되지 않는다.)
- 개발자도구에서 수정하면 Hot Reload조차 기다릴 필요 없이 바로 확인할 수 있으므로 빠른 작업이 가능하다.
  - **핫 리로딩(Hot Reloading)**: 코드를 수정하면 페이지 전체를 새로고침하지 않고, **수정된 부분만 즉시 교체(Hot Swap)해서 UI를 바로 업데이트**하는 기술
  - 개발자 도구 Elements에서 DOM, CSS를 직접 수정하면 빌드 과정 없이 즉석에서 변화 확인 가능하다.
  - **개발 모드 = WebSocket + Hot Reloading 구**조
    - 개발자 모드에서 실행하면 **브라우저와 개발 서버 사이에 WebSocket 연결이 자동으로 열리고**, \
      파일이 수정될 때마다 서버가 WebSocket을 통해 브라우저에 변경 신호를 보냄

### 요소 탭

- 배너와 같이 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면 요소의 중단점을 사용해 디버깅할 수 있다.
  - 디버깅하고 싶은 요소 선택, 마우스 오른쪽 버튼, 중단 위치 선택, 중단을 원하는 옵션 선택
  - 중단 위치를 이렇게 설정해두면 \
    중단과 관련된 작업이 일어날 때마다 브라우저가 렌더링을 중단하고 \
    해당요소 변경을 일으킨 소스코드를 보여준다. \
    (예를 들어, 속성 수정에 체크하고 해당 노드의 class명을 수정하려는 작업을 보여준다.)
- 특정 요소만 캡처하거나 숨기는 기능

#### 요소 정보

- 이벤트 리스너
  - 현재 요소에 부착된 각종 이벤트 리스너를 확인
  - 상위버튼을 체크해제하면 딱 해당 요소에 명확하게 부착된 이벤트만 볼 수 있다.
  - 그러나 이벤트 버블링 등으로 이벤트를 발생시키는 경우에는 확인할 수 없다.
- DOM 중단점
  - 앞서 설명한 중단점이 있는지 알려주는 탭
- 속성
  - 해당 요소가 가지고 있는 모든 속성값
  - 자바스크립트에서 해당 DOM으로 .attributes를 실행하면 직접 할당된 값만 나오지만, 속성 탭에는 모든 값이 나온다.
- 접근성
  - 웹 이용에 어려움을 겪는 장애인, 노약자를 위한 스크린리더기 등이 활용하는 값

### 소스 탭

- 웹 애플리케이션을 불러오기 위해 실행하거나 참조된 모든 파일을 확인할 수 있다. 자바스크립트 파일, CSS, HTML, 폰트 등
- 디버깅하고 싶은 파일을 직접 열어야 한다.
- 프로덕션 모드의 경우 파일이 모두 압축돼 있기 때문에 디버깅하기가 매우 불편하지만 개발모드에서는 유용하게 사용.
- 소스 중단점을 생성해 자바스크립트 실행을 중단시키고 디버깅을 수행할 수 있다.
  - 중단시키고 싶은 코드 줄의 줄 번호(line number)를 클릭하고 새로고침
  - 이는 코드에 debugger를 선언하는 것과 동일한 역할을 하지만 소스코드를 오염시키지 않으므로 더 유용하다.
  - 중단점으로 다음 코드 시작을 중지하고, 이전에 할당한 변수에는 어떤 값이 들어있는지 육안으로 확인할 수 있다.
  - 사용중인 라이브러리에서 버그가 의심되는 지점을 디버깅하거나 실제로 소스코드상에서 어떤 식으로 작동하는지 확인하고 싶을때 매우 유용
- 자바스크립트 파일에서는 확인할 수 없는 스코프, 호출 스택 등 현재 자바스크립트가 실행되고 있는 구조도 확인 가능

**감시**

- 감시하고 싶은 변수를 선언하고, 현재 값이 무엇인지 실시간으로 해당 변수의 정보를 확인
- 왼쪽에서 제공하는 변수외에 디버깅 시점에서 특정 변수의 값을 알고 싶다면 이 감시를 활용
- 감시로 확인할 수 없는 값은 not available로 표시
- 감시에 변수를 추가해 실제 변수값을 확인하는 기능을 사용한다면 굳이 번거롭게 변수마다 console.log로 디버깅 하지 않아도 훨씬 빠르게 필요한 정보를 확인 가능

**중단점**

- 현재 열려있는 파일 뿐 아니라 웹페이지 전체에 걸쳐 소스탭에서 추가한 모든 중단점 확인

**범위**

- 현재 중단점에서의 스코프
- 이 스코프에서 접근할 수 있는 값을 확인할 수 있다.
- 클로저, 전역 스코프, 등 확인 가능

**호출스택**

- 현재 중단점의 콜스택을 확인할 수 있다.

**전역 리스너**

- 현재 전역 스코프에 추가된 리스너 목록

**XHR/가져오기, DOM, 이벤트 리스너, CSP 위반 중단점**

- 소스의 중단점 이외에 다양한 중단점을 확인할 수 있다.
- XHR = XMLHttpRequest 한마디로 “API 요청 중단점”
  - 요청 URL 또는 조건을 넣어두면 그 URL로 요청이 발생하는 순간 자동 멈춤
  - XHR Breakpoint에 /community 라고 넣어두면 이 API를 부르는 순간 디버거가 멈추고 headers, params, data를 즉시 확인할 수 있음
  - XHR이 아닌 Network 탭에서 보는 게 더 정확함
- CSP 위반 중단점 — CSP Violation Breakpoints
  - CSP = **Content Security Policy&#x20;**<mark style="background-color:yellow;">**브라우저가 제공하는 보안 정책**</mark>
  - 사이트에 악성 스크립트가 삽입되거나, 허용되지 않은 리소스를 로드하려고 하면 CSP가 막고 오류를 발생시킴
  - CSP Breakpoint는 CSP 위반 오류가 발생하는 순간 실행을 멈추는 기능 → 어디에서 forbidden script를 실행하려고 하는지, 어떤 라인이 문제인지 즉시 중단돼서 추적 가능

### 네트워크 탭

- HTTP요청, 웹 소켓 등 웹페이지가 외부 데이터와 통신하는 정보
- 하단에는 페이지를 불러오는 기간 동안 발생한 총 요청 건수와 총 다운로드한 업로드 리소스의 크기를 확인 가능
  - 모바일의 경우, 총 리소스 크기만큼 사용자가 모바일 네트워크 비용을 지불해야 한다.
  - 비용뿐 아니라 속도에도 영향을 미치는 문제이므로 **가급적 네트워크 리소스 요청 횟수와 크기를 줄일 필요**가 있다.
  - gzip이나 brotli 를 적절히 활용해 리소스를 압축하거나 이미지를 최적화.
- 스크린샷 캡처 기능을 활용하면 네트워크 요청 흐름에 따라 웹페이지가 어떻게 로딩되는지 확인 가능.
- 외부 CDN에서 가져오는 이미지 리소스 요청 등도 확인할 수 있다.
- 노출되는 영역이 큰 중요한 콘텐츠가 우선적으로 다운로드 되는지 등을 확인할 수 있다.

#### 네트워크 탭을 통해 집중적으로 확인해봐야 하는 점

- 불필요한 요청 또는 중복된 요청이 없는지
- 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
- 리소스를 불러오는 속도는 적절한지. 또는 너무 속도가 오래걸리는 리소스는 없는지
- 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지.
- 참고로, **리액트에서 동일한 주소의 요청이 두 번 실행되는 경우는 대부분 잘못된 useEffect의 사용**으로 발생하는 문제

### 메모리 탭

- 메모리 누수, 속도 저하, 웹페이지 프리징 현상을 확인
- 리액트 개발 도구의 프로파일과 비슷하게 프로파일링 작업을 거쳐야 원하는 정보를 볼 수 있다. 다른 탭과는 다르게 메모리 탭 그 자체만으로는 아무것도 할 수 없다.

#### 메모리 탭 프로파일 유형

- 힙 스냅샷
  - 현재 메모리 상황을 사진 찍듯이 촬영
- 타임라인의 할당 계측
  - 시간의 흐름에 따라 메모리의 변화를 확인
  - 주로 로딩될때 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용
- 할당 샘플링
  - 메모리 공간을 차지하고 있는 자바스크립트 함수를 볼 수 있다.

#### 자바스크립트 인스턴스 VM 선택

- 현재 실행 중인 자바스크립트 VM 인스턴스를 확인할 수 있다.
- 메모리에서 자바스크립트 가상머신 인스턴스를 선택할 수 있다. 메모리 현황을 알고싶은 인스턴스를 선택하고 시작하면 된다.
- 인스턴스별 힙 크기를 볼 수 있는데, 실제 해당 페이지가 자바스크립트 힙을 얼마나 점유하고 있는지 나타낸다. 이 크기는 자바스크립트 실행에 따라 실시간으로 바뀐다. 이 크기만큼 사용자의 브라우저에 부담을 주기 때문에 불필요하게 크기가 늘어나지 않는지 눈여겨 볼 필요가 있다.
- 인스턴스
  - `설계도 → 실물` 관계로 이해할 때, 실제로 만들어진 개체(실물)
  - **브라우저가 자바스크립트를 실행**하려면 **실행 엔진을 한 개 만들어서 메모리, 스택, 힙을 구성**해야 한다.
  - 이렇게 만들어진 실행 엔진 1개가 바로 “JavaScript VM Instance (**자바스크립트 실행 엔진의 실물 1개**)”
    - 설계도: **V8 엔진(크롬의 JS 엔진 구조)**
    - 실물: 현재 페이지를 실행하기 위해 실제로 띄운 엔진 → **인스턴스**
  - 참고
    - 클라우드(AWS, GCP)에서 말하는 인스턴스는 가상 컴퓨터 한 대(실제로 돌아가는 서버 한 대)
    - Docker에서의 인스턴스 = 이미지(설계도)에서 만들어진 컨테이너 한 개
      - Docker 이미지 = 빌드된 청사진
      - Dockerfile = 설계도
      - **Docker 컨테이너** = 그 **이미지가 실행된 실체(인스턴스)**
- **자바스크립트 VM 인스턴스 = 자바스크립트 엔진이 만든 실행 환경(힙 + 스택)**
  - 브라우저는 웹사이트를 실행할 때 자바스크립트 엔진(V8) 을 여러 개 사용할 수 있다.
  - 이 엔진 하나를 실행할 때 만들어지는 힙(Heap)과 스택(Stack) 을 묶어서 VM 인스턴스 (Virtual Machine Instance) 라고 부른다.
  - React 앱을 하나 실행하면 보통 하나의 VM 인스턴스가 생성됨. 하지만 경우에 따라 여러 VM 인스턴스가 생길 수도 있음
    - iframe 안에 또 JS가 있을 때
    - 웹 워커(Web Worker)를 실행할 때
    - 개발자도구 자체가 별도 VM을 사용할 때
    - 확장 프로그램이 JS를 실행할 때

    이런 것들이 각각 독립된 메모리와 스택을 가진 엔진 인스턴스(VM instance) 를 만듦 ![netflix 인스턴스들](./assets/netflix_instances.png)

#### 힙 스냅샷

- 현재 페이지의 메모리 상태 확인(스냅샷을 촬영하는 시점을 기준으로)
- **메모리 누수 의심**이 되는 지점을 먼저 추측해본 뒤 스냅샷을 두개 이상 촬영한 다음 차이 비교 (거의 아무것도 없는 빈 애플리케이션도 리액트와 브라우저가 웹페이지 실행을 위해 많은것을 준비해두었기 때문)
- 먼저 페이지에 진입하고 페이지 로딩이 완료되면 힙 스냅샷 촬영을 한번 수행
- 메모리 크기 차이의 원인을 파악하기 위해, 메뉴를 클릭하고 `스냅샷1에서 스냅샷2 사이에 할당된 객체`를 클릭해 `얕은 크기(shallow size)` 항목을 기준으로 내림차순 정렬 → 어떤 변수가 메모리를 크게 잡아먹고 있는지 확인
- (p449, 450참고)
  - 어떤 인터랙션으로 인해 메모리 사용량 차이가 발생했는지 확인 가능
  - 메모리를 크게 차지하고 있는것이 객체(여기서는 배열)인지 등 확인 가능
  - 이 액션이 어떤 함수를 통해 빚어졌는지 확인 가능
  - 해당 배열이 어떤 값을 가지고 있는지도 확인 가능(전역변수로 저장하고 콘솔로 확인 가능)
- **스냅샷을 활용해 useMemo나 useCallback같은 의존성 있는 값들이 정말로 렌더링 사이에 재생성되지 않고 그대로 유지되는지 확인할 수 있다.**
- **힙**: 자바스크립트 엔진이 **동적**으로 메모리를 저장하는 넓은 창고
  - JS가 생성하는 객체들이 아무 자리나 저장되는 거대한 자유 공간
  - 크기가 정해지지 않은 데이터(객체, 배열 등)가 저장되는 곳

**컴퓨터 메모리는 크게 2구역**

1. **스택(Stack)** → 작고 빠르고, 저장 위치가 정해져 있음 → 함수 실행 컨텍스트, 지역변수, number 같은 primitive 값들이 들어감(크기가 고정된 primitive)

```js
const a = 10;
// 값 10은 스택(Stack) 에 들어감
```

2. **힙(Heap)** → 크고 자유로움(메모리를 아무 곳에 할당 가능) → 객체, 배열, 함수 같은 크기가 가변적인 데이터가 들어감(객체는 크기가 일정하지 않음) → React 컴포넌트 인스턴스 DOM 노드도 여기

```js
const obj = { name: "diveit" };
// { name: "diveit" }는 힙(Heap) 에 저장
// obj 변수는 스택에 저장 + 힙 주소를 가르킴 (참조)
// Stack: obj ----> 0x1A32F (Heap address)
// Heap:  { name: "diveit" }
```

**얖은 크기(Shallow Size) vs 유지된 크기(Retained Size)**

- shallow size: 객체 자체가 보유하는 메모리 바이트 크기
- retained size: 해당 객체 자체 + 다른 부모가 존재하지 않는 모든 자식 객체들의 크기까지 더한 값(참고 p451)
- <mark style="background-color:yellow;">**메모리 누수를 찾을때는 얕은 크기(객체 자체의 크기)는 작으나 유지된 크기(객체가 참조하고 있는 모든 객체들의 크기)가 큰 객체를 찾아야한다.**</mark>
  - 두 크기의 차이가 큰 객체는 다수의 다른 객체를 참조하고 있다는 뜻이며, 이는 **해당 객체가 복잡한 참조 관계를 가지고 있다는 뜻**.
  - 이런 객체가 오랜 시간 메모리에 남아있다면 그로 인해 많은 메모리를 점유하고 있을 수 있다.

#### 타입라인의 할당 계측

- 시간의 흐름에 따라 메모리 변화를 확인할수 있는 기능(스냅샷은 해당 시점의 메모리 내용만 촬영)
- 메모리 변화를 일으킨 변수가 무엇인지, 그리고 해당 변수가 어느정도 크기를 차지하는지 등 확인할 수 있다.
- 페이지 로딩이 끝나면 타임라인의 할당 계측을 선택하고 시작을 누른다.
- 상단 그래프에서 검색을 원하는 범위를 좁히면 해당 기간에 메모리에 할당된 내용만 골라서 볼 수 있다.
- 마찬가지로 특정 변수를 클릭해 전역변수로 저장하면 해당 변수가 무슨 값을 가지고 있는 객체인지 확인할 수 있다.

#### 할당 샘플링

- 시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에서 타임라인 할당 계측과 비슷하지만
- 자바스크립트 실행 스택별로 분석할 수 있고, 이 분석을 함수 단위로 한다는 차이가 있다.
- 프로파일링할때 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅을 수행해야할 때 유리하다.
- 만약, 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인하기 어려워 힙 스냅샷을 촬영해 비교하기 어려운 경우에도 활용하면 좋다.
- 페이지가 로딩된 후, 할당 샘플링을 하고 싶은 VM을 선택하고 시작을 누르고 이런저런 활동 후 스탑
  - 예를 들어 최초에는 6.5MB 정도만 차지하던 힙이, 버튼을 클릭한 후에는 395MB까지 치솟는 상황. 버튼을 클릭하는 사이에 엄청나게 많은 메모리 할당 작업이 이뤄진것.
- 할당 프로파일링이 끝나고 무거운 순으로 정렬하면 가장 무거운 변수와 이 변수가 무엇때문에 할당됐는지 구체적으로 알 수 있다. 가장 많은 바이트를 차지한 함수의 작업이 맨 위로 올라온다.
- 오른쪽의 파일명 또는 마우스 오른쪽 버튼 `소스 패널에 표시`를 선택해 해당 함수가 어느 파일에서 어떻게 정의됐는지 확인 가능

### Next.js 환경 디버깅하기

- 클라이언트 자바스크립트 환경의 경우, 사용자 기기의 성능과 스펙에 따라 같은 메모리 누수라도 다른 결과를 낳게 된다.
- SSR을 수행하는 자바스크립트 환경에서 메모리 누수가 발생하면 서버 자체에 부담이 되고, 서버 부담은 곧 모든 사용자가 서비스를 사용할 수 없는 심각한 상황을 초래할 수 있다.
- 서버 환경도 동일하게 크롬 개발자 도구로 디버깅이 가능하다.

#### Next.js 프로젝트를 디버그 모드로 실행하기

- 가장 먼저 할일은 Next.js프로젝트를 디버그 모드로 실행하는 것.
- 디버그 모드로 실행하려면 다음과 같은 방법으로 **NODE_OPTIONS='--inspect'**&#xB77C;는 인수와 함께 next dev를 실행한다.

```js
"dev": NODE_OPTIONS='--inspect' next dev
```

- 주소창에 `chrome://inspect`로 이동한다. 여기서 open dedicated devtools for node를 클릭하면 개발자 도구 나타난다. Node로 실행한 next를 이곳에서 확인할 수 있다.

#### <mark style="background-color:yellow;">Next.js 서버에 트래픽 유입시키기</mark>

- SSR같이 서버에서 제공하는 서비스의 경우, 서버를 실행한 뒤 사용자가 서서히 유입되면서 메모리 누수가 발생하는 경우가 많다.
- 따라서 서버에 직접 트래픽을 발생시켜 확인하는 편이 제일 확실하다. \
  (**사용자의 트래픽이 서버로 몰리는 상황 시뮬레이션**)
- 새로고침이나 다른 컴퓨터를 이용해 접속하는 것보다 더 편리한 방법은 **오픈소스 도구인 ab**를 사용하는 것.
  - ab: 아파치 재단에서 제공하는 웹서버 성능 검사 도구. HTTP서버의 성능을 벤치마킹할 수 있는 도구
  - 터미널에서 아래와 같이 실행

  ```js
  ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
  // 이 명령어는 http://127.0.0.1:3000/을 향해 한번에 50개의 요청을 총 10000회 시도
  // 로컬에서 테스트할 경우 주소를 localhost로 하면 정상적으로 실행되지 않으니 IP나 올바른 주소 기재
  ```

  - ab을 사용하면 요청을 수행하는 것 뿐 아니라, 요청으로부터 응답받는데 걸리는 시간, 바이트 크기 등 다양한 정보를 확인할 수 있다.

#### Next.js의 메모리 누수 지점 확인하기

- getServerSideProps는 페이지 접근 요청이 있을때마다 실행되는 함수이므로 최대한 부수효과 없이 순수함수로 만들어야 한다. 만약 이 함수 내부에서 외부 스코프의 변수에 의존하는 작업을 하면 메모리 누수 상황을 마주할 수 있다.

### 기타

- DOM을 그리기 위해 리액트가 1:1구조로 생성하는 FiberNode
