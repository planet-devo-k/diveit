### 서버 컴포넌트, 클라이언트 컴포넌트

클라이언트 컴포넌트의 문제

- JS 번들 비대화
- 보안 취약
- 연쇄(waterfall) 요청

#### 어떤 컴포넌트를 서버로, 어떤 것을 클라이언트로 만들어야 할까요?

- 클라이언트 컴포넌트 ("use client"): useState, useEffect 같은 훅을 사용하거나, 버튼 클릭·입력 같은 이벤트 리스너가 필요한 경우, 브라우저 API(window, localStorage)를 쓰는 경우에 사용합니다.

- 서버 컴포넌트 (기본값): 데이터를 불러오는 로직, 정적인 UI, 보안이 중요한 로직, 큰 라이브러리를 사용하는 로직 등에 우선적으로 사용합니다.

#### RSC와 SSR은 모두 서버에서 실행되는데, 둘의 결정적인 차이점은 무엇인가요?

가장 큰 차이는 '클라이언트 자바스크립트 번들 포함 여부'와 '컴포넌트의 상태 유지'입니다.

- SSR: 서버에서 HTML을 생성한 후, 브라우저에서 동일한 컴포넌트를 다시 실행(Hydration)해야 합니다. 따라서 컴포넌트 코드가 JS 번들에 포함됩니다.
- RSC: 서버에서만 실행되고 결과물만 전송됩니다. 해당 컴포넌트의 로직이나 라이브러리는 JS 번들에 포함되지 않습니다.
  또한, RSC는 하이드레이션 과정이 없으므로 클라이언트의 상태(State)를 파괴하지 않고도 서버 데이터를 리프레시할 수 있습니다.

- RSC만 쓰면: 번들 크기는 줄지만, 브라우저가 데이터를 받아서 화면을 그릴 때까지 '흰 화면'을 봐야 할 수 있습니다.
- SSR만 쓰면: 화면은 빨리 보이지만, 하이드레이션을 위해 결국 모든 자바스크립트 코드를 브라우저가 다운로드해야 해서 무겁습니다.

#### RSC 사용 시 데이터 로딩으로 인한 '흰 화면' 문제를 어떻게 해결할 수 있나요?

Suspense와 Streaming을 활용.
무거운 데이터를 불러오는 RSC를 Suspense로 감싸면, 서버는 일단 로딩 상태가 담긴 HTML(Skeleton UI 등)을 먼저 보내줍니다. 이후 서버에서 데이터 처리가 완료되는 대로 실제 컨텐츠를 '스트리밍' 형태로 브라우저에 전달하여 끼워 넣습니다. 이를 통해 사용자는 빈 화면 대신 즉각적인 피드백을 받을 수 있습니다.

#### RSC와 SSR이 발전했는데도 여전히 CSR(Client Side Rendering)이 필요한 이유는 무엇인가요?

고도로 인터랙티브한 경험 때문입니다.
차트의 실시간 움직임, 폼 입력의 즉각적인 벨리데이션, 드래그 앤 드롭 등은 브라우저의 이벤트 리스너와 상태 관리가 필수적입니다. 또한, 한 번 로드된 후에는 서버 호출 없이 빠른 화면 전환이 필요한 대시보드 형태의 서비스에는 여전히 CSR 방식이 유리합니다.

#### 프로젝트를 시작할 때 CSR, SSR, RSC 세 가지 기술을 어떻게 조합하시겠습니까?

서버 중심의 하이브리드 전략

- 기본은 RSC
- 인터랙션은 Client Component
- 초기 진입 성능은 SSR

#### 서버 액션의 장점?

- API 통로(Endpoint)를 관리할 필요가 없습니다.
- 타입 안정성 (Type Safety)
- 서버 컴포넌트와의 시너지

#### 기존의 useEffect나 이벤트 핸들러에서 fetch/Axios로 데이터를 수정하던 방식과 '서버 액션'을 통한 Mutation의 가장 큰 차이는 무엇인가요?

- 기존 방식: 클라이언트에서 API 엔드포인트를 호출하고, 응답이 오면 useState나 React Query의 캐시를 수동으로 업데이트해야 했습니다.
- 서버 액션: 별도의 API 호출 코드 없이 함수 실행만으로 데이터 수정을 처리합니다. 특히 수정 직후 서버에서 직접 캐시를 무효화(revalidatePath)할 수 있어, 클라이언트가 서버의 최신 데이터를 다시 가져오도록 강제하는 과정이 매우 단순하고 선언적입니다.
