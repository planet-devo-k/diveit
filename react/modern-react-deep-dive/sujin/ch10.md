# 1. 리액트 17버전 살펴보기

16버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경사항을 최소화했음.

## 1. 리액트의 점진적인 업그레이드

유의적 버전을 기반으로 업데이트를 거치고 있었으나 리액트 17부터는 점진적인 업그레이드가 가능해짐.

리액트 16과 17이 혼재되어 있는 경우 리액트 17 애플리케이션은 내부에서 리액트 16을 게으르게 불러온다. 불러오는 과정에서 리액트 16을 위한 별도의 루트요소를 만들고, 여기에 불러온 리액트 16모듈을 렌더링하는 구조로 구성되어 있다. 이렇게 불러온 결과, 서로 렌더링 하는 과정에서 버전의 불일치로 인한 에러도 발생하지 않고 하나의 웹사이트에서 두개의 리액트가 존재할 수 있다. 리액트 팀에서는 어디까지나 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 리액트 버전을 한꺼번에 업데이트 하는게 복잡성 감소 측면에서 좋음

## 2. 이벤트 위임 방식의 변경

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM요소에 부탁하는 것이 아닌 이벤트 타입당 하나의 핸들러를 루트에 부착(이벤트 위임을 이용함). 하지만 리액트 17부터는 이러한 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트요소로 바뀜. 이유는 점진적인 업그레이드 지원과 다른 바닐라 자바스크립트나 jQuery 등이 혼재되어 있는 경우 혼란을 방지하기 위해서임.

## 3. 새로운 JSX transform

2장에서 언급한 것처럼 JSX는 일반 자바스크립트로 변환하는 과정이 필수적. 16버전까지는 이러한 JSX변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 `import React from 'react'` 구문이 필요했음. 그러나 리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐음.

장점

- 번들링 크기를 약간 줄일 수 있음
- 컴포넌트 작성을 더욱 간결하게 함

## 4. 그밖의 주요 변경 사항

### 이벤트 풀링 제거

리액트에는 이벤트를 처리하기 위한 SyntheticEvent 라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한번 더 감싼 이벤트 객체. 여기서 이벤트 풀링이란 SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미.

- 이벤트 풀링 시스템에서의 이벤트 발생과정
  1. 이벤트 핸들러가 이벤트를 발생시킨다
  2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다
  3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다
  4. 유저가 저장한 이벤트 리스너가 실행됨
  5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다

언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어서 효과적으로 보이지만 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는 방식은 분명 사용하는 쪽에서는 직관적이지 않았음.

```jsx
export default function App() {
	const [value, setValue] = useState('')
	function handleChange(e: ChangeEvent<HTMLInputElement>) {
		setValue(() => {
			return e.target.value
			})
		}

	return <input onChange={handleChange} value={value}/>

}
```

위 코드는 아래와 같은 에러를 발생시킴

```jsx
// Cannnot read properties of null (reading 'value')

//Warning: This synthetic event is reused for performance reasons.
//If you're seeing this. you're accessing the property 'target' on a released/nullified synthetic event,This is set to null. If you must keep the original synthetic event around, use event.persist(). See https://fb.me/re-act-event-pooling for more information.
```

이러한 에러가 발생하는 이유는 리액트 16 이하 버전에서는 이벤트 풀링 방식을 통해 서로 다른 이벤트 간에 이벤트 객체를 재사용하고, 이 재사용하는 사이에 모든 이벤트 필드를 null로 변경하기 때문. 따라서 비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게됨. 비동기 코드 내부에서 이 합성이벤트 e에 접근하기 위해서는 추가적인 작업인 e.persist() 같은 처리가 필요함.

비동기 코드로 이벤트 핸들러에 접근하기 위해서는 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 그리고 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안된다는 점 때문에 이러한 이벤트 풀링 개념이 삭제됨

### useEffect 클린업 함수의 비동기 실행

16까지는 동기적으로 처리됐음. 리액트 17붜는 화면이 완전히 업데이트 된 이후에 클린업 함수가 비동기적으로 실행됨. ⇒ 컴포넌트의 커밋 단계가 완료될 까지 지연됨. 이로써 약간의 성능적인 이점을 볼 수 있게 됨.

### 컴포넌트 undefined 반환에 대한 일관적인 처리

리액트 16과 17은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다. 이는 의도치 않게 잘못된 반환으로 인한 실수를 방지하기 위해서였음. 그러나 16에서 forwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 있었으나 17부터는 에러가 정상적으로 발생. 리액트 18부터는 undefined를 반환해도 에러가 발생하지 않음.

# 2. 리액트 18버전 살펴보기

## 1. 새로 추가된 훅 살펴보기

### useId

컴포넌트별로 유니크한 값을 생성하는 새로운 훅

### useTransition

UI변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅. 이를 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 사용자 경험을 제공할 수 있음

### useDeferredValue

리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅. 일반적으로 특정시간 동안 발생하는 이벤트를 하나로 인식해 한번만 실행하게 해주는 디바운스와 비슷하지만 디바운스 대비 useDeferredValue만이 가진 장점이 몇가지 있음

1. 디바운스는 고정된 지연 시간을 필요로 하지만, useDeferredValue는 고정된 지연시간 없이 첫번째 렌더링이 완료된 이후에 이 useDeferredValue로 지연된 렌더링을 수행
2. 이 지연된 렌더링은 중단할 수도 있고, 사용자의 인터렉션을 차단하지도 않음.

useTransition과의 차이점과 용도

useTransition은 state값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state값 자체만을 감싸서 사용. 지연된 렌더링을 한다는 역할은 같다. 만약 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근할 수 있다면 useTransition을 사용하는 것이 좋다.

### useSyncExternalStore

일반적인 애플리케이션 코드 작성시 사용할 일이 별로 없는 훅. useSubscription의 구현이 18에 이르러서 useSyncExternalStore로 대체된것.

- 테어링(tearing) : 하나의 state값이 있음에도 서로 다른 값(보통 state나 props의 이전과 이후)을 기준으로 렌더링 되는 현상을 말함.

리액트18에서 렌더링을 일시중지하거나 뒤로 미루는 등의 최적화가 가능해지면서 동시성 이슈가 발생할 수 있음.

![](https://velog.velcdn.com/images/sxin2949/post/7cf7bd38-2572-4e1e-af99-d724cad907b1/image.png)

1. 첫번째 컴포넌트에서는 외부 데어트 스토어의 값이 파란색이었으므로 파란색을 렌더링
2. 그리고 나머지 컴포넌트들도 파란색으로 렌더링을 준비
3. 그러다 갑자기 외부 데이터 스토어의 값이 빨간색으로 변경
4. 나머지 컴포넌트들은 렌더링 도중에 바뀐 색을 확인해 빨간색으로 렌더링했다.
5. 결과적으로 같은 데이터 소스를 바라보고 있음에도 컴포넌트의 색상이 달라지는 테어링 현상 발생

리액트가 관리할 수 없는 외부 데이터 소스에서라면 문제가 생김. 여기서 외부 데이터 소스란 리액트의 클로저 범위 밖에 있는 값들을 말함(document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등). ⇒ useState, useReducer가 아닌 모든 값들.

이러한 테어링문제를 해결하기 위한 훅이 useSyncExternalStore임.

```jsx
import { useSyncExternalStore } from "react";

// useSyncExternalStore(
// subscribe: (callback) => Unsubscribe
// getSnapshot: () => State
// ) => State
```

- 첫번째 인수: 콜백함수를 받아 스토어에 등록하는 용도로 사용
- 두번째 인수: 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수.
- 마지막 인수: 옵셔널 값. 서버사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용.

useSyncExternalStore의 인수를 읽다보면 기존에 우리가 알고있던 외부 값을 렌더링하기 위한 작동방식이 모두 담겨있는 것을 확인할 수 있음. 마지막으로 눈여겨봐야할 것은 리렌더링을 발생시키기 위해 useState나 useReducer를 어색하게 호출하는 동작 또한 없다는 것. 이를 통해 useSyncExternalStore 어딘가에 콜백을 등록하고, 이 콜백이 호출될 때마다 렌더링을 트리거하는 장치가 마련돼 있다는 것을 알 수 있음.

```jsx
import { useSyncExternalStore } from 'react'

function subscribe(callback: (this: Window, ev: UIEvent) => void) => {
	window.addEventListner('resize', callback)
	return () => {
		window.removeEventListner('resize', callback)
	}
}

export default function App() {
	const windowSize = useSyncExternalStore(
		subscribe,
		() => winodw.innerWidth,
		() => 0, // SSR시 제공되는 기본값
	)

	return <>{windowSize}</>
}
```

useSyncExternalStore 없이도 이와 비슷한 훅을 구현할 수 있다. 하지만 이 훅을 사용하면 컴포넌트 렌더링 이후에 정확하게 바로 현재 width를 가져온 반면, 사용하지 않은 쪽은 아예 값을 가져오지 못하고 초깃값만 나타나는 것을 확인할 수 있다.

useSynceExternalStore는 애플리케이션 코드에 직접적으로 사용할 일은 많지 않지만 사용 중인 관리 라이브러리가 외부에서 상태를 관리하고 있다면 이 useSyncExternalStore를 통해 외부 데이터 소스의 변경을 추적하고 있는지 반드시 확인해야 함

### useInsertionEffect

CSS-in-JS 라이브러리를 위한 훅.

Next.js에 styled-components를 사용할 경우 styled-components가 사용한느 스타일을 모두 모아 SSR이전에 <style>태그에 삽입했어야 함. CSS 추가 및 수정은 브러우저에서 렌더링 하는 작업 대부분을 다시 계산해 작업해야 하는데, 이는 리액트 관점에서 매우 무거운 작업. 따라서 리액트 17에서는 CSR시에 이러한 작업이 발생하지 않도록 서버 사이드에서 스타일 코드를 삽입함. 훅에서 이러한 작업을 할 수있도록 도와주는 것이 이 useIntertionEffect 훅.

기본적인 구조는 useEffect와 동일하나 실행시점이 다름. useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행됨. useEffect, useLayoutEffect, useInsertionEffect의 실행순서는 다음과 같다

```jsx
function Index() {
  useEffect(() => {
    console.log("useEffect");
  }); // 3

  useLayoutEffect(() => {
    console.log("useLayoutEffect");
  }); // 2

  useInsertionEffect(() => {
    console.log("useInertionEffect");
  }); // 1
}
```

## 2. react-dom/client

### createRoot

기존 react-dom에 있던 render 메서드를 대체할 새로운 메서드.

### hydrateRoot

SSR 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드 React DOM 서버 API와 함께 사용됨

## 3. react-dom/server

### renderToPipiableStream

리액트 컴포넌트를 HTML로 렌더링하는 메서드. 이 메서드는 스트림을 지원하는 메서드로. HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다. 이를 통해 서버에서는 Suspense를 이용해 빠르게 렌더링이 필요한 부분을 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링 되게끔 할 수있음. 여기에 앞서 소개한 hydrateRoot를 호출하면 서버에서는 HTML을 렌더링하고, 클라이언트의 리액트에서는 여기에 이벤트만 추가함으로써 첫번쨰 로딩을 매우 빠르게 수행할 수 있다.

```jsx
import * as React from 'react'

function render(url, res){
	let didError = false
	// 서버에서 필요한 데이터를 불러온다
	// 그리고 여기에서 데이터를 불러오는 데 오랜 시간이 걸린다고 가정
	const data = createServerData()
	const stream = renderToPipeableStream(
		// 데이터를 Context API로 넘긴다.
		<DataProvider data={data}>
			<App assets={assets} />
		</DataProvider>,
		{
			// 렌더링 시에 포함시켜야 할 자바스크립트 번들
			bootstrapScripts: [assets['main.js']],
			onShellReady() {
				// 에러 발생 시 추가
				res.statusCode = didError ? 500 : 200
				res.setHeader('Content-type','text/html')
				stream.pipe(res)
			},
			onError(x) {
				didError = true
				console.error(x)
			},
		},
	)
	// 렌더링 시작 이후 일정 시가이 흐르면 렌더링에 실패한 것으로 간주하고 취소
	setTimeout(() => strea.abort(), ABORT_DELAY)
}
export default function APP({assets}) {
	return (
		<Html assets={assets} title="Hello">
			<Suspense fallback={<Spinner/>}>
				<ErrorBoundary FallbackComponent={Error}>
					<Content />
				</ErrorBoundary>
			</Suspense>
		</Html>
	);
}

function Content() {
	return (
		<Layout>
			<NavBar />
			<article className="post">
				<section className="comments">
					<h2>Comments</h2>
					<!-- 데이터가 불러오기 전에 보여줄 컴포넌트 -->
					<Suspense fallback={<Spinner />}>
						<!-- 데이터가 완료된 후에 노출되는 컴포넌트 -->
						<Comment/>
					</Suspense>
				</section>
				<h2>Thanks for reading!</h2>
			</article>
		</Layout>
	);
}
```

### renderToReadableStream

웹 스트림을 기반으로 작동하는 메서드. 서버 환경이 아닌 클라우드플레어나 디노 같은 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용됨.

## 4. 자동 배치(Automatic Batching)

리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법.

## 5. 더욱 엄격해진 엄격 모드

### 리액트의 엄격모드

리액트에서 제공하는 컴포너트 중 하나. 리액트 애플리케이션에서 발생할수도 있는 잠재적인 버그를 찾는데 도움이 되는 컴포넌트. 컴포넌트 형태로 선언해서 사용할 수 있음.

- 더이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
  componentWillMount, componentWillReceiveProps, componentWillUpdate는 더이상 사용할 수 없음.
- 문자열 ref 사용금지
- findDOMNode에 대한 경고 출력
  findDOMNode는 클래스 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 메서드. 현재는 사용하는 것이 권장되지 않음.
- 구 Context API 사용 시 발생하는 경고
- 예상치 못한 부작용(side-effects) 검사

### 리액트 18에서 추가된 엄격 모드

이후에 있을 변경을 위해 StrictMode에서 고의로 useEffect를 두번 작동 시키는 내용을 추가함.

## 6. Suspense 기능 강화

Suspense는 리액트 16.6에서 실험버전으로 도입된 기능. 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능

변경된 내용

- 마운트되기 직전임에도 effect가 빠르게 실행되는 문제 수 정
- suspense로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행됨.
- Suspense를 이제 서버에서도 실행할 수 있게 된다
- Suspense 내에 스로틀링이 추가됐다.

## 7. 인터넷 익스플로러 지원 중단에 따른 추가 풀리필 필요

이제 리액트는 리액트를 사용하는 코드에서 다음과 같은 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포됨.

- promise, symbol, Object.assign

## 8. 그밖에 알아두면 좋은 사항

- 이제 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않음. undefined반환은 null반환과 동일하게 처리
- 이와 마찬가지로 <Suspense fallback={undefined}>도 null과 동일하게 처리된다
- renderToNodeStream이 지원 중단됐다. 그 대신 renderToPipeableStream을 사용하는 것이 권장됨
