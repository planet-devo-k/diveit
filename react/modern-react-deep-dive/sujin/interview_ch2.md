1. any와 unknown의 차이를 설명하고, 실제 프로젝트에서 unknown을 어떻게 활용했는지 예를 들어 설명해주세요.

- any는 타입 검사를 완전히 비활성화시키는 반면, unknown은 어떤 값이든 받을 수 있지만 사용하기 전에 타입을 반드시 좁혀야 합니다.
  즉, `unknown`은 타입 안정성을 유지한 채 유연성을 제공하는 상위 타입(top type)이고, `any`는 사실상 타입 시스템을 무력화합니다.

2. 리액트 파이버 구조가 기존 가상 DOM 대비 어떤 문제를 해결하기 위해 도입되었으며, 렌더링의 “렌더 단계”와 “커밋 단계”는 각각 어떤 특징을 가지고 있나요?

- 리액트 파이버는 기존 가상 DOM이 갖고 있던 동기 렌더링의 한계를 해결하기 위해 도입된 구조입니다.

  기존에는 렌더링이 한 번 시작되면 중단할 수 없어서 대규모 컴포넌트 트리에서는 프레임 드랍이 발생했습니다.

  파이버는 각 컴포넌트를 “작은 작업 단위”로 쪼개고, **우선순위를 부여해 중단·재개·폐기가 가능한 비동기 렌더링**을 지원합니다.

  렌더링은 두 단계로 나뉩니다:

- **렌더 단계(Render Phase)**: 가상 DOM을 비교(diff)하고 변경사항을 계산하는 단계. 비동기적으로 일어날 수 있습니다.
- **커밋 단계(Commit Phase)**: 계산된 변경사항을 실제 DOM에 반영하는 단계. 이 단계는 **동기적**이며 중단될 수 없습니다.

이 구조 덕분에 리액트는 애니메이션이나 사용자 입력 중에도 프레임 단위를 유지하면서 반응성을 높일 수 있습니다.

3. 클래스 컴포넌트의 생명주기 메서드와 함수 컴포넌트의 useEffect는 어떤 점이 다르며, useEffect가 “생명주기를 위한 훅이 아니다”라는 말의 의미를 설명해주세요.
   클래스 컴포넌트의 생명주기 메서드는 시점 중심적(componentDidMount, componentDidUpdate, componentWillUnmount)으로 동작하지만, useEffect는 의존성 중심적으로 작동합니다.

   즉, “언제 실행되는가”보다 “무엇이 변했을 때 실행되는가”가 핵심이에요.

   그래서 `useEffect`는 생명주기를 단순히 흉내내는 것이 아니라, **props나 state의 변화에 따라 부수효과를 동기적으로 발생시키는 메커니즘**이에요.

   예를 들어 다음 코드는 `count` 값이 바뀔 때마다만 실행되며, 마운트/언마운트에 해당하는 구문도 한 곳에서 함께 관리할 수 있습니다.

   ```tsx
   useEffect(() => {
     console.log("mounted or count changed");
     return () => console.log("cleanup on unmount");
   }, [count]);
   ```

   즉, `useEffect`는 생명주기 대체제가 아니라 **반응형 부수효과 관리 도구**라고 이해하는 게 맞습니다.

4. JSX가 실제로 자바스크립트 코드로 변환될 때 어떤 과정이 일어나며, @babel/plugin-transform-react-jsx가 하는 일을 간단히 설명해주세요.
   JSX는 ECMAScript의 일부가 아니라 별도의 구문이기 때문에 브라우저는 직접 이해하지 못합니다.

   [1장 리액트 개발을 위해 꼭 알아야할 자바스크립트](https://www.notion.so/1-27af98624f998077860be7bc5d8e0eef?pvs=21)

   그래서 Babel의 `@babel/plugin-transform-react-jsx`가 **JSX 문법을 `React.createElement` 형태의 자바스크립트 함수 호출로 변환**합니다.

   예를 들어 다음 코드는

   ```jsx
   const element = <h1 className="title">Hello</h1>;
   ```

   Babel에 의해 다음처럼 변환됩니다:

   ```jsx
   const element = React.createElement("h1", { className: "title" }, "Hello");
   ```

   즉, JSX는 단순한 문법적 설탕이며, Babel은 이 구문을 트리 구조로 분석해 ECMAScript 코드로 변환하는 트랜스파일러 역할을 합니다.

   이 덕분에 HTML처럼 작성해도 리액트가 내부적으로 가상 DOM 객체를 효율적으로 관리할 수 있습니다.

5. 리액트에서 memo, useMemo, useCallback을 사용할 때의 장단점과, “섣부른 최적화를 경계해야 한다”는 이유를 구체적인 시나리오로 설명해주세요.
   memo, useMemo, useCallback은 불필요한 리렌더링이나 함수 재생성을 막기 위한 메모이제이션 기법이지만, 모든 경우에 성능 향상을 보장하진 않습니다.

   예를 들어 가벼운 연산이나 단순한 props만 전달하는 컴포넌트에 `React.memo`를 감싸면, props에 대한 얕은 비교가 오히려 더 큰 비용이 될 수 있습니다.

   ```tsx
   const Button = React.memo(({ label }) => <button>{label}</button>);
   ```

   이런 단순 컴포넌트는 memo 없이 렌더링하는 게 더 효율적일 수 있습니다.

   반면, 복잡한 연산이나 큰 자식 트리를 가진 컴포넌트라면 `useMemo`나 `useCallback`을 통해 비싼 연산을 캐싱하는 것이 유리합니다.

   핵심은 **렌더링 비용 vs 메모이제이션 비용**의 균형입니다.

   리액트 공식문서에서도 “useMemo는 성능 최적화를 보장하지 않으며, 캐시 무효화 정책에 따라 재계산될 수 있다”고 명시되어 있습니다.

   따라서 “작동하게 만든 다음에 최적화하라”는 접근이 가장 바람직합니다.
