# Chapter 2

## JSX란?

* 자바스크립트 내부에서 표현하기 까다로웠던 XML 스타일의 트리 구문을 작성하는데 도움을 주는 문법

### JSX의 정의

* 4가지의 컴포넌트를 기반으로 구성되어 있다.

**JSXElement**

* JSX를 구성하는 가장 기본요소 (HTML과 비슷한 역할)

```jsx
//JSXOpeningElement : 요소의 시작
<JSXElement>

//JSXClosingElement : 요소의 끝 내부적으로 자식을 포함할 수 없는 형태
</JSXElement>

// JSXSelfClosingElement : 요소가 시작되고, 스스로 종료하는 형태
<JSXElement />

//JSXFragment : 아무런 요소가 없는 형태 </> 불가능
<>JSXChildren(optional)<>
```

**JSXElementName**

* JSXElement의 요소 이름으로 쓸 수 있는 것

```jsx
//JSXIdentifier : JSX 내부에서 사용할 수 있는 식별자  (JS의 규칙과 동일) $, _ 외 특수문자, 숫자로는 시작할 수 없다.

// 가능
<$></$>
<_></_>

// 불가
<1></1>

//JSXNamespacedName:JSXIdentifier:JSXIdentifier의 조합 : ':'을 통해 서로 다른 식별자 연결 (최대 한 개)
<foo:bar></foo:bar> // O
<foo:bar:baz></foo:bar:baz> // X

//JSXMemberExpression.JSXIdentifier.JSXIdentifier의 조합 : '.'을 통해 서로 다른 식별자 연결 (여러 개 가능, JSXNamespacedName 끼리는 불가)
<foo.bar></foo.bar> // O
<foo.bar.baz></foo.bar.baz> // O
```

**JSXAttributes**

* JSXElement에 부여할 수 있는 속성
* 단순 속성을 의미 하기 때문에 모든 경우에서 필수 값 X, 존재 하지 않아도 에러 X

JSXSpreadAttributes: 자바스크립트의 전개 연산자와 역할 동일

JSXAttribute: 속성을 나타내는 키와 값 표현

* 키(JSXAttributeName): `:`을 이용해 키를 나타낼 수 있다.\
  `<foo.bar foo:bar="baz"></foo.bar>`
* 속성(JSXAttributeValue): 키에 할당 하는 값으로 다음중 하나를 만족해야 한다.

1. "큰 따옴표로 구성된 문자열"
2. '작은 따옴표로 구성된 문자열'
3. {AssignmentExpression}: 자바스크립트에서 값을 할당할 때 쓰는 표현식

```jsx
function Child({ attribute }) {
  return <div>{attribute}</div>;
}
```

4. JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다

* attribute={//...} <= prettier 규칙

```jsx
<Child attribute=<div>hello</div> />
```

5. JSXFragment: 속성을 갖지 않는 형태의 JSX 요소가 들어 갈 수 있다.

**JSXChildren**

* JSXElement의 자식의 값을 나타낸다.
*   부모 자식 관계에서 자식을 JSXChildren이라 부름

    1. JSXChild: JSXChildren을 다루는기본 단위, JSXChild를 0개 이상 가질 수 있다. JSXChildren은 JSXChild 가 없어도 상관 없음
    2. JSXText: `{,<,>,}`을 제외한 문자열. 사용하고 싶으면 문자열로 표기
    3. JSXElement: 값으로 다른 JSX 요소가 들어갈 수 있다.
    4. JSXFragment: 값으로 빈 JSX 요소인 `<></>`가 들어갈 수 있다.
    5. { JSXChildExpressions (optional) }: 자바스크립트 표현식을 의미.

    ```jsx
    export default function App() {
      return <>{() => "foo"}</>;
    }
    ```

**JSXStrings**

* HTML과 JSX 사이에 복사와 붙여넣기를 쉽게 할 수 있도록 설계
* HTML에서 사용 가능한 문자열 모두 사용 가능
* `\`는 자바스크립트에서 특수문자를 처리할 떄 사용되므로 몇 가지 제약 사항이 있음 (HTML은 제약 X)

```js
 // 불가
let esc1 = "\"
// 가능
let esc2 = "\\"
```

### JSX는 어떻게 자바스크립트에서 변환될까?

* `@babel/plugin-transform-react-jsx` 플러그인을 통해 JSX 구문을 자바스크립트가 이해할 수 있게 형태 변환
* 공통점은 다음과 같음\
  a. JSXElement를 첫 번째 인수로 선언해 요소를 정의한다.\
  b. 옵셔널인 JSXChildren, JSXAttributes, JSXStrings는 이후 인수로 넘겨주어 처리

```jsx
//이 점을 활용한다면 다음과 같이 처리 할 수 있음

// 활용 X
function A({ isHeading, children }: Props<{ isHeading: boolean }>) {
  return isHeading ? <h1>{children}</h1> : <div>{children}</div>;
}

// 활용 O
import { createElement } from "react";

function A({ isHeading, children }: Props<{ isHeading: boolean }>) {
  return createElement(
    isHeading ? "h1" : "div",
    { className: "text" },
    children
  );
}
```

## 2.2 가상 DOM과 리액트 파이버

### DOM과 브라우저 렌더링 과정

* DOM(Document Object Model): 웹페이지에 대한 인터페이스. 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄 지에 대한 정보

**렌더링 과정**

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML파일 다운로드
2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM노드로 구성된 트리(DOM)를 만든다
3. 2번 과정에서 CSS파일을 만나면 해당 CSS 파일 다운로드
4. 브라우저 렌더링 엔진이 이 CSS도 파싱해 CSS노드로 구성된 트리를 만든다(CSSOM)
5. 브라우저는 2번에서 만든 DOM노드를 순회. 모든 노드를 방문하는 것이 아닌 사용자 눈에 보이는 노드만 방문.(display:none과 같이 보이지 않는 요소는 방문 X)
6. 5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS스타일 정보를 이 노드에 적용.

*   DOM노드에 CSS를 적용하는 과정\
    레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정 [참고 영상](https://www.youtube.com/watch?v=ZTnIxIA5KGw\&t=11s)\
    페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

    #### 가상 DOM(Virtual DOM)의 탄생 배경

    * DOM 변경이 일어날 때마다 레이아웃이 일어나면서 필연적으로 리페인팅 작업이 발생하기 때문에 비용 증가
    * 변경이 많이 일어나는 자식 요소를 가지고 있는 경우 하위 자식 요소도 변경이 되기 때문에 더 많은 비용을 브라우저와 사용자가 지불하게 됨

    ```
    결론: 개발자는 비용 감소 + DOM 결과물만 받고 싶다 = 가상 DOM 탄생
    ```

### 가상 DOM을 위한 아키텍처, 리액트 파이버

**리액트 파이버란?**

* 리액트에서 관리하는 평범한 자바스크립트 객체
* 파이버 재조정자(fiberreconciler) : 파이버를 기준으로 화면의 렌더링 하는 요청을 함

**파이버의 역할**

* 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
* 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
* 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

이러한 모든 과정은 비동기로 수행됨, 파이버는 하나의 작업 단위로 구성 되어 있는데 리액트는 이러한 작업 단위를 하나씩 처리하며 `finishedWork()`라는 작업을 마무리한다. 그리고 이 작업을 커밋해 브라우저 DOM에 변경 사항을 만들어 내는데 이는 두 단계로 나눌 수 있다.

1. 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행 해당 작업에서 파이버의 작업, 우선순위를 지정하거나 중지, 버리는 작업이 일어남
2. 커밋 단계에서는 DOM에 실제 변경 사항을 반영하기 위한 작업, `commitWork()`거 실행되는데 해당 과정은 동기식으로 진행되고 중단 X

**리액트 요소와 차이점**

* 리액트 요소는 렌더링이 발생 할 때마다 새롭게 생성되지만 파이버는 가급적이면 재사용
* 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용됨

생성된 파이버는 state변경, 생명주기 메서드 실행, DOM의 변경이 필요한 시점에 실행된다.

### 리액트 파이버 트리

* 파이버 트리는 리액트 내부에서 두 가지가 존재함
* 현재의 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리
* 파이버의 작업이 끝난 후 리액트는 포인터만 변경에 workInProgress 트리를 현재 트리로 변경(더블 버퍼링)
* 더블 버퍼링 : 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법
* 리액트에서는 해당 작업을 커밋 단계에서 수행함
* current 기준으로 작업 시작 => 업데이트 발생 시 파이버는 새로 받은 데이터로 workInProgress 트리를 빌드함 => 작업이 끝나면 다음 렌더링에 해당 트리 사용 => 최종적으로 렌더링이 반영되면 current가 해당 트리(workInProgress)로 변경됨.

**파이버의 작업 순서**

1. 리액트에서 beginWork() 함수 수행
   * 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작
2. 1번 작업이 끝나면 completeWork() 함수를 실행해 파이버 작업 완료
3. 형제가 있다면 형제로 넘어감
4. 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업 완료를 알림

**setState 업데이트가 발생할 경우**

* 앞서 만든 current 트리가 존재하고, state 업데이트 요청을 받아 workInProgress 트리를 다시 빌드함
* 최초 렌더링은 모든 파이버를 새롭게 만들었지만 해당 상황은 파이버가 존재하기 때문에 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리됨

### 파이버와 가상 DOM

* 가상 DOM은 웹 애플리케이션에서만 통용되는 개념으로 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기 때문에 동일한 개념이 아니다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 클래스 컴포넌트

* 기본적으로 클래스 컴포넌트를 만들려면 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends해야 함, 넣을 수 있는 클래스는 다음과 같음
  * React.Component
  * React.PureComponent

**클래스 컴포넌트의 생명주기 메서드**

* 생명 주기 메서드가 실행되는 시점
  * 마운트(mount): 컴포넌트가 생성되는 시점
  * 업데이트(update): 이미 생성된 컴포넌트의 내용이 변경되는 시점
  * 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

**생명주기 메서드**

* `render():` 클래스 컴포넌트의 유일한 필수 값으로 항상 쓰임, 컴포넌트가 UI를 렌더링하기 위해서 쓰인다. 마운트와 업데이트 과정에서 일어나게됨
  * 주의점: 항상 순수해야 하며 부수효과가 없어야함 (같은 입력 값이 들어가면 같은 결과물을 반환해야 한다는 뜻)
* `componentDidMount():` 컴포넌트가 마운트되고 준비되는 즉시 실행됨, 내부에 `this.setState()`로 `state` 값을 변경하는 것이 가능 => 호출 후 `state`가 변경되고 렌더링을 시도(UI를 업데이트 하기 전에 실행하여 사용자가 변경을 알 수 없다.)
* `componentDidUpdate():` 컴포넌트 업데이트가 일어난 이후 바로 실행된다. 일반적으로 `state`나 `props`의 변화에 따라 DOM 업데이트에 사용됨 여기도 `this.setState`를 사용할 수 있다 (조건문으로 감싸지 않는다면 계속해서 호출될 수 있다.)
* `componentWillUnmount():` 언마운트되거나 더 이상 사용되지 않기 직전에 호출됨 (메모리 누수나 불필요한 작동을 막는 클린업 함수를 작성하기 용이)
* `shouldComponentUpdate():` state난 props의 변경으로 래익트 컴포넌트가 다시 리렌더링되는 것을 막고 싶다면 해당 생명주기 메서드를 사용함
* `static getDerivedStateFromProps():` 사라진 `componentWillReceiveProps`를 대체할 수 있는 메서드, 이 메서드는 `render()`를 호출하기 직전에 호출
* `getSnapShotBeforeUpdate():` `componentWillUpdate()`를 대체할 수 있는 메서드 DOM이 업데이트되기 직전에 호출된다. 여기서 반환되는 값은 `componentDidUpdate`로 전달된다.

**클래스 컴포넌트의 한계**

* 데이터의 흐름을 추적하기 어렵다.
* 애플리케이션 내부 로직의 재사용이 어렵다.
* 기능이 많아질수록 컴포넌트의 크기가 커진다.
* 클래스는 함수에 비해 상대적으로 어렵다.
* 코드 크기를 최적화하기 어렵다.
* 핫 리로딩을 하는 데 상대적으로 불리하다.
  * 핫 리로딩(hot reloading): 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법

### 함수 컴포넌트

* render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요 없으며, state는 객체가 아닌 각각의 원시값으로 관리됨

### 함수 컼포넌트 vs 클래스 컴포넌트

**생명주기 메서드의 부재**

* 함수 컴포넌트는 `useEffect` 훅을 사용해 생명주기 메서드와 비슷하게 구현할 수 있다. (비슷할 뿐 똑같지는 않음)
* `useEffect:` 컴포넌트의 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘

**함수 컴포넌트와 렌더링된 값**

* 함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링됨 (클래스는 this로 부터 가져옴)

## 2.4 렌더링은 어떻게 일어나는가?

### 리액트의 렌더링이란?

* 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕을 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

### 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링 : 처음 진입시 리액트는 브라우저에 이 정보를 제공하기 위해 렌더링 수행
2. 리렌더링: 최초 렌더링 이후 발생하는 모든 렌더링을 의미 발생하는 경우는 다음과 같음
   * 클래스 컴포넌트의 setState가 실행되는 경우
   * 클래스 컴포넌트의 forceUpdate가 실행되는 경우
   * 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
   * 컴포넌트의 key props가 변경되는 경우
   * props가 변경되는 경우
   * 부모 컴포넌트가 렌더링될 경우

### 리액트의 렌더링 프로세스

* 시작: 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정된 모든 컴포넌트를 찾는다.
* 발견: 클래스의 경우에는 내부의 render() 함수를 실행하게 되고 함수는 컴포넌트 그 자체를 호출 후 저장됨

### 렌더와 커밋

* 렌더 단계: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
* 커밋 단계: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정, 해당 작업이 끝나야 브라우저의 렌더링이 발생

## 컴포넌트 함수의 무거운 연산을 기억해 두는 메모이제이션

### 주장1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자.

* 메모이제이션이 만능처럼 보이지만 메모이제이션도 비용이든다.
* 값을 비교하고 렌더링 또는 재계산이 필요한지, 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 비용이 존재

### 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션 해버리자

* memo를 사용하지 않을 경우 발생할 수 있는 문제는 다음과 같다
  * 렌더링을 함으로써 발생하는 비용
  * 컴포넌트 내부의 복잡한 로직의 재실행
  * 그리고 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
  * 리액트가 구 트리와 신규 트리를 비교
* 해당 주장은 memo를 하지 않았을 때 치러야 할 잠재적 위험 비용이 더 크기 때문에 나오는 주장이다.

### 결론 및 정리

리액트의 이해도와 웹 애플리 케이션에 대해 접근하는 관점을 넓히고 싶다 = 1번 시간적 여유가 없다 = 2번
