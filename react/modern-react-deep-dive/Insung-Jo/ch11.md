# 11장 Next.js과 리액트 18

## 11.1 app 디렉터리의 등장

- 기존 next.js 12 버전에서는 레이아웃을 공통으로 유지하려면 `_app`이 유일함 (제한적)

- 이런 한계를 극복하기 위해 app 레이아웃이 등장

### 라우팅

- 기존 `/pages` -> `/app`으로 변경

- 파일명으로 라우팅이 가능했으나 불가능하게 변경

**라우팅을 정의 하는 법**

- Next.js 12 이하: `/pages/a/b.tsx` or `/pages/a/b/index.tsx`는 모두 동일한 주소 (파일명이 index이면 내용 무시)

- Next.js 13 app: `/app/a/b`는 `/a/b`로 변환되며, 파일명은 무시됨 (폴더명 까지만 주소 변환)

**layout.js**

- 기본적인 레이아웃을 구성하는 요소

- 해당 폴더에 layout이 있다면 그 하위 폴더 및 주소에 모두 영향을 미침 (부모 자식 관계)

```tsx
export default function DashboardLayout({
  children, // 페이지 또는 중첩 레이아웃이 될 것임
}: {
  children: React.ReactNode;
}) {
  return (
    <section>
      {/* 여기에는 헤더나 사이드바와 같은 공유 UI를 포함하세요 */}
      <nav></nav>

      {children}
    </section>
  );
}
```

**page.js**

- 일반적인 페이지를 의미

```tsx
export default function BlogPage() {
  return <>//...</>;
}
```

**error.js**

- 라우팅 영역에서 사용되는 공통 에러 컴포넌트

- 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능

```tsx
"use client"; // Error boundaries must be Client Components

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error);
  }, [error]);

  return (
    <div>
      <h2>Something went wrong</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  );
}
```

**not-found.js**

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용

```tsx
import Link from "next/link";

export default function NotFound() {
  return (
    <div>
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
```

**loading.js**

- 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용

- `"use client"`를 사용하여 클라이언트에서 렌더링 가능

```tsx
export default function Loading() {
  // 또는 커스텀 로딩 스켈레톤 컴포넌트
  return <p>Loading...</p>;
}
```

**route.js**

- api 디렉터리에서 라우팅 주소를 담당하며 디렉터리의 파일명이 route.js로 통일

- REST API의 get, post와 같은 메서드명을 예약어로 선언해두면 HTTP 요청에 맞게 해당 메소드를 호출함

## 11.2 리액트 서버 컴포넌트

### 서버 컴포넌트란?

- 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법.

- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없음.

### 서버 컴포넌트의 배경과 필요성

- 기존 SSR의 한계: 클라이언트에서 HTML을 받은 후에도 자바스크립트 번들을 모두 다운로드하고 하이드레이션(Hydration) 과정을 거쳐야 인터랙션이 가능함. 이는 사용자 경험을 저하시키는 요소가 됨.

- TBT(Total Blocking Time) 감소: 서버에서 렌더링을 수행하고 결과물만 전달함으로써 클라이언트가 다운로드해야 할 자바스크립트 양을 획기적으로 줄임.

### 서버 컴포넌트 vs 클라이언트 컴포넌트

1.  서버 컴포넌트 (Server Components)
    - 서버에서 한 번 실행되고 끝나는 컴포넌트.

    - 상태(useState), 효과(useEffect), 브라우저 API(window, document 등) 사용 불가.

    - DB에 직접 접근하여 데이터를 가져올 수 있음.

    - 클라이언트로 전송되는 번들에 포함되지 않음.

2.  클라이언트 컴포넌트 (Client Components)
    - "use client" 지시문을 상단에 선언하여 정의.

    - 기존의 리액트 컴포넌트와 동일하게 동작(상태, 효과, 이벤트 핸들러 사용 가능).

    - 서버 컴포넌트의 자식으로 존재할 수 있으나, 서버 컴포넌트를 직접 import할 수는 없음 (대신 children props로 전달받는 것은 가능).

## 11.3 데이터 페칭, 캐싱, 그리고 재검증 (Data Fetching)

Next.js 13부터는 기존의 getStaticProps, getServerSideProps가 사라지고, 리액트의 fetch API를 확장하여 사용합니다.

### fetch API 확장

- 캐싱(Caching): 기본적으로 fetch 요청은 자동으로 캐싱됨.

- 재검증(Revalidation): 특정 시간 간격으로 데이터를 갱신할 수 있음.

```tsx
// 1. SSG(Static Site Generation)와 유사: 기본 캐싱  fetch('https://...');
// 2. SSR(Server Side Rendering)과 유사: 캐싱하지 않음  fetch('https://...', { cache: 'no-store' });
// 3. ISR(Incremental Static Regeneration)과 유사: 주기적 갱신  fetch('https://...', { next: { revalidate: 60 } });
```

### 함수 레벨에서의 캐싱 (cache)

- fetch가 아닌 일반적인 함수(DB 직접 호출 등)의 결과값을 캐싱하고 싶을 때 리액트의 cache 함수를 사용하여 중복 호출을 방지함.

## 11.4 서버 액션 (Server Actions)

API Route를 명시적으로 만들지 않고도, 클라이언트 컴포넌트에서 서버 함수를 직접 호출할 수 있는 기능입니다.

### 특징

- "use server" 지시문을 사용함.

- form 태그의 action 속성에 직접 연결 가능.

- 서버에서 실행되므로 DB 보안에 유리하며, 자바스크립트 비활성화 환경에서도 기본 동작 가능.

```tsx
// app/post/page.tsx
export default function Page() {
  async function createInvoice(formData: FormData) {
    "use server";

    const rawFormData = {
      customerId: formData.get("customerId"),
      amount: formData.get("amount"),
    };

    // DB 업데이트 로직 실행...
  }

  return <form action={createInvoice}>...</form>;
}
```

## 11.5 변형된 메타데이터 API

기존의 <Head> 컴포넌트 대신, layout.js나 page.js에서 Metadata 객체를 내보내는 방식으로 변경되었습니다.

```tsx
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "나의 블로그",
  description: "Next.js 13으로 만든 블로그입니다.",
};
```
