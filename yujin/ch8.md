## 📝 좋은 리액트 코드 작성을 위한 환경 구축: ESLint 활용 심층 분석

본 내용은 \*\*ESLint(정적 코드 분석)\*\*를 활용하여 고품질의 리액트 코드를 작성하고 환경을 구축하는 방법에 대해 다룹니다.

---

## 1\. ESLint를 활용한 정적 코드 분석

\*\*정적 코드 분석(Static Code Analysis)\*\*이란 코드를 실제로 **실행하지 않고** 코드 그 자체만으로 \*\*코드 스멜(Code Smell)\*\*이나 잠재적 문제 소지가 있는 부분을 찾아내어 사전에 수정하는 과정입니다.

### ESLint의 코드 분석 원리 (AST 기반)

ESLint는 다음 4단계 과정을 거쳐 코드를 분석하고 문제점을 찾아냅니다.

1.  **읽기:** 자바스크립트 코드를 단순한 **문자열**로 읽습니다.
2.  **구조화 (파싱):** 자바스크립트 코드를 분석할 수 있는 **파서** (기본값: **espree**)를 사용해 코드를 구조화합니다.
3.  **트리 생성:** 구조화된 형태를 \*\*AST(Abstract Syntax Tree, 추상 구문 트리)\*\*라는 JSON 기반의 트리 구조로 만듭니다. AST의 각 노드에는 코드 타입(`"type": "Program"`, `"type": "JSXElement"`), 시작/끝 위치(`start`, `end`) 등의 정보가 담깁니다.
4.  **규칙 대조:** 생성된 AST를 기준으로 ESLint에 설정된 각종 \*\*규칙(Rules)\*\*과 대조하여 위반 코드를 알리거나 자동으로 수정합니다.

<!-- end list -->

```json
// AST 예시 (JSX Element)
{
  "type": "Program",
  "body": [
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "JSXElement", // JSX 요소 타입
        "openingElement": {
          "name": { "name": "Sample" } // 컴포넌트 이름
        },
        "closingElement": null,
        "children": []
      }
    }
  ],
  "sourceType": "module"
}
```

---

## 2\. ESLint 플러그인과 설정 (Plugin & Config)

ESLint의 기능을 확장하고 특정 도메인에 맞는 규칙 세트를 적용하기 위해 `plugin`과 `config`를 사용합니다.

| 종류                | 역할          | 설명                                                                                                            | 예시                                                                        |
| :------------------ | :------------ | :-------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------- |
| **`eslint-plugin`** | **규칙 제공** | 특정 프레임워크나 도메인(예: React, TypeScript, Import 순서)과 관련된 **새로운 규칙**을 묶어서 제공하는 패키지. | `eslint-plugin-react`, `eslint-plugin-import`                               |
| **`eslint-config`** | **규칙 묶음** | 여러 개의 `eslint-plugin`을 한데 묶어 **완벽한 설정 세트**로 제공하는 패키지.                                   | `eslint-config-airbnb`, `eslint-config-next`, `@titicaca/triple-config-kit` |

### 주요 ESLint Config 소개

- **`eslint-config-airbnb`:** 에어비앤비에서 만든 설정으로, 가장 엄격하고 널리 사용되는 리액트 기반 프로젝트용 설정 세트입니다.
- **`eslint-config-next`:** Next.js 프레임워크 전용 설정으로, 페이지나 컴포넌트의 JSX, 그리고 `_app.js`, `_document.js` 등의 Next.js 특정 파일에 대한 정적 분석 규칙을 제공합니다.

---

## 3\. 나만의 ESLint 규칙 만들기 및 커스터마이징

ESLint 설정 파일을 통해 이미 존재하는 규칙을 수정하거나 새로운 규칙을 정의할 수 있습니다.

### 커스터마이징 예시: `import React` 제거

리액트 17버전부터 **새로운 JSX 런타임**이 도입되어 JSX를 사용해도 파일 상단에 `import React from 'react';` 구문이 필요 없어졌습니다. 이를 위해 설정 파일에서 관련 규칙을 조정할 수 있습니다 (최신 ESLint 9 버전 기준 설정 예시).

```javascript
// eslint.config.mjs (최신 형식)

export default [
  // 1️⃣ TypeScript 설정
  ...tseslint.configs.recommended,

  // 2️⃣ React 설정
  {
    plugins: {
      react: reactPlugin,
    },
    rules: {
      // ✅ 최신 JSX 런타임 사용 시 'import React' 불필요 경고 끄기 (예시)
      // "react/react-in-jsx-scope": "off",

      "react/jsx-pascal-case": "error", // React 컴포넌트는 PascalCase 강제
    },
    settings: {
      react: {
        version: "detect", // 프로젝트 react 버전을 자동으로 감지
      },
    },
  },

  // 3️⃣ Import 설정
  {
    plugins: { import: importPlugin },
    rules: {
      "import/no-unresolved": "off", // TypeScript가 확인하므로 ESLint 중복 검사 비활성화
      "import/no-duplicates": "error", // 같은 모듈에서 여러 번 import 하는 것을 금지
    },
    // ... import resolver 설정 (TypeScript 경로와 연동)
  },

  // 4️⃣ 프로젝트 전체 공통 설정
  {
    files: ["**/*.ts", "**/*.tsx"],
    rules: {
      "prefer-arrow-callback": "error", // 콜백함수는 화살표 함수로
      "func-style": ["error", "expression"], // 함수는 선언문이 아닌 표현식으로
      "prefer-const": "error", // 재할당되지 않는 변수는 const로
      "no-var": "error", // var 키워드 금지
    },
  },
];
```

---

## 4\. ESLint 환경 구축 시 주의사항

### 1\. Prettier와의 충돌 방지

- **문제점:** ESLint에도 **스타일 관련 규칙**(예: 세미콜론 사용 여부, 들여쓰기)이 많고, Prettier 또한 포맷팅을 담당하므로 두 도구가 서로 충돌하는 규칙으로 인해 에러가 발생할 수 있습니다.
- **해결:** `eslint-config-prettier` 패키지를 사용하여 **ESLint의 모든 스타일 관련 규칙**을 비활성화하고 포맷팅은 **Prettier**에게 전적으로 위임해야 합니다.

### 2\. 규칙에 대한 예외 처리 (주석 사용)

특정 코드 라인에서만 규칙을 **임시로 제외**하고 싶다면 주석을 사용합니다.

- `// eslint-disable-line [규칙명]`: 해당 라인에서만 규칙을 비활성화.
- `// eslint-disable-next-line [규칙명]`: 다음 라인에서만 규칙을 비활성화.
- **`react-hooks/no-exhaustive-deps`:** `useEffect`, `useCallback` 등 의존성 배열(`deps array`)이 필요한 훅에 의존성이 제대로 선언되었는지 확인하는 중요한 규칙입니다. 이 규칙을 임의로 비활성화하는 것은 **주의**해야 합니다.

### 3\. ESLint 버전 충돌

- **문제점:** 설치한 플러그인(`eslint-plugin-*`)이나 설정(`eslint-config-*`) 패키지가 ESLint 코어 버전이나 다른 의존성의 버전과 서로 달라 충돌이 발생할 수 있습니다.
- **해결:** ESLint는 `peerDependencies`를 설정하여 의존성 충돌을 피하도록 권장합니다. 환경 설정 시 의존성 버전을 명확히 맞춰야 합니다.

---

## 8.2 리액트 컴포넌트 테스트 코드 작성하기

프론트엔드 애플리케이션은 사용자의 입력, 비즈니스 로직, 그리고 예상치 못한 다양한 시나리오를 고려해야 하므로 **테스트가 매우 중요**합니다. 이 절에서는 **React Testing Library**를 활용하여 사용자 관점에서 리액트 컴포넌트를 테스트하는 방법을 심도 있게 다루고 있습니다.

## 8.2.1 React Testing Library란?

- **기반 구조**: **React Testing Library**는 **DOM Testing Library**를 기반으로 만들어진 라이브러리입니다. DOM Testing Library는 다시 **`jsdom`**을 기반으로 합니다.
- **`jsdom`의 역할**: `jsdom`은 Node.js처럼 HTML이 없는 자바스크립트 환경에서도 가상의 HTML과 DOM을 사용할 수 있게 해줍니다. 이를 통해 실제 브라우저 환경에서처럼 DOM을 조작하고 테스트할 수 있습니다.
- **테스트 철학**: React Testing Library는 복잡한 테스트 환경 구축 없이 리액트 컴포넌트를 **실제 사용자가 눈으로 보는 방식**과 유사하게 DOM을 통해 테스트하도록 권장합니다.

## 8.2.2 자바스크립트 테스트의 기초

- **테스트의 원리**: 테스트는 '내가 작성한 코드가 예상대로 작동하는지'를 확인하는 과정이며, **실제 결과**(`actual`)와 **기대하는 결과**(`expected`)를 비교하여 불일치 시 오류를 발생시킵니다.
- **Assertion (어설션)**: 기대한 결과와 실제 결과를 비교하는 기능을 하며, Node.js는 기본적으로 **`assert` 모듈**을 제공합니다.
- **테스트 프레임워크 (Jest)**: Jest는 테스트 실행 시 `test`, `expect` 등의 메서드를 **전역(global) 스코프**에 자동으로 넣어주며, 단순히 성공/실패 외에 테스트 내용, 경과 시간 등 상세 정보를 콘솔에 출력해줍니다.

## 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

리액트 컴포넌트 테스트는 기본적으로 **① 컴포넌트 렌더링 → ② 특정 액션 수행(선택) → ③ 결과 비교**의 순서를 따릅니다.

### A. 정적 및 동적 컴포넌트 테스트

| 유형              | 설명                                                                                  | 주요 테스트 방법                                                                                                                                                        |
| :---------------- | :------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **정적 컴포넌트** | 상태(`useState`)가 없어 항상 동일한 결과를 반환하는 컴포넌트.                         | `render(<App />)`로 렌더링하고 `screen.getByText`로 요소를 찾은 뒤 `expect().toBeInTheDocument()`로 검증. `toHaveAttribute`, `toHaveStyle` 등으로 속성이나 스타일 검증. |
| **동적 컴포넌트** | `useState`를 사용해 상태를 관리하며, 사용자의 액션에 따라 렌더링이 변화하는 컴포넌트. | **`userEvent`** (예: `userEvent.type`, `userEvent.click`)를 사용하여 사용자 액션을 흉내 내고, 상태 변화에 따른 컴포넌트의 렌더링 변화를 확인.                           |

- **요소 찾기 메서드**:
  - `getBy...`: 요소가 없거나 두 개 이상이면 **에러**를 발생.
  - `findBy...`: 비동기 호출 이후 요소를 찾을 때 사용하는 **Promise**를 반환.
  - `queryBy...`: 요소를 찾지 못해도 에러 대신 **`null`**을 반환.
  - `getByTestId`: HTML DOM 요소에 선언된 `data-testid`를 이용해 요소를 선택합니다.
- **이벤트 버블링 활용**: 버튼 목록에서 `onClick` 이벤트 처리 시, 상위 `<ul>` 태그에 이벤트를 추가하고 `event.target.dataset` (HTML의 `data-*` 속성)을 활용하여 필요한 정보를 얻는 방식이 효율적입니다.

### B. 비동기 및 사용자 정의 훅 테스트

| 테스트 유형        | 설명                                                                                  | 주요 기술 및 구현                                                                                                                                                                                                                                                                         |
| :----------------- | :------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **비동기 (Fetch)** | `fetch` 요청을 모킹하여 서버 응답에 따른 컴포넌트의 렌더링 변화를 테스트.             | **MSW (Mock Service Worker)**를 사용해 `fetch` 요청을 가로채고 모의 응답을 제공합니다. `setupServer`, `server.listen()`, `server.close()`, `server.resetHandlers()`를 사용해 서버 환경을 관리. 에러 테스트는 `res(ctx.status(503))`로 모킹하고, 검증 시 `await screen.findByText`를 사용. |
| **사용자 정의 훅** | 훅의 로직이 예상대로 작동하는지, 특히 `props` 변경에 따른 동작을 테스트.              | `@testing-library/react-hooks`를 사용하여 훅을 테스트하며, **`renderHook`** 함수를 사용합니다. `renderHook`이 반환하는 **`rerender`** 함수를 통해 새로운 `props`를 전달하여 훅이 다시 실행되도록 테스트합니다.                                                                            |
| **환경/모킹**      | 테스트 환경에 존재하지 않는 객체 메서드(`window.alert` 등)의 호출 여부나 인자를 검증. | **`jest.spyOn`**으로 메서드를 관찰하고 **`mockImplementation`**으로 모의 구현을 대체합니다. `process.env.NODE_ENV`를 모의하여 프로덕션 환경 최적화 코드가 실행되지 않는지 확인할 수 있습니다.                                                                                             |

### 8.2.4 나만의 ESLint 규칙 만들기

- **목적**: 개발자가 자주 실수하거나, 코드 변경으로 일관성이 깨지는 경우, 또는 PR 검토 시 수동 수정이 필요한 비효율적인 상황을 방지합니다.
- **예시**: React 17 이후 새로운 JSX 런타임 덕분에 불필요해진 **`import React from 'react'`** 구문을 자동으로 제거하여 번들러의 크기를 줄이고 코드 품질을 유지하는 규칙을 만들 수 있습니다.

---

## 8.3 React Testing Library와 테스트 심화

### 1. 테스트 코드 구성 요소

| 요소                           | 역할                                                                                                                      | 상세 내용                                                                   |
| :----------------------------- | :------------------------------------------------------------------------------------------------------------------------ | :-------------------------------------------------------------------------- |
| **`describe`**                 | 연관된 테스트들을 그룹으로 묶어 관리합니다. `describe` 내부에 또 다른 `describe`를 포함하여 계층 구조를 만들 수 있습니다. | 코드가 복잡해질 때 관리하기 편리합니다.                                     |
| **`it` / `test`**              | 테스트가 완전히 성공해야 함을 의미하며, 테스트 코드를 읽기 쉽게 만드는 **별칭(alias)**입니다.                             | 실제 테스트 로직이 들어가는 단위입니다.                                     |
| **`beforeEach` / `afterEach`** | **테스트 라이프사이클** 함수로, 각 `it` 테스트 실행 전 또는 후에 공통 코드를 실행합니다.                                  | MSW 서버 핸들러 초기화(`server.resetHandlers()`) 등 환경 정리에 유용합니다. |
| **`testId`**                   | `data-testid` HTML 속성을 의미하며, `getByTestId` 메서드로 해당 요소를 선택할 수 있도록 합니다.                           | `querySelector('[data-testid="..."]')`와 동일한 역할을 수행합니다.          |

### 2. 테스트의 심화와 목표

- **테스트의 목표**: 소프트웨어 테스트는 단순히 **코드 커버리지 100%를 달성**하는 것이 아니라, **애플리케이션이 핵심 비즈니스 요구사항을 충족하는지** 확인하여 소프트웨어의 품질에 대한 확신을 갖는 것입니다.
- **테스트 유형**:
  - **유닛 테스트 (Unit Test)**: 각 컴포넌트가 독립적으로 작동하는지 검증.
  - **통합 테스트 (Integration Test)**: 유닛 테스트를 통과한 컴포넌트들이 묶여서 정상적으로 작동하는지 검증.
  - **E2E 테스트 (End to End Test)**: 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전반적인 시스템 통합을 검증합니다 (Cypress 등의 라이브러리 필요). React Testing Library는 유닛/통합 테스트를 돕는 데 초점을 맞춥니다.
- **테스트 고려사항**: 프론트엔드 코드는 사용자의 입력에 매우 자유롭기 때문에 100%의 커버리지를 달성하기 어려울 수 있으며, 개발 우선순위에 따라 테스트 코드 작성이 밀릴 수도 있습니다. 핵심적인 부분부터 테스트 코드를 작성하여 소프트웨어 품질에 대한 확신을 갖는 것이 중요합니다.
