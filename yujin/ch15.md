# 🚀 리액트 프로젝트의 시작과 지속 가능한 웹 개발 가이드

리액트는 현재 웹 프론트엔드의 표준으로 자리 잡았지만, 기술의 변화 속도가 빠르고 생태계가 방대하여 프로젝트 시작 단계에서의 신중한 선택이 향후 유지보수의 성패를 결정.

---

## 1. 리액트 프로젝트 시작 시 필수 고려 사항

성공적인 프로젝트 운영을 위해 개발자가 가장 먼저 챙겨야 할 기술적 토대들임.

### 1-1. 버전 관리와 현대적 표준 준수

* **최소 버전 18.3.1 권장:** 리액트 16.8에서 훅(Hooks)과 함수 컴포넌트 개념이 정립되었다면, 18 버전부터는 동시성(Concurrency)과 같은 고도의 렌더링 최적화가 도입되었음. 유지보수 중인 서비스라면 최소한 18 버전 이상의 안정적인 릴리스를 유지해야 최신 라이브러리와의 호환성을 보장받을 수 있음.
* **IE11 공식 종료:** 더 이상 Internet Explorer를 위한 폴리필(Polyfill)과 구형 문법에 시간을 낭비할 필요가 없음. 최신 브라우저 표준에 집중하여 더 가볍고 빠른 번들을 구성하기.

### 1-2. 렌더링 전략: 서버 사이드 렌더링(SSR) 우선 고려

기본 HTML은 비어 있고 자바스크립트로 모든 화면을 그리는 단일 페이지 애플리케이션(SPA)은 다음과 같은 한계가 명확함.

* **SEO 불리:** 검색 엔진 로봇이 자바스크립트를 실행하기 전에는 빈 화면만 수집할 위험이 있음.
* **기기 성능 의존성:** 저사양 모바일 기기 사용자는 거대한 JS 파일을 다운로드하고 실행하는 과정에서 매우 느린 첫 화면을 경험하게 됨.
* **추천:** 콘텐츠 노출이 중요한 일반 사용자 대상 서비스는 SSR(Next.js 등)을 우선 고려하고, SPA는 관리자 페이지나 매우 단순한 이벤트 페이지 등 제한적인 상황에서만 선택하는 것이 좋음.

### 1-3. 상태 관리와 라이브러리 의존성 경계

* **상태 관리 라이브러리의 절제:** Redux, Zustand, Recoil 등은 꼭 필요한 '파생 상태'가 많거나 '상태 합성'이 복잡할 때만 도입하십시오. 단순한 앱에 도입하면 번들 크기만 키우고 프로젝트 구조를 복잡하게 만듦.
* **버전 종속성 주의:** `react-something`과 같이 리액트에 강력하게 종속된 라이브러리는 리액트가 18에서 19로 업그레이드될 때 발목을 잡을 수 있습니다. 가능한 한 리액트 없이도 작동하는 범용 라이브러리를 선택하거나, 라이브러리의 업데이트 속도를 확인한 후 도입해야 함.

---

## 2. 리액트 설계 원칙과 흔히 겪는 혼란들

리액트의 독특한 동작 방식을 이해하지 못하면 비효율적인 코드를 짤 가능성이 높음.

### 2-1. 왜 일반 변수가 아닌 `useState`인가?

리액트 엔진은 메모리 상의 변수 값이 바뀌었다고 해서 브라우저 화면을 다시 그리지 않습니다. `useState`의 세터 함수(예: `setFruits`)를 호출해야만 리액트에게 **"상태가 변했으니 가상 DOM을 다시 그려 실제 DOM과 비교해(Re-render)!"**라고 신호를 보낼 수 있음.

### 2-2. `useEffect`와 비동기 처리의 비밀

* **왜 `async`를 바로 못 쓰나?:** `useEffect`는 반환값으로 반드시 '클린업 함수'나 `undefined`를 받아야 합니다. 하지만 `async` 함수는 호출 즉시 **Promise**를 반환합니다. 리액트는 이 Promise를 클린업 함수로 오해하여 에러를 발생시킴.
* **해결책:** 내부에서 즉시 실행 함수(IIFE)로 비동기 로직을 감싸거나, 별도의 비동기 함수를 선언하여 호출하는 방식을 사용해야 함.

### 2-3. 불변성과 주소값 비교

왜 배열에 `push`를 하면 안 되고 `[...prev, newValue]`처럼 새로 만들어야 할까요? 리액트는 성능을 위해 배열 내부의 값 하나하나를 전수 조사하지 않고, 배열의 **'메모리 주소값'**만 비교합니다. `push`는 주소를 그대로 둔 채 내용만 바꾸므로 리액트가 변화를 감지하지 못합니다. 번거로워 보이지만, 이 방식이 리액트 전체의 렌더링 최적화에 훨씬 유리함.

---

## 3. 웹 개발 인프라의 변화: 자바스크립트에서 러스트(Rust)로

성능의 한계에 부딪힌 자바스크립트 기반 도구들이 시스템 프로그래밍 언어인 러스트로 재작성되고 있음.

### 3-1. 고성능 도구들의 등장

* **SWC와 터보팩:** 바벨과 웹팩을 대체하여 빌드 속도를 수십 배 이상 끌어올림.
* **Biome:** 린트(Lint)와 포맷팅(Format)을 러스트 기반 엔진 하나로 통합하여 매우 빠른 개발 환경을 제공함.
* **WebAssembly (Wasm):** 브라우저가 직접 읽을 수 있는 저수준 이진(Binary) 데이터 형식입니다. C, C++, Rust 코드를 웹에서 실행하여 자바스크립트가 하기 힘든 물리 엔진, 영상 처리 등의 고성능 작업을 수행함.

### 3-2. 경쟁 프레임워크: Svelte

리액트가 브라우저에서 '가상 DOM'을 비교하며 에너지를 쓰는 동안, **Svelte**는 빌드 시점에 "어떤 데이터가 변하면 어떤 DOM을 직접 고칠지" 미리 코드를 생성하는 전략을 취합니다. 리액트의 패러다임이 절대적인 것은 아님을 시사함.

---

## 4. 오픈소스 생태계의 그림자

오픈소스는 무료이고 영원할 것이라는 믿음은 위험할 수 있음.

* **라이선스 리스크:** 과거 페이스북의 BSD+Patents 조항 사례처럼, 기업의 정책 변화로 사용자의 권리가 위협받을 수 있음. (현재 리액트는 안전한 MIT 라이선스입니다.)
* **메인테이너 이슈:** `color.js`, `faker.js` 사태처럼 핵심 개발자의 의도적인 파괴나 지원 중단은 전 세계 인프라에 큰 타격을 줄 수 있습니다. 프로젝트의 의존성을 신중하게 선택해야 하는 이유.

---

## 💡 요약: 개발자의 유연한 자세

기술의 중심이 자바스크립트에서 러스트로 이동하고, 브라우저 내부 작업이 빌드 타임 작업으로 옮겨가고 있음. 하지만 변하지 않는 사실은 모든 웹은 결국 **HTML, CSS, JS**라는 토대 위에 세워진다는 것임. 특정 라이브러리에 매몰되지 않고 웹의 근본 원리를 이해하는 것이 '언젠가 사라질 수도 있는' 기술에 대응하는 최선의 방법.