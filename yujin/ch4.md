## **서버 사이드 렌더링 (SSR) 및 리액트 API 정리**

### **1. 서버 사이드 렌더링 (SSR)의 이해**

**싱글 페이지 애플리케이션 (SPA)의 특징**
• **작동 방식**: 렌더링과 라우팅의 대부분을 **브라우저의 자바스크립트**에 의존합니다.
• **페이지 전환**: 최초 로딩 이후, 페이지 전환 시 서버에서 HTML을 새로 내려받지 않고, 자바스크립트와 브라우저의 `history` API를 사용해 필요한 부분만 다시 그립니다.
• **장점**: 페이지 로딩 후에는 빠르고 매끄러운 UI/UX를 제공합니다.
• **문제점**: 자바스크립트 코드의 양이 증가하면서, **자바스크립트 파싱 및 실행 시간 증가**로 인해 초기 로딩 및 상호 작용 가능 시간이 지연되는 문제가 발생했습니다.

### **서버 사이드 렌더링 (SSR)의 개념**

- **최초에 사용자에게 보여줄 페이지**를 **서버에서 렌더링**하여 완성된 HTML을 사용자에게 빠르게 제공하는 방식입니다.

### **SSR의 장점**

• **빠른 최초 페이지 진입**: 완성된 HTML을 먼저 보여주므로 사용자가 콘텐츠를 빠르게 볼 수 있습니다.
• **SEO (검색 엔진 최적화) 용이**: 검색 엔진 크롤러가 HTML 문서를 쉽게 파싱할 수 있어 메타데이터 제공이 쉽습니다.
• **누적 레이아웃 이동 (CLS) 감소**: 페이지가 처음부터 완전하게 그려지므로 렌더링 이후 레이아웃이 이동할 가능성이 적습니다.
• **디바이스 성능에 비교적 자유로움**: 무거운 렌더링 작업을 클라이언트 대신 서버가 수행합니다.
• **보안**: 민감한 데이터 처리 로직을 서버에 둘 수 있어 클라이언트보다 보안에 더 안전합니다.

### **SSR의 단점**

• **소스코드 작성 시 서버 고려**: 클라이언트와 서버 환경을 모두 고려해야 하므로 개발 복잡도가 증가합니다.
• **적절한 서버 구축 필요**: 렌더링 작업을 수행할 수 있는 서버 환경이 필수입니다.
• **서비스 지연 문제**: 렌더링 작업 부하로 인해 서버의 응답이 늦어질 경우 사용자 경험이 저하될 수 있습니다.

### **2. 서버 사이드 렌더링을 위한 리액트 API**

- 리액트는 서버 환경에서 컴포넌트를 HTML 문자열 또는 스트림으로 변환하는 다양한 API를 제공합니다.**API결과물 형태용도/특징**`renderToString`HTML **문자열**SSR의 가장 기초적인 API. 최초 페이지를 HTML로 변환합니다. 자바스크립트 코드는 별도로 제공되어야 합니다.`renderToStaticMarkup`HTML **문자열**`renderToString`과 동일하지만, **`data-reactroot` 같은 리액트 전용 DOM 속성을 생성하지 않습니다**. 이벤트 리스너가 필요 없는 **순수한 HTML**을 만들 때 사용합니다.`renderToNodeStream`Node.js **ReadableStream**`renderToString`과 동일한 결과물을 **스트림** 형태로 반환합니다. **큰 데이터를 다룰 때** 청크(chunk) 단위로 전송하여 서버 부하를 줄이고 응답 속도를 개선합니다. (Node.js 환경에서만 사용 가능)`renderToStaticNodeStream`Node.js **ReadableStream**`renderToStaticMarkup`의 스트림 버전입니다. 리액트 속성이 없는 순수 HTML 스트림이 필요할 때 사용합니다.**`hydrate`**-`renderToString`이나 `renderToNodeStream`으로 서버에서 생성된 HTML 콘텐츠에 **자바스크립트 핸들러와 이벤트 리스너를 붙여** 상호 작용 가능한 상태로 만듭니다. (클라이언트에서 실행)

### **💡 `hydrate`의 역할**

- `hydrate`는 클라이언트 측에서 실행되며, 이미 존재하는 서버 렌더링된 HTML에 **React의 생명 주기와 이벤트 시스템을 주입**하는 과정입니다. 이는 `ReactDOM.render`가 HTML을 처음부터 새로 렌더링하는 것과 달리, 기존 마크업을 활용하여 **이벤트 부착** 작업만 수행합니다.
  <br><br>

# 4.3 Next.js 아키텍처 및 핵심 가이드 (Pages Router)

## 1. Next.js의 정체성

- **정의:** Vercel이 개발한 **React 기반의 풀스택 웹 프레임워크**
- **철학:** PHP처럼 서버 사이드 렌더링(SSR)을 염두에 두고 설계. **SEO(검색 엔진 최적화)**와 **초기 로딩 속도** 개선에 특화

---

## 2. 핵심 파일 및 프로젝트 구조

### 설정 파일

| 파일명               | 역할 및 특징                                                                                               |
| :------------------- | :--------------------------------------------------------------------------------------------------------- |
| **`package.json`**   | 프로젝트 의존성 및 명령어(Script) 관리                                                                     |
| **`next.config.js`** | **환경 설정 담당.** `reactStrictMode`, `swcMinify`(Rust 기반 고속 컴파일), `redirects`, `basePath` 등 설정 |

### 구조 및 렌더링 제어 파일 (`pages/`)

`_app.tsx`와 `_document.tsx`의 차이를 이해하는 것이 핵심입니다.

| 구분          | `_app.tsx`                                                                | `_document.tsx`                                                               |
| :------------ | :------------------------------------------------------------------------ | :---------------------------------------------------------------------------- |
| **역할**      | **App의 진입점.** 페이지 전환 시 상태 유지, 전역 에러 처리, 공통 레이아웃 | **HTML 뼈대 설정.** `<html>`, `<body>` 태그 커스터마이징, 폰트/웹 아이콘 설정 |
| **실행 위치** | **서버 & 클라이언트** 모두 실행                                           | **오직 서버**에서만 실행 (이벤트 핸들러 사용 불가)                            |
| **주요 사용** | 전역 CSS(`reset.css`), Context API/Provider 설정                          | 메타 태그, `CSS-in-JS` 서버 초기화(FOUC 방지)                                 |

> **Error Handling:** `_error.tsx`(공통 에러), `404.tsx`, `500.tsx`를 통해 상황별 에러 페이지 커스텀 가능

---

## 3. 라우팅 시스템 (Routing)

### 📂 파일 시스템 라우팅 규칙

폴더와 파일 이름이 곧 URL이 됩니다.

1. **정적 라우팅:** `pages/about.tsx` → `/about`
2. **중첩 라우팅:** `pages/blog/post.tsx` → `/blog/post`
3. **동적 라우팅 (Dynamic):**
   - `[id].tsx`: `/hello/123` (변수 1개)
   - `[...props].tsx`: `/hello/a/b/c` (Catch-all, 모든 하위 경로 포함)

### 페이지 이동: Server vs Client

성능 최적화를 위해 내부 이동 시 반드시 `<Link>`를 사용해야 합니다.

- **`<a>` 태그 (Server Routing):**
  - 페이지 전체 리로드 발생
  - 모든 리소스 재다운로드 (비효율적)
- **`<Link>` 컴포넌트 (Client Routing):**
  - JS로 필요한 데이터(JSON/Chunk)만 교체
  - **화면 깜빡임 없이 즉시 전환** (Single Page Application 처럼 동작)

---

## 4. 데이터 페칭 (Data Fetching) 전략

### 주요 함수 비교

| 함수명                         | 렌더링 시점   | 용도                         | 특징                                                              |
| :----------------------------- | :------------ | :--------------------------- | :---------------------------------------------------------------- |
| **`getStaticProps`** (SSG)     | **빌드 타임** | 블로그, 문서 등 정적 컨텐츠  | 빌드 시 HTML 생성. 가장 빠름.                                     |
| **`getStaticPaths`**           | **빌드 타임** | 동적 라우팅(`[id]`)의 SSG    | 어떤 경로를 미리 빌드할지 지정 (`fallback` 옵션 중요)             |
| **`getServerSideProps`** (SSR) | **요청 타임** | 최신 데이터 필수 페이지, SEO | 매 요청마다 서버 실행. 클라이언트에 `__NEXT_DATA__`로 데이터 전달 |

### Hydration과 `__NEXT_DATA__`

- **SSR 과정:** 서버에서 HTML 생성 → 클라이언트 전송 → 브라우저가 HTML 표시 → JS 로드 후 이벤트 연결(Hydration)
- **데이터 불일치 방지:** 서버에서 가져온 데이터를 HTML 내부 `script` 태그(`__NEXT_DATA__`)에 담아 보내주어, 클라이언트가 다시 데이터를 요청하지 않고 그대로 사용 (Mismatch 에러 방지)

---

## 5. 스타일링 (Styling)

1. **Global CSS:** `_app.tsx`에서만 import 가능
2. **CSS Modules:** `name.module.css` 형태. 클래스명 충돌 방지
3. **SCSS:** 별도 설정 없이 설치 후 바로 사용 가능
4. **CSS-in-JS (Styled-components 등):**
   - **문제:** JS가 로드되기 전 스타일 없는 HTML이 잠깐 보이는 현상 (**FOUC**)
   - **해결:** `_document.tsx`에서 `ServerStyleSheet`를 통해 스타일을 미리 수집(collect)하여 HTML에 주입해야 함
   - _Tip:_ 최신 버전에서는 `next.config.js`의 `compiler: { styledComponents: true }` 옵션으로 간단히 처리 가능

---

## 6. API Routes & BFF

- **경로:** `pages/api/*`
- **역할:** 프론트엔드 프로젝트 내에 존재하는 백엔드 기능
- **용도:** CORS 우회, DB 직접 접근, 비밀 키 숨기기 등 **BFF(Backend For Frontend)** 패턴 구현에 적합
