# Interview Questions

### 1장 - 동등비교

- 리액트 컴포넌트의 렌더링이 일어나는 이유 - props의 동등 비교
- 무엇을 기반으로 이루어지는가? - 객체의 얕은 비교
- 얕은 비교가 어떻게 이루어지는가? - Object.is로 먼저 비교 수행 후 Object.is에서 수행하지못하는 객체 간 얕은 비교를 한 번 더 수행하여 첫 번째 깊이에 존재하는 값만 비교
- 객체가 아닌 타입들은 무엇을 갖지 않는가? - 메서드
- Falsy 가 가능한 값? - false/NaN/' '/null/undefined ...
- 객체와 배열은 내부 값 존재 여부와 상관없이 truthy로 취급된다 - O
- [ ]와 { }는 truthy? - O
- 백틱과 작은 따옴표의 차이 - 같은 문자열을 반환하지만 템플릿 리터럴은 줄바꿈이 가능하고 문자열 내부 표현식 사용 가능
- 자바스크립트 문자열의 특징 : 원시타입이며 변경 불가 -> 문자열 생성 후 변경 불가
- Symbol의 특징: 중복되지 않는 어떤 고유한 값을 나타내기 위해 만들어짐
- 배열, 함수, 정규식, 클래스는 객체 타입이다? - O
- 내용이 같아도 참조가 다르면 ===으로 비교 시 false - O
- Object.is는? - ==과 ===의 한계를 극복하기 위해 만들어졌으나 객체 비교에서는 ===과 동일하게 동작
- 객체의 얕은 비교까지만 구현한 이유 - 리액트에서 사용하는 JSX props는 객체고, props만 일차적으로 비교하면 되기때문, 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적으로 얕은 비교로 충분하지만 props에 또 다른 객체를 넘겨줄 시에 리액트 렌더링이 예상치 못하게 작동
- 자바스크립트 객체 비교의 불완전성은 어떤 기능을 사용할 때 고려해야 되는가? - 훅의 의존성 배열 비교/useMemo와 useCallback/React.

### 2장 - 함수

- 함수 정의 4가지 방법 - 함수선언문/함수표현식/Function 생성자/화살표 함수
- 선언식과 표현식의 차이: 호이스팅 여부
- 호이스팅의 관점에서 두 방식의 차이를 설명해주세요 - 두 방식 모두 호이스팅이 발생하지만 표현식은 호이스팅되는 시점에서 var인 경우 undefined로 초기화되므로 함수를 자유롭게 선언하고 호출하고 싶거나 명시적으로 함수를 구별하고 싶은 경우 함수 선언문이 더 좋고, 함수 선언 전 호출이 이루어지는 경우가 안좋게 느껴지는 경우 표현식이 좋을 수 있다.
- Function 생성자 방식이 권장되지 않는 이유 - 함수의 몸통을 모두 문자열로 작성해야하며 함수의 클로저 또한 생성 X
- 화살표 함수의 함수 생성 방식의 차이점 - Constructor 사용 불가/arguments 존재X/this 바인딩
- This 바인딩 관점에서 일반함수와 화살표함수 비교 - 화살표 함수는 별도의 작업을 추가로 하지않고 this에 접근 가능하고 단순히 일반 함수의 축약형이 아닌 this를 선언 시점에서만 결정하는 것이 아니라는 점에서 큰 차이가 있다
- 한 번 선언하고 호출된 이후부터는 더이상 재호출이 불가능하고 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있어 리팩터링에도 도움이 되는 함수? - 즉시 실행 함수
- 좋은 함수란 - 부수 효과를 최대한 억제하여 동일 인수에 대해 동일 결과를 반환하고 외부에 영향을 미치지 않는 함수(ex. useEffect 사용 최소화)
- 함수 네이밍 잘하기 - 누구나 이해할 수 있고 직접 호출하는 데에 사용되지 않더라도 복잡해지는 경우 알아보기 위한 네이밍

### 3장 - 클래스

- 객체 생성 함수 -> 클래스 -> 컴포넌트 변화 알기
- 클래스 컴포넌트에 어떻게 생명주기를 구현할 수 있는지, 왜 클래스 컴포넌트 생성을 위해 React.Component를 상속하는지, 메서드가 화살표 함수와 일반 함수일 때 어떤 차이가 있는지를 이해할 수 있다

### 4장 - 클로저

- 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분이 모두 클로저에 의존
- 자바스크립트는 기본적으로 함수 레벨 스코프를 가지고 있다 - O
- 클로저의 장점 - 전역 스코프의 사용을 막고 개발자가 원하는 정보만 원하는 방향으로 노출시킬 수 있다
- UseState 함수의 호출은 Component 내부 첫 줄에서 종료됐는데 setState는 useState 내부의 최신 값을 어떻게 계속 확인가능할까? - 클로저가 useState 내부에서 활용됐기 때문. 외부 함수가 반환한 내부 함수는 외부 함수의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경을 기억하기 때문에 계속해서 state 값 사용 가능
