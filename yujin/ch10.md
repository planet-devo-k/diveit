# 📚 React 핵심 진화 가이드: v17, v18, v19

이 문서는 리액트의 주요 버전별 변경 사항을 **인과관계** 중심으로 정리하여, 기술 도입의 배경과 실무적 이점을 한눈에 파악할 수 있도록 돕습니다.

---

## 1. React 17: 점진적 마이그레이션을 위한 기반 다지기

17버전은 새로운 기능 추가보다, 기존 구조의 결함을 해결하고 미래 버전으로의 안정적인 업그레이드 경로를 확보하는 데 집중했습니다.

### 주요 변경 사항 및 인과관계

**이벤트 위임(Event Delegation) 지점의 변경**

- **원인:** 기존(v16)에는 모든 이벤트를 HTML `document`에 부착했습니다. 이로 인해 한 페이지에 서로 다른 버전의 리액트 앱이 공존할 경우, 한쪽에서 호출한 `e.stopPropagation()`이 다른 쪽 앱의 이벤트 전파를 막지 못하는 충돌이 발생했습니다.
- **변화:** 이벤트를 `document`가 아닌 리액트의 **루트 요소(Container)**에 부착하도록 변경했습니다.
- **결과:** 각 리액트 앱이 독립적인 이벤트 영역을 갖게 되어, 여러 리액트 버전을 한 서비스에 섞어 쓰는 **'점진적 업그레이드'**와 **'마이크로 프론트엔드'** 구축이 안전해졌습니다.

**새로운 JSX Transform 도입**

- **원인:** 과거에는 JSX를 바벨이 `React.createElement`로 변환했기 때문에, 코드에서 직접 사용하지 않더라도 상단에 반드시 `import React from 'react'`를 선언해야 하는 번거로움이 있었습니다.
- **변화:** 리액트와 바벨이 협업하여 전용 함수(`jsx-runtime`)를 직접 호출하는 방식을 도입했습니다.
- **결과:** 불필요한 **import 구문이 삭제**되어 번들 크기가 감소했고, 리액트 모듈에 대한 의존성을 줄여 성능을 소폭 개선했습니다.

**이벤트 풀링(Event Pooling) 시스템 제거**

- **원인:** 메모리 절약을 위해 이벤트 객체를 재사용(풀링)했으나, 이로 인해 비동기 콜백 내부에서 이벤트 객체에 접근하면 값이 이미 `null`로 초기화되어 에러가 났습니다. 이를 막으려면 `e.persist()`를 써야 하는 등 코드가 직관적이지 않았습니다.
- **변화:** 현대 브라우저의 가비지 컬렉션 성능 향상에 따라 복잡한 **이벤트 풀링 시스템을 완전히 폐지**했습니다.
- **결과:** 비동기 콜백 안에서도 **`e.persist()` 없이 이벤트 객체에 안전하게 접근**할 수 있게 되어 코딩의 직관성이 높아졌습니다.

**useEffect 클린업(Cleanup)의 비동기 실행**

- **원인:** 기존에는 언마운트 시 클린업 함수가 동기적으로 처리되어, 클린업 작업이 길어질 경우 브라우저의 화면 업데이트(Paint)가 지연되는 성능 병목이 발생했습니다.
- **변화:** 화면 업데이트가 완전히 완료된 후 클린업이 실행되도록 **비동기 방식으로 변경**했습니다.
- **결과:** 컴포넌트 교체 시 화면 멈춤 현상이 줄어들어 **화면 업데이트 반영 시간(Commit Time)이 단축**되었습니다.

---

## 2. React 18: 동시성(Concurrency)과 UX 혁신

18버전은 리액트 엔진인 **Fiber**를 활용해 "중단 가능한 렌더링"을 구현함으로써 사용자 경험을 한 단계 끌어올렸습니다.

### 💡 핵심 아키텍처: Fiber & 더블 버퍼링

- **원인:** 기존 리액트는 렌더링이 시작되면 끝날 때까지 멈출 수 없었습니다(Blocking). 작업이 무거우면 그동안 사용자 입력(클릭, 타이핑)이 무시되어 UI가 먹통이 되는 현상이 발생했습니다.
- **변화:** 작업을 쪼갤 수 있는 **Fiber** 구조와, 백그라운드에서 다음 화면을 미리 그리는 **더블 버퍼링**을 통해 **동시성 렌더링**을 구현했습니다.
- **결과:** 리액트가 렌더링 도중에도 사용자 입력을 감지해 작업의 우선순위를 즉시 변경할 수 있게 되었습니다.

### 🛠 주요 기능의 인과관계

**자동 배치(Automatic Batching)**

- **변화:** `setTimeout`, `Promise` 등 비동기 로직 내의 여러 상태 업데이트를 하나로 묶어 처리합니다.
- **결과:** 불필요한 리렌더링 횟수를 줄여 전체적인 앱 성능을 향상시켰습니다.

**useTransition / useDeferredValue**

- **변화:** 특정 업데이트를 '긴급하지 않음'으로 분류하여 나중에 처리하게 합니다.
- **결과:** 무거운 리스트 렌더링 중에도 사용자의 타이핑이나 클릭은 즉시 반응하는 **빠른 인터페이스**를 유지합니다.

**useSyncExternalStore**

- **변화:** 외부 상태 관리 도구와 동시성 렌더링 간의 연결을 보장합니다.
- **결과:** 렌더링 도중 상태가 변해 데이터가 일치하지 않는 **Tearing(찢어짐) 현상**을 방지합니다.

---

## 3. React 19: 비동기 작업 및 서버 중심의 표준화

19버전은 비동기 통신과 서버 환경을 리액트의 기본 모델 안으로 완전히 편입시킨 "완결판"입니다.

### 액션(Actions) 모델의 도입

- **원인:** 비동기 요청 시 로딩(`isLoading`), 에러(`isError`) 상태를 매번 수동으로 관리해야 하는 복잡함이 있었습니다.
- **변화:** 비동기 함수를 리액트가 직접 이해하고 관리하는 **Action** 단위를 도입했습니다.
- **결과:** `useActionState`, `useFormStatus` 등을 통해 **로딩/성공/실패 처리를 선언적**으로 관리하며 코드가 획기적으로 간결해졌습니다.

### 낙관적 업데이트(Optimistic UI)

- **원인:** 네트워크 지연은 사용자에게 불확실성을 주며, 버튼 클릭 후 반응이 없으면 사용자는 앱이 고장 났다고 판단해 이탈합니다.
- **변화:** `useOptimistic` 훅을 통해 서버 응답 전 성공 결과를 UI에 즉시 반영합니다.
- **결과:** 지연 없는 즉각적인 피드백을 제공하며, 실패 시 리액트가 자동으로 **이전 상태로 복구(Rollback)**하여 안정성을 확보합니다.

### 🛠 개발자 경험(DX) 혁신

- **Ref의 일반 Prop화:** `forwardRef`의 복잡함을 해결하고 `ref`를 일반 props로 전달 가능하게 하여 개발 편의성을 높였습니다.
- **use() API:** 렌더링 중 Promise나 Context를 읽어오는 기능을 통해, 비동기 데이터를 다루는 흐름을 직관적으로 바꿨습니다.
- **메타데이터/리소스 호이스팅:** 컴포넌트 내의 `<title>`, `<link>` 등을 리액트가 자동으로 `<head>`로 옮겨주어 SEO와 성능 최적화를 자동화했습니다.

---

### 📝 기타 용어 정리

- **이벤트 위임:** 상위 요소 하나에만 이벤트를 부착하여 하위 요소의 이벤트를 제어하는 방식 (캡처링 → 타깃 → 버블링 단계 활용).

**Throttling vs Debouncing:**

- **Throttling:** 이벤트가 계속 발생해도 일정 시간 간격으로 실행을 보장 (예: 스크롤 애니메이션).
- **Debouncing:** 마지막 이벤트 발생 후 특정 시간 대기 후 1회 실행 (예: 검색창 자동완성).
